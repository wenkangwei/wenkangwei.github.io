{"pages":[{"title":"","text":"","link":"/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"images","text":"","link":"/images/index.html"},{"title":"Wenkang Wei","text":"My Websites Coding practice website: https://wenkangwei.gitbook.io/leetcode-notes/It summaries of coding practice and implementation of algorithms Technical blog: https://wenkangwei.github.io/It summaries of algorithms and projects Source code repository: https://github.com/wenkangweiIt stores my open source projects, source codes and some datasets Who am I? My ResumeMachine Learning Fan and Researcher - Iâ€™m a second-year master student of computer engineering with minor of Computer Science. So far, Iâ€™m doing researches about deep learning and data mining. Iâ€™m working with Dr. Adam hoover on Human activity (Eating) pattern recognition research. Iâ€™m also a research assistant in Clemson-Clair Lab of Dr. Kai Liu with research topic of machine learning optimization. Job Seeker - Iâ€™m actively looking for a full-time job related to Data Scientist or Machine Learning Engineer that starts from Summer 2021 after my graduation in May 2021My Resume can be found Here or LinkedInYou are welcomed to email me if you have any suggestion or reference to me. blogger - I find that writing blogs can help me manage my tehcnical notes and problems I solved in the past. Whatâ€™s more, it provides a platform for me to communicate techniques with more people. Iâ€™m trying to manage my technical notes and my thoughts on some problems I wrote in the past. Geek - I usually find some technical projects to do once Iâ€™m leisure. Some projects are inspired by my daily life, my classes on campus and my researches. To know more about it, Click HERE Dreamer - I usually imagine how our brains work and ponder how AI will collaborate with human in the future and how can we borrow human learning behaviors or architectures of human brain to design a new AI algorithm. Hopefully, the secret behine human brain can be revealed one day. Amateur of paintingIâ€™m a fan of japanese animes and hence sometimes do some paintings related to anime characters. Educational BackgroundIâ€™m a master student of computer engineering with the focus area of intelligent system and pattern recogniton. I have received the BS degree with EE major and named to Deanâ€™s List as well in Clemson Univeristy. If you are interested in my academic achievements, Click HERE Work ExperienceMachine Learning Research Assistant - Summer 2020-Current Proof of convergence and convergence rate of Multiple Update Algorithm (MUA) in Non-Negative Matrix Factorization Problem Formulated Matrix Factorization Problem into Constraint Optimization Problem Applied Linear Algebra, Lagrange multiplier to simplify problem and utilized Lipschitz gradient, convex optimization to prove the convergence and convergence rate of MUA algorithm Implemented MUA and ALS (alternative least square) algorithm in Google Colab and Matlab to verify convergence result Collaborated and communicated with CS professor Dr Kai Liu to present mathematic proof process orally Wrote a paper in AAAI format using Latex (unpublished due to copyright reason) Technical Skills Programming: Python/Jupyter Notebook PostgreSQL C/C++ Matlab HTML, Markdown, Latex Tools: Deep Learning Framework: PyTorch / Tensorflow Distributed Machine Learning: PySpark, Hadoop MapReduce,MPI Data Analysis toolkits: sklearn, pandas, seaborn, etc Platform: Raspberry Pi, Linux, Google Colab, Git, AWS (RDS, EC2) Theory and Analysis Techniques: Feature Engineering, Data Visualization and Preprocessing Techniques, PCA, NLP text processing: Word Embedding, TF-IDF, etc Machine Learning Modeling: Collaborate Filtering, Matrix Factorization, SVM, Decision Tree, Clustering, Convolution Neural Network etc Techniques for Model Evaluation and Improvement: Cross-Validation, Ensemble Learning, ROC, AUC, Feature Importance, etc. Selected ProjectsImage Classification Car Classification using Transfer Learning - Fall 2020 Constructed data pipeline by PyTorch to extracted and transformed Stanford car images dataset (1.96GB dataset with 196 classes) Modified and tuned pre-trained models Google-Net, VGG-16 , Res-Net 50 to fit car dataset using early stopping, weight decay techniques Improved test accuracy of the best model to 85% using cross-validation model selection techniques Recommendation System Recommendation System based on MovieLens 25M dataset ((PySpark, Hadoop, HDFS, SQL) Utilized PySpark to load movielens 25M dataset (25 million ratings) and used SQL to query and analyze data in databrick cluster platform Implemented and applied Mapper, Reducer functions in Hadoop File system to analyze contribution of different movie genres to ratings Applied Collaborative Filtering and Matrix Factorization methods to construct a recommendation system with PySpark Achieved 0.67 mean square error score and deployed recommendation system using IPython widget KKBox Music Recommendation System Utilized Exploratory Data Analysis (EDA) techniques and data visualization to analyze relationship between features Constructed Data pipeline to clean data by filling missing values, converting data type and transform data using OneHot encoding, Embedding, etc. Implemented and applied Light gradient boosting machine and wide and deep neural network for recommendation system Data Science and NLP Bank Churn Prediction Visualized and analyzed data related to customer churn by using visualization toolkits: seaborn, matplotlib Preprocessed and transforms categorical data for Machine Learning model training using pandas toolkit and normalization techniques Established Data Pipeline and ML Models: Random Forest, Logistic Regression, SVM, etc. and Evaluated Models using ROC,AUC Improved Models Accuracy from 80% to 86% by using Model Selection, Cross Validation and Feature Selection, L1 Regularization techniques Youtube Comments Analysis and Pet Owners Classification (PySpark, SQL, Databrick Cluster) Utilized PySpark and PostgreSQL to load, query and explore Youtube comment text data (about 1GB after decompression) Built data pipeline and applied Term-Frequency-Inverse Document-Frequency(TF-IDF) to transform text data into numerical data Applied Logistic Regression, Random Forest, Gradient Boosting machine in PySpark to classify cat or dog owners from comments Achieved 92% prediction accuracy on test set using grid search and cross validation Software Development Real-time Signal Visualization System (C++, Qt, GDB) Designed a visualization software system based on Qt toolkit, Arduino using C/C++ to solve the problem of visualizing voltage signal data in real time with self-motivation and initiative Designed GUI components and class modules for software interface in Qt and software framework to control data visualization behaviors in C++ using data structure (queue) and Object-Oriented Programming (OOP) techniques Integrated, tested and debugged GUI components with software framework using GDB toolkit and Qt IDE Wrote technical document for software system in Github with video demo. Link to demo: https://github.com/wenkangwei/SerialPlot More projects will be uploaded soon. They are mentioned in my resume or LinkedIn. Please feel free to contact me via email: wenkanw@g.clemson.edu or LinkedIn if you have any questions or any job opportunities for me. Thanks! My InterestsResearch Interests:Data mining, Recommendation System, NLP, machine learning,deep learning and their applications. Other Interests:Anime, painting, music, badminton,swimmingâ€¦ My Framework for solving problems / researching You are welcomed to contact me by wenkangwei917@gmail.com or by https://github.com/wenkangwei if you have any suggestion on my projects or my blog.","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"src","text":"","link":"/src/index.html"}],"posts":[{"title":"Data Structure - BuckSort with Parallel Computing","text":"IntroductionThis article introduces the basic bucket sort algorithm and the parallel version of bucket sort Simple Bucket SortStep of Bucket Sort Create n buckets and each bucket has a range, such as [0,4) Assign every element of unsorted array to the corresponding bucket based on the range of bucket. Ex: element 3 should be assigned to the bucket with range [0,4) Sort every bucket using insertion sort or other sorting method Merge all buckets together based on range to get the overall sorted arrayExampleUsing two buckets with range: [0,5), [5, 10]12345678unsorted array: [10, 2 , 5, 9, 4, 6, 1] / \\assign element to buckets: [2,4,1] [10,5,9,6] | | Sort every bucket [1,2,4] [5,6,9,10]with insertion sortMerge buckets: [1,2,4,5,6,9,10] Analysis Time complexity: O(n) for assigning element to buckets. O(n^2) for insertion sort in insertion. When merging buckets to a new buckets: O(n). Depending on the insertion operation, the time complexity can be different. Average case: O(n) if we think insertion time is O(1), else O(n)+O(n^2) = O(n^2) when using insertion sortif using quicksort, mergesort, it becomes O(nlog(m))+O(n) = O(nlogm) Memory complexity: O(n), since we use buckets to store element, where n = number of bucket * size of bucket Bucket Sort with Parallel Computing methodStep of Bucket Sort of parallel version There are p computing nodes/processors For every computing node, it has 1 large bucket and m small bucket and p=m In processor 0, it divides unsorted array into pieces evenly to every processors Every small bucket / large bucket has its range Every processor breaks its own piece of array into its small buckets based on the range of small bucket Sort every small bucket using some sorting (quicksort, insertion sort, etc) Gather all small buckets that have the same range into the large bucket that have that range Sort every large bucket Merge all large buckets into a sorted array ExampleUsing two small buckets: b1, b2 and two large buckets: lb1, lb2, with range: [0,5), [5, 10].There are two computing nodes/processor 1234567891011121314unsorted array: [10, 2 , 5, 9, 4, 6, 1, 7] / \\2 nodes: node1: [10,2,5,9] node2: [4,6,1,7] | | Divide them into b1: [2] b2:[10,5,9] b1:[4,1] b2:[6,7]Small buckets | |Sort: b1:[2], b2:[5,9,10] b1:[1,4] b2:[6,7] | |Send to large buckets: node1: [2,1,4] node2: [5,9,10,6,7] | |Sort: node1: [1,2,4] node2: [5,6,7,9,10]Merge buckets: [1,2,4,5,6,7, 9,10] Analysis Time complexity: Average Case O(n) if we consider sorting time as O(1). Or O(nlogm) if we use quicksort/mergesort Memory Complexity: O(n) since we use p computing nodes , large buckets and m smaller buckets to store data Reference[1] https://media.geeksforgeeks.org/wp-content/uploads/BucketSort.png","link":"/2020/09/22/Data-Structure-BuckSort-Parallel-Computing/"},{"title":"DeepLearning -2 DropOut","text":"Introduction and Problem of OverfittingIn deep learning, Overfitting is a common problem, in which model fits the training data very well, but perform worse in test data / unseen data. This is due to that when the model learns general features of the dataset, it also learns some specific features in some specific samples well. It makes generalization error increase as well. Dropout is a regularization method that approximates training a large number of neural networks with different architectures in parallel. Or we can regard DropOut as a method of sampling sub-neural network within a full neural network by randomly selecting some neurons to feedforward and update weight. How DropOut WorkDropOut can be applied to any hidden layer. It is to randomly select some neurons in the hidden layer to output to the next layer. As the image shows here, in the second hidden layer, we randomly select some neurons to output and disable other neurons during feedforward process. Then in back propagation process, we only update the weights connected to those selected neurons. We can also regard DropOut as Sampling training technique in training weight. In back propagation, since we randomly sample neurons to output, it can be regarded as a 0,1 mask to multiply the output in hidden layer. So in back propagation, the gradient to the weights of ignored neurons will be zeros. Note that DropOut is applied in training step only. We DO NOT use dropout in prediction step as it can make the prediction unstable when randomly choosing different neurons for output. DropOut RateDropOut rate is the possibility of training a given node in a hidden layer. If dropout rate is large, then it is more likely to select and train the node in hidden layer. For example, if dropout rate = 0.1, then each node in a hidden layer has only 0.1 possibility of being trained (enabled to feedforward and back propagation) in training step. If dropout rate = 1, then all neurons in network will be trained. Code of dropout12345678910111213141516171819202122def forward(X): p = 0.5 # p is dropout rate out1 = np.maximum(0, np.dot(w1,X)+b1) mask1 = np.random.rand(*out1.shape) &lt; p # create dropout mask out1 *= mask # since we select parts of neurons for output, # the scale of out1 has changed, we need to use /p to # re-scale the output out1 /= p out2 = np.maximum(0, np.dot(w2,out1)+b2) mask2 = (np.random.rand(*out2.shape) &lt; p)/p out2 *= mask2 out3 = np.maximum(0, np.dot(w3,out2)+b3) return out3def predict(x): # In prediction, we don't need dropout as dropout make the output # difference and unstable out1 = np.maximum(0, np.dot(w1,X)+b1) out2 = np.maximum(0, np.dot(w2,out1)+b2) out3 = np.maximum(0, np.dot(w3,out2)+b3) return out3 Properties of DropOut dropout is one way to regularize neural network and avoid overfitting dropout is extremely effective and simple It can be applied to any hidden layer output Reference[1] https://machinelearningmastery.com dropout-for-regularizing-deep-neural-networks/ [2] https://blog.csdn.net/qq_28888837/article/details/84673884","link":"/2020/11/13/DL-DropOut/"},{"title":"Data Structure 3 - BinaryTree","text":"Binary TreeDefinition of Binary TreeThe settings of binary tree are following: Each node in the tree contains no more than 2 children nodes (left node, right node) Leaf nodes of the tree are the nodes that contain no children nodes Traversal of Binary TreeType of traversals of binary treeConsider this example of binary tree Pre-order traversalThe order of visiting nodes: current node -&gt; left children node -&gt; right children node.In the binary tree above, we start from the root node (current node) and follow the rule to visit each node. Then have cur_node= 10, left_node =5. when we goes to left_node 5, 5 becomes the new current node and hence print 5 and then its left_node 2. When it finds there is no left node after 2, it goes back to 5 and visit its right node.Repeat doing this, we have Pre-Order traversal of this binary tree: 10-&gt; 5-&gt;2-&gt; 7-&gt; 15-&gt;20 In-order traversalThe order of visiting nodes: left children node -&gt; current node -&gt; right children nodeSimilar to Pre-Order traversal, except the traversal order, In-order requires the current node is the second node to be visited. Hence, In-Order traversal of this example is: 2-&gt;5-&gt;7-&gt;10-&gt;15-&gt;20 Post-order traversalThe order of visiting nodes: left children node -&gt; right children node -&gt; current nodeSimilarly, Post-Order traversal of the example is: 2-&gt;7-&gt;5-&gt;15-&gt;20-&gt;10 Level-order traversalIt traverses the binary tree from top level to lower level. In each level of tree, it iterates the nodes from left to right. Level-Order traversal of this example: 10-&gt;5-&gt;15-&gt;2-&gt;7-&gt;20 Implementation of Traversal of Binary Tree Recursive Method Pre-OrderTime Complexity: O(n)Memory Complexity: O(h), h is the height of the tree. It is used by recursion to store address of function in stack 12345678910111213141516class TreeNode(): def __init__(self): self.left = None self.right = None self.val = Noneclass Solution(): def Pre_Order(self, root): if not root: return [] result = [] result.append(root.val) left_list = self.Pre_Order(root.left) right_list = self.Pre_Order(root.right) result.extend(left_list) result.extend(right_list) return result In-OrderTime Complexity: O(n)Memory Complexity: O(h), h is the height of the tree. It is used by recursion to store address of function in stack 1234567891011class Solution(): def In_Order(self, root): if not root: return [] result = [] left_list = self.In_Order(root.left) result.extend(left_list) result.append(root.val) right_list = self.In_Order(root.right) result.extend(right_list) return result Post-OrderTime Complexity: O(n)Memory Complexity: O(h), h is the height of the tree. It is used by recursion to store address of function in stack 1234567891011class Solution(): def Post_Order(self, root): if not root: return [] result = [] left_list = self.Post_Order(root.left) result.extend(left_list) right_list = self.Post_Order(root.right) result.extend(right_list) result.append(root.val) return result Iterative Method Pre-OrderTime Complexity: O(n)Memory Complexity: O(h), h is the height of the tree123456789101112131415161718192021222324class Solution(object): def PreOrder(self, root): \"\"\" input: TreeNode root return: Integer[] \"\"\" # write your solution here if not root: return [] stack = [(root, 1)] result = [] while len(stack)&gt;0: node, count = stack.pop() if count ==1: result.append(node.val) stack.append((node,2)) if node.left: node = node.left stack.append((node, 1)) if count == 2: if node.right: node= node.right stack.append((node,1)) return result In-OrderTime Complexity: O(n)Memory Complexity: O(h), h is the height of the tree123456789101112131415161718192021222324class Solution(object): def InOrder(self, root): \"\"\" input: TreeNode root return: Integer[] \"\"\" # write your solution here if not root: return [] stack = [(root, 1)] result = [] while len(stack)&gt;0: node, count = stack.pop() if count ==1: stack.append((node,2)) if node.left: node = node.left stack.append((node, 1)) if count == 2: result.append(node.val) if node.right: node= node.right stack.append((node,1)) return result Post-OrderTime Complexity: O(n)Memory Complexity: O(h)1234567891011121314151617181920212223242526class Solution(object): def PostOrder(self, root): \"\"\" input: TreeNode root return: Integer[] \"\"\" # write your solution here if not root: return [] stack = [(root, 1)] result = [] while len(stack)&gt;0: node, count = stack.pop() if count ==1: stack.append((node,2)) if node.left: node = node.left stack.append((node, 1)) if count == 2: stack.append((node, 3)) if node.right: node= node.right stack.append((node,1)) if count==3: result.append(node.val) return result Level-OrderTime Complexity: O(n)Memory Complexity: O(h)1234567891011121314151617class Solution(object): def LevelOrder(self,root): if not root: return [] queue = [root] result = [] while len(queue) &gt;0: # dequeue node = queue[0] del queue[0] result.append(node.val) # enqueue if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result Special Binary Tree1. Balanced Binary TreeBalanced Binary Tree is a tree that the depth of left and right subtrees of every node differ by 1 or less.Hence, for each node in the tree, we need to check the heights of left, right subtrees.In the examples below: Example 1 is a balanced tree, but Example 2 is not, since left and right subtrees of the node of 20 in example 2 has the height difference 2-0 = 2 &gt;1. 2. Complete Binary TreeA Binary Tree is a complete Binary Tree if all the levels are completely filled except possibly the last level and the last level has all keys as left as possibleConsider the following example: 12345 10 / \\ 5 1 / \\ / 2 4 2 This is an complete as well as balanced tree.However, the following one is balanced but not complete tree, since in the last level, all keys are not as left as possible as the node 2 should be in the left node, but it doesnâ€™t. 12345 10 / \\ 5 1 / \\ \\2 4 2 4. Perfect Binary TreePerfect Binary Tree A Binary tree is a Perfect Binary Tree in which all the internal nodes have two children and all leaf nodes are at the same level. Example of a perfect tree 12345 10 / \\ 5 1 / \\ / \\2 4 3 2 Example of not a perfect tree 12345 10 / \\ 5 1 / \\ /2 4 3 This is a complete, balanced binary tree, but not a perfect tree 5. Binary Search TreeBinary search tree is a tree that for every node in the tree, the values in left subtree are smaller than its value, the values in right subtree are greater than its.if we consider the duplicated values in the tree, the values in right subtree can be greater than or equal to the node value. This case should be discussed if duplicated values exist. This difference should be determined when discussing with the hiring manager Example of Binary Search Tree 12345 10 / \\ 5 11 / \\ \\2 7 21 Example of Not a Binary Search Tree 12345 10 / \\ 5 1 / \\ \\2 7 21 6. AVL TreeAVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees cannot be more than one for all nodes.When inserting each element in the AVL tree, it will re-balance the tree automatically.The operations of this data structure will be demonstrated in future 7. Red-Black TreeRed-Black tree is also a self-balancing tree. It has the following constraints: Each node has a color either red or black Root of tree is always black No adjacent red nodes. The parent/ children of a red node could not be red. But there could be adjacent black nodes Every path from a node (including root) to any of its descendant NULL node has the same number of black nodes.Example: Every path starting from node 18 to NiL/ None, have the same amount of black node 1. SummaryIn future, I may write the notes about more operations about binary tree, AVL tree, Red-Black Tree, just like computing height of tree, isBalanced, isSymmetric, insertion and deletion of element in AVL tree/Red-Black tree Reference[1] https://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/[2] https://www.geeksforgeeks.org/avl-tree-set-1-insertion/[3] https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9","link":"/2020/09/05/Data-Structure-BinaryTree/"},{"title":"Distributed Computing Basic Note - 1","text":"IntroductionThis blog introduces basic types of parallel computing architecture, memory, and basic evaluation metrics of parallel computing. Parallel Computing Features of Parallel computing Features of Problem: problem task can be broken into discrete pieces of work Problem can be solved faster with multiple computing resource than single resource Features of Computing resource Single computer with multiple processors Multiple computers connected in network Combine 1,2 Special computing component (GPU) Execution Execute multiple instructions concurrently in time Relationship between Parallel, Distributed, Cluster, Concurrency Computing:$ Cluster Computing \\subset Distributed Computing \\subset Parallel computing \\subset Concurrencty Computing$ Evaluation of Computing performanceAmdahlâ€™s LawAssume:$f_s$: fraction that the program is not parallelizable (the ratio of series part to whole program)Or called portion of series in the programp: Number of processor$t_p$: runtime of parallelizable operation$t_s$: runtime of series operationS(p): Parallel SpeedupThenAmdahlâ€™s Law: $t_p = f_s S(p) + \\frac{(1-p)f_s}{p} $ Parallel SpeedupParallel Speedup: $S(p) = \\frac{t_s}{t_p} = \\frac{p}{(p-1)*f+1}$. Usually Parallel Speedup $S(p) \\leq p$ Limiting Factors affecting Parallel Speedup: Not parallelizable code (or Series operation runtime): $t_s$. Longer runtime series code takes, larger $f_s$ is and Smaller the Parallel Efficiency is Communication Overhead: more time is spent on communication, then it also increases $t_s$ Parallel EfficiencyParallel Efficiency: $E = \\frac{S(p)}{p} = \\frac{1}{(p-1)*f + 1}$Parallel Efficiency measures how efficient the parallelization is. Higher Efficiency is, more busy each processor is and Faster the operations are executed. So we want to increase parallel Efficiency and maximize the ratio between S(p) and p. Type of Parallel Speedup Linear Speedup (normal case): $S(p) &lt; p$ Sublinear Speedup: $S(p) = p$ Superlinear Speedup: $S(p) &gt; p$ limiting Factors lead to superlilnear Speedup: Poor sequential reference implementation, leading to $t_s$ very large and series runtime very large 2. Memory caching: when memory cache is small, it will increase $t_s$ and lead to lower processing speed such that $t_s &gt;t_p$ and S(p) &gt;p3. I/O blocking : block I/O leads to delay of runtime, $t_s$ will increase Types of ComputersFlynneâ€™s TaxonomyThis taxonomy classifies the computer architecture into four types: SISD: Single Instruction Single Datastream SIMD: Single Instruction Multiple Datastreams MISD: Multiple Instructions Single Datastream MIMD: Multiple Instructions Multiple Datastreams Note: SIMD, MISD, MIMD architecture belongs to parallel computer since they satisfy the requirements of feature in parallel computing ( break task into piece, execute multiple(same or different )instrutions concurrently, etc) Type of Memory Shared MemoryMultiple processors share the same memory Distributed Memory and Message PassingMultiple processors have its own memory but use message passing method to communicate with each other distributedly across network. Hyper-ModelCombining Shared memory and distributed Memory together. Heterogeneous computing (accelerators) GPU FPGA Benchmarking and Ranking supercomputers LINPACK (Linear Algebra Package): Dense Matrix Solver HPCC: High-Performance Computing Challenge SHOC: Scalable Heterogeneous Computing - Non-traditional systems (GPU) TestDFSIO - I/O Performance of MapReduce/Hadoop Distributed File System","link":"/2020/09/20/Distributed-Computing-note-1/"},{"title":"Data Structure 1 - Binary Search","text":"Summary of Binary Search (also called half-interval search)Given an array A = [a0, a1,â€¦.an], where elements are in increasing order, that is, a1&lt; a2 &lt;â€¦&lt; an. We are going to find the index of an element ak inside the array.Let consider the array below, where a0=1, a1=3â€¦ index 0 1 â€¦ k â€¦ n a[i] a[0] = 1 a[1] =3 â€¦ a[k] = ak =10 â€¦ a[n]=an= 20 let set left variable L store index of a1 and right variable R stores index of an. Then Let L=0, R=n Check if a[L]=ak or a[R]=ak. If yes, return index of ak. Otherwise, step3 Find middle index M =$\\frac{(L+R)}{2}$ and check if a[M]=ak. If no, continue if a[M]&gt;ak, let R=M and search subarray between index L~ MReason:we know array is in increasing order and elements between M and R must be larger than a[M] and ak. Hence we only need to search elements between L and M if a[M]&lt;ak, let L=M search subarray between index M~ RThe logic is similar to step 4 Back to Step 3 until ak is found, Or R = L+1, that is, ak is not found. Analysis Computational Complexity: O($log_2(n)$) since it makes $log_2 n$ iterations. Space complexity of binary search is O(1) My Thoughts Its main idea is to reduce the searching space by half each time by using mid-intervel Assumption It requires we know L and R It assumes the array has been sorted. If the array has not been sorted, we can use Binary-Search-Tree to sort and store data and then use in-order traversal to obtain index of each element When to Apply It is good to search specific values that can be found by comparison of values However, in my opinion, It is not good enough to explore the combination of elements. For example, Finding the max sum of N numbers in an array. Then the searching space would be too large to find when using binary search. Extension Extensive Problem 1:Given a very very large (may be infinite) array and we donâ€™t know how large it is. Use binary search to find the index of a given element ak. Example: Given an array like this, a1 a2 â€¦ ak â€¦(we donâ€™t know the end of the array) 1 3 â€¦ a[k] â€¦ Analysis: since we donâ€™t know the size of array, we are hardly to find the right boundary R we only know the left boundary L=0 Idea: Jump Out to find R: We can first find the smallest integer X, such that a[$z^X$]$\\geq$ ak, where z is positive integer, maybe 2, 10â€¦ Set R= $z^X$ Jump in to find ak: Apply binary search on the region between $z^{X-1}$ and $z^X$. Evaluate Time Complexity since jump out step is $z^X$, then the time required to find the region is O($log_Z$(n)). Time required to search ak insdie $z^{X-1}$ and $z^X$ is O($log_2$(n)) Total complexity is O($log_Z$(n) + $log_2$(n)) Compare the value of Z to find the best performance. __Draw the picture of $log_z(X)$ !__ Reference[1] â€œhttps://www.cdn.geeksforgeeks.org/wp-content/uploads/binary-tree-to-DLL.png&quot;","link":"/2020/07/19/Data-Structure-binary-search/"},{"title":"GNN-2-MessagePassing","text":"GNN-2-Message Passing æ¶ˆæ¯ä¼ é€’ç¥ç»ç½‘ç»œ1. Introductionåœ¨å›¾ç¥ç»ç½‘ç»œé‡Œé¢ï¼Œåœ¨å¯¹æ•°æ®å’Œæ ·æœ¬ä¹‹é—´çš„å…³ç³»è¿›è¡Œå»ºæ¨¡å¾—åˆ°å›¾çš„edgeï¼Œ nodeä¹‹åï¼Œæˆ‘ä»¬éœ€è¦åœ¨å›¾é‡Œé¢æŠŠæ¯ä¸ªèŠ‚ç‚¹çš„ä¿¡æ¯æ ¹æ®å®ƒçš„neighborçš„ä¿¡æ¯è¿›è¡Œæ›´æ–°ï¼Œä»è€Œè¾¾åˆ°nodeçš„ä¿¡æ¯æ›´æ–°å’ŒèŠ‚ç‚¹ç‰¹å¾(Node Representation)çš„ç‰¹å¾è¡¨è¾¾ã€‚è€Œè¿™ä¸ªæŠŠnodeèŠ‚ç‚¹ä¿¡æ¯ç›¸äº’ä¼ é€’ä»è€Œæ›´æ–°èŠ‚ç‚¹è¡¨å¾çš„æ–¹æ³•ä¹Ÿå«Message Passingã€‚MessagePassingæ˜¯ä¸€ç§èšåˆé‚»æ¥èŠ‚ç‚¹ä¿¡æ¯æ¥æ›´æ–°ä¸­å¿ƒèŠ‚ç‚¹ä¿¡æ¯çš„èŒƒå¼ï¼Œå®ƒå°†å·ç§¯ç®—å­æ¨å¹¿åˆ°äº†ä¸è§„åˆ™æ•°æ®é¢†åŸŸï¼Œå®ç°äº†å›¾ä¸ç¥ç»ç½‘ç»œçš„è¿æ¥ã€‚æ¶ˆæ¯ä¼ é€’èŒƒå¼å› ä¸ºç®€å•ã€å¼ºå¤§çš„ç‰¹æ€§ï¼Œäºæ˜¯è¢«äººä»¬å¹¿æ³›åœ°ä½¿ç”¨ã€‚éµå¾ªæ¶ˆæ¯ä¼ é€’èŒƒå¼çš„å›¾ç¥ç»ç½‘ç»œè¢«ç§°ä¸ºæ¶ˆæ¯ä¼ é€’å›¾ç¥ç»ç½‘ç»œã€‚ è¿™ä¸€èŠ‚é‡Œé¢æˆ‘ä»¬è®¨è®ºå’Œå®è·µ å›¾ç¥ç»ç½‘ç»œä¸€ä¸‹å‡ ç‚¹: Message Passing çš„åŸç† PyG (PyTorch Geometric)é‡Œé¢çš„MessagePassingç±»çš„ç†è§£å’Œæ”¹å†™ é€šè¿‡MessagePassing, GCNConv æ­å»ºGraph Convolution Neural network (GCN) å¹¶é€šè¿‡å®é™…çš„æ•°æ®è¿›è¡Œè®­ç»ƒ å¯¹MessagePassingçš„åŸºç±»å‡½æ•°å¦‚ aggregationï¼Œ updateï¼Œ çš„methodè¿›è¡Œç†è§£å’Œä½¿ç”¨ Jupyter Notebook source code å¯ä»¥çœ‹è¿™é‡Œ: https://github.com/wenkangwei/Datawhale-Team-Learning/blob/main/GNN/Task-2-MessagePassing/GNN-Task-2-MessagePassing.ipynb æ³¨ï¼šè¿™ç¯‡æ–‡ç« å‚è€ƒäº†datawhaleæ•™å­¦æ–‡æ¡£, Torch Geometric å®˜æ–¹æ–‡æ¡£ï¼Œ Deep Learning on Graph, å¹¶æ·»åŠ äº†è‡ªå·±ä¸€äº›æƒ³æ³•ã€‚ 2.How Message Passing works Message Passingçš„åŸºæœ¬æ€è·¯ ä»¥å›¾ç‰‡ä¸ºä¾‹ï¼Œå¦‚æœæˆ‘ä»¬çš„ä»»åŠ¡æ˜¯node predictionå»é¢„æµ‹node Açš„ç‰¹å¾å€¼/node representationï¼Œé‚£ä¹ˆå›¾ç‰‡é‡Œnode Aå°±æ˜¯target nodeã€‚ç„¶å MessagePassingçš„è¿‡ç¨‹å¦‚ä¸‹ å›¾ä¸­é»„è‰²æ–¹æ¡†éƒ¨åˆ†å†…å®¹çš„æ˜¯ä¸€æ¬¡é‚»å±…èŠ‚ç‚¹ä¿¡æ¯ä¼ é€’åˆ°ä¸­å¿ƒèŠ‚ç‚¹çš„è¿‡ç¨‹ï¼šBèŠ‚ç‚¹çš„é‚»æ¥èŠ‚ç‚¹ï¼ˆA,Cï¼‰çš„ä¿¡æ¯ç»è¿‡å˜æ¢åèšåˆåˆ°BèŠ‚ç‚¹ï¼Œæ¥ç€BèŠ‚ç‚¹ä¿¡æ¯ä¸é‚»å±…èŠ‚ç‚¹èšåˆä¿¡æ¯ä¸€èµ·ç»è¿‡å˜æ¢å¾—åˆ°BèŠ‚ç‚¹çš„æ–°çš„èŠ‚ç‚¹ä¿¡æ¯ã€‚åŒæ—¶ï¼Œåˆ†åˆ«å¦‚çº¢è‰²å’Œç»¿è‰²æ–¹æ¡†éƒ¨åˆ†æ‰€ç¤ºï¼ŒåŒæ ·çš„è¿‡ç¨‹ï¼ŒCã€DèŠ‚ç‚¹çš„ä¿¡æ¯ä¹Ÿè¢«æ›´æ–°ã€‚å®é™…ä¸Šï¼ŒåŒæ ·çš„è¿‡ç¨‹åœ¨æ‰€æœ‰èŠ‚ç‚¹ä¸Šéƒ½è¿›è¡Œäº†ä¸€éï¼Œæ‰€æœ‰èŠ‚ç‚¹çš„ä¿¡æ¯éƒ½æ›´æ–°äº†ä¸€éã€‚ æ¯ä¸ªnodeçš„å€¼æ˜¯åŒæ—¶æ›´æ–°çš„ æŠŠæ­¥éª¤1 çš„â€œé‚»å±…èŠ‚ç‚¹ä¿¡æ¯ä¼ é€’åˆ°ä¸­å¿ƒèŠ‚ç‚¹çš„è¿‡ç¨‹â€è¿›è¡Œå¤šæ¬¡ã€‚å¦‚å›¾ä¸­è“è‰²æ–¹æ¡†éƒ¨åˆ†æ‰€ç¤ºï¼ŒAèŠ‚ç‚¹çš„é‚»æ¥èŠ‚ç‚¹ï¼ˆB,C,Dï¼‰çš„å·²ç»å‘ç”Ÿè¿‡ä¸€æ¬¡æ›´æ–°çš„èŠ‚ç‚¹ä¿¡æ¯ï¼Œç»è¿‡å˜æ¢ã€èšåˆã€å†å˜æ¢äº§ç”Ÿäº†AèŠ‚ç‚¹ç¬¬äºŒæ¬¡æ›´æ–°çš„èŠ‚ç‚¹ä¿¡æ¯ã€‚å¤šæ¬¡æ›´æ–°åçš„èŠ‚ç‚¹ä¿¡æ¯å°±ä½œä¸ºèŠ‚ç‚¹è¡¨å¾ã€‚ ä¸€å¥è¯æ€»ç»“å°±æ˜¯æ¯æ¬¡éƒ½æŠŠå›¾é‡Œé¢çš„nodeçš„ä¿¡æ¯æ ¹æ®é‚»å±…èŠ‚ç‚¹è¿›è¡Œæ›´æ–°ï¼Œå¹¶å¤šæ¬¡æŠŠå›¾çš„ä¿¡æ¯ä¸æ–­åˆ·æ–°å¾—åˆ°Node representationã€‚ Message Passing GNN çš„æ³›å¼ MessagePassingå›¾ç¥ç»ç½‘ç»œéµå¾ªä¸Šè¿°çš„â€œèšåˆé‚»æ¥èŠ‚ç‚¹ä¿¡æ¯æ¥æ›´æ–°ä¸­å¿ƒèŠ‚ç‚¹ä¿¡æ¯çš„è¿‡ç¨‹â€ï¼Œæ¥ç”ŸæˆèŠ‚ç‚¹è¡¨å¾ã€‚Message Passing GNNçš„é€šç”¨å…¬å¼å¯ä»¥æè¿°ä¸º $$\\mathbf{x}_ i^{(k)} = \\gamma^{(k)} ( \\mathbf{x}_ i^{(k-1)}, \\square_{j \\in \\mathcal{N}(i)} , \\phi^{(k)}(\\mathbf{x}_ i^{(k-1)}, \\mathbf{x}_ j^{(k-1)},\\mathbf{e}_{j,i}) ),$$ æ ¹æ®å®˜æ–¹æ–‡æ¡£ ä»¥åŠCREATING MESSAGE PASSING NETWORKS, æˆ‘ä»¬å®šä¹‰ $\\mathbf{x}^{(k-1)}_i\\in\\mathbb{R}^F$è¡¨ç¤ºç¥ç»ç½‘ç»œçš„$(k-1)$å±‚ä¸­èŠ‚ç‚¹$i$çš„èŠ‚ç‚¹è¡¨å¾ $\\mathbf{e}_{j,i} \\in \\mathbb{R}^D$ è¡¨ç¤ºä»èŠ‚ç‚¹$j$åˆ°èŠ‚ç‚¹$i$çš„è¾¹çš„å±æ€§ä¿¡æ¯ã€‚ $\\square$è¡¨ç¤ºå¯å¾®åˆ†çš„ã€å…·æœ‰æ’åˆ—ä¸å˜æ€§ï¼ˆå‡½æ•°è¾“å‡ºç»“æœä¸è¾“å…¥å‚æ•°çš„æ’åˆ—æ— å…³ï¼‰çš„å‡½æ•°, æ¯”å¦‚aggregation å‡½æ•°ã€‚æ¯”å¦‚sumï¼Œ mean, minç­‰å‡½æ•°å’Œè¾“å…¥çš„å‚æ•°é¡ºåºæ— å…³çš„å‡½æ•°ã€‚ $\\gamma$ : å¯å¾®åˆ†å¯å¯¼çš„update å‡½æ•°ï¼Œæ¯”å¦‚MLPsï¼ˆå¤šå±‚æ„ŸçŸ¥å™¨ï¼‰ $\\phi$: å¯å¾®åˆ†å¯å¯¼çš„message å‡½æ•°ï¼Œæ¯”å¦‚MLPsï¼ˆå¤šå±‚æ„ŸçŸ¥å™¨ï¼‰å’Œ linear Projectionç­‰ Note: ç¥ç»ç½‘ç»œçš„ç”ŸæˆèŠ‚ç‚¹è¡¨å¾çš„æ“ä½œç§°ä¸ºèŠ‚ç‚¹åµŒå…¥ï¼ˆNode Embeddingï¼‰ï¼ŒèŠ‚ç‚¹è¡¨å¾ä¹Ÿå¯ä»¥ç§°ä¸ºèŠ‚ç‚¹åµŒå…¥ã€‚è¿™é‡Œè€ƒè™‘èŠ‚ç‚¹åµŒå…¥åªä»£æŒ‡ç¥ç»ç½‘ç»œç”ŸæˆèŠ‚ç‚¹è¡¨å¾çš„æ“ä½œã€‚ æœªç»è¿‡è®­ç»ƒçš„å›¾ç¥ç»ç½‘ç»œç”Ÿæˆçš„èŠ‚ç‚¹è¡¨å¾è¿˜ä¸æ˜¯å¥½çš„èŠ‚ç‚¹è¡¨å¾ï¼Œå¥½çš„èŠ‚ç‚¹è¡¨å¾å¯ç”¨äºè¡¡é‡èŠ‚ç‚¹ä¹‹é—´çš„ç›¸ä¼¼æ€§ã€‚é€šè¿‡ç›‘ç£å­¦ä¹ å¯¹å›¾ç¥ç»ç½‘ç»œåšå¾ˆå¥½çš„è®­ç»ƒï¼Œå›¾ç¥ç»ç½‘ç»œæ‰å¯ä»¥ç”Ÿæˆå¥½çš„èŠ‚ç‚¹è¡¨å¾ã€‚æˆ‘ä»¬å°†åœ¨ç¬¬5èŠ‚ä»‹ç»æ­¤éƒ¨åˆ†å†…å®¹ã€‚ èŠ‚ç‚¹è¡¨å¾ä¸èŠ‚ç‚¹å±æ€§çš„åŒºåˆ†ï¼šéµå¾ªè¢«å¹¿æ³›ä½¿ç”¨çš„çº¦å®šï¼Œæ­¤æ¬¡ç»„é˜Ÿå­¦ä¹ æˆ‘ä»¬ä¹Ÿçº¦å®šï¼ŒèŠ‚ç‚¹å±æ€§data.xæ˜¯èŠ‚ç‚¹çš„ç¬¬0å±‚(GNNè¾“å…¥å±‚)èŠ‚ç‚¹è¡¨å¾ï¼Œç¬¬$h$å±‚çš„èŠ‚ç‚¹è¡¨å¾ç»è¿‡ä¸€æ¬¡çš„èŠ‚ç‚¹é—´ä¿¡æ¯ä¼ é€’äº§ç”Ÿç¬¬$h+1$å±‚çš„èŠ‚ç‚¹è¡¨å¾ã€‚ä¸è¿‡ï¼ŒèŠ‚ç‚¹å±æ€§ä¸å•æŒ‡data.xï¼Œå¹¿ä¹‰ä¸Šå®ƒå°±æŒ‡èŠ‚ç‚¹çš„å±æ€§ï¼Œå¦‚èŠ‚ç‚¹çš„åº¦(in-degree, out-degree)ç­‰ã€‚ 3.2 MessagePassing çš„Base Class å‡½æ•°3.2.1 propagate å‡½æ•°çš„è¾“å…¥propagate å‡½æ•°çš„è¾“å…¥ æœ‰edge_index, x (node embedding matrix), ä»¥åŠå…¶ä»–è‡ªå®šä¹‰çš„è¾“å…¥å‚æ•°(degree, normä¹‹ç±»çš„)ã€‚å…¶ä¸­edge_indexçš„å‚¨å­˜å½¢å¼å¦‚ä¸‹$$\\mathbf{Edge index}=[\\begin{array}{lllll} [0 &amp; 0&amp; 1&amp; 4&amp;..8] \\\\ [0&amp; 1&amp; 4&amp; 1&amp; ..9] \\\\ \\end{array}]$$å…¶ä¸­Edge_indexçš„shape = [2, amount of edge]. Edge_index[0]ç¬¬ä¸€è¡Œæ˜¯source nodeçš„indexï¼Œ Edge_index[1]ç¬¬äºŒè¡Œæ˜¯target nodeçš„index. Note å¦‚æœedge_index ç”¨ torch tensoræ¥å‚¨å­˜ï¼Œé‚£ä¹ˆpropagateå‡½æ•°ä¼šåˆ†åˆ«è°ƒç”¨message, aggregateçš„å‡½æ•° å¦‚æœedge_index ç”¨ torch_sparseçš„SparseTensorç±»æ¥å‚¨å­˜ï¼Œé‚£ä¹ˆpropagateå‡½æ•°ä¼šè°ƒç”¨message_and_aggregateçš„å‡½æ•°è€Œä¸æ˜¯ä¸¤ä¸ªå•ç‹¬çš„å‡½æ•° å½“edge_index, x(node embedding)è¾“å…¥åˆ°propagateåï¼Œå®ƒä¼šè‡ªåŠ¨é€šè¿‡ collect()å‡½æ•° æŠŠè¾“å…¥è§£æå¾—åˆ°ä»¥ä¸‹å‚æ•°: å¦‚æœflow=â€source_to_targetâ€: x_i: edge_indexçš„target nodeçš„indexåˆ—è¡¨(edge_index[1])å¯¹åº”çš„node embeddingå‘é‡åˆ—è¡¨ã€‚æ¯”å¦‚ edge_indexçš„target nodeåˆ—è¡¨æ˜¯ edge_index[1], length = E, è€Œnode embeddingçš„ç»´åº¦ä¸ºdim, é‚£ä¹ˆ x_i =x[edge_index[1]]æ˜¯edge_index[1]æ‰€å¯¹åº”çš„embeddingåˆ—è¡¨ï¼Œ x_içš„shape= [E, dim]ã€‚ä¸¾ä¸ªä¾‹å­å°±æ˜¯ target node çš„ç´¢å¼•åˆ—è¡¨æ˜¯ edge_index[1] = [0, 1, 2]è€Œ E=3, dim=2, é‚£ä¹ˆ x_i = [[0.5,0.6],[0.1,0.22],[0.2,0.3]]ã€‚x_ié‡Œé¢çš„æ¯ä¸€è¡Œåˆ†åˆ«å¯¹åº”target node 0, 1,2çš„node embeddingå‘é‡ deg_i: edge_indexçš„target nodeçš„indexåˆ—è¡¨å¯¹åº”çš„degreeåˆ—è¡¨ã€‚è¿™ä¸ªå’Œx_iåŒç† x_jï¼šedge_indexçš„source nodeçš„edge_index[0]åˆ—è¡¨å¯¹åº”çš„node embeddingå‘é‡åˆ—è¡¨ã€‚ deg_j: edge_indexçš„source nodeçš„edge_index[0]åˆ—è¡¨å¯¹åº”çš„degreeåˆ—è¡¨ã€‚è¿™ä¸ªå’Œx_jåŒç† å¦‚æœflow=â€target_to_sourceâ€ é‚£ä¹ˆæœ‰_ iåç¼€ä»£è¡¨source, _ jåç¼€ä»£è¡¨target node åœ¨å¾—åˆ°target nodeçš„edge_indexå’Œ å¯¹åº”çš„source nodeçš„node embedding vectorsä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥æŠŠæ¯ä¸ªtarget nodeå¯¹åº”çš„æ‰€æœ‰node embeddingå‘é‡èšåˆä¸€èµ·å¾—åˆ°target nodeçš„ä¿¡æ¯é›†åˆç”¨äºæ­å»º messageäº†3.2.2 message å‡½æ•°çš„è¾“å…¥message å‡½æ•°è¾“å…¥ä¸€èˆ¬åŒ…æ‹¬: x_i, x_j, deg_i, deg_j, edge_indexä»¥åŠå…¶ä»–è‡ªå®šä¹‰çš„å‚æ•°è¾“å…¥ 3.2.3 aggregate å‡½æ•°çš„è¾“å…¥aggregate å‡½æ•°è¾“å…¥é™¤äº†æœ‰ inputs (æ¥è‡ªmessageå‡½æ•°çš„è¾“å…¥) å¤– ä¸€èˆ¬è¿˜åŒ…æ‹¬: inputs, x_i, x_j, deg_i, deg_j, edge_indexä»¥åŠå…¶ä»–è‡ªå®šä¹‰çš„å‚æ•°è¾“å…¥ã€‚ 3.2.4 message_and_aggregate å‡½æ•°çš„è¾“å…¥message_and_aggregate å‡½æ•°è¾“å…¥ ä¸€èˆ¬è¿˜åŒ…æ‹¬: x_i, x_j, deg_i, deg_j, edge_indexä»¥åŠå…¶ä»–è‡ªå®šä¹‰çš„å‚æ•°è¾“å…¥ã€‚ 3.2.5 update å‡½æ•°çš„è¾“å…¥update å‡½æ•°è¾“å…¥åŒ…æ‹¬inputsä»¥åŠå…¶ä»–è‡ªå®šä¹‰çš„å‚æ•°è¾“å…¥ã€‚ 12 4. Coding Practice4.1 åŸºäº Message Passingçš„æ³›å¼(æ¡†æ¶)æ­å»ºGraph Convolution Network (GCN)æ ¹æ®PyGçš„å®˜æ–¹æ–‡æ¡£ï¼Œ**GCNConv** çš„å…¬å¼æ˜¯$$\\mathbf{x}_ i^{(k)} = \\sum_{j \\in \\mathcal{N}(i) \\cup { i }} \\frac{1}{\\sqrt{\\deg(i)} \\cdot \\sqrt{\\deg(j)}} \\cdot ( \\mathbf{\\Theta} \\cdot \\mathbf{x}_ j^{(k-1)} ),$$ çŸ©é˜µçš„å½¢å¼æ˜¯$$\\mathbf{X}^{(k)} = \\mathbf{D}^{-0.5}\\mathbf{A}\\mathbf{D}^{-0.5}\\mathbf{X}^{(k-1)}\\mathbf{\\Theta}$$ å…¶ä¸­ï¼Œ$\\mathbf{x}_i$ çš„èŠ‚ç‚¹çš„ç‰¹å¾æ˜¯ç”±å®ƒçš„è¿‘é‚»çš„nodeçš„ä¿¡æ¯(åŒ…æ‹¬node iè‡ªå·±)è¿›è¡Œæ›´æ–°ï¼Œæ‰€ä»¥è®¡ç®—æ—¶jæ˜¯èŠ‚ç‚¹içš„é‚»å±…(åŒ…æ‹¬èŠ‚ç‚¹iæœ¬èº«)çš„å­é›†é‡Œé¢çš„nodeã€‚ é‚»æ¥èŠ‚ç‚¹çš„è¡¨å¾$\\mathbf{x}_j^{(k-1)}$é¦–å…ˆé€šè¿‡ä¸æƒé‡çŸ©é˜µ$\\mathbf{\\Theta}$ç›¸ä¹˜è¿›è¡Œå˜æ¢ï¼Œç„¶åæŒ‰ç«¯ç‚¹çš„åº¦$\\deg(i), \\deg(j)$è¿›è¡Œå½’ä¸€åŒ–å¤„ç†ï¼Œæœ€åè¿›è¡Œæ±‚å’Œã€‚è¿™ä¸ªå…¬å¼å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š å‘é‚»æ¥çŸ©é˜µæ·»åŠ è‡ªç¯è¾¹ã€‚ å¯¹èŠ‚ç‚¹è¡¨å¾åšçº¿æ€§è½¬æ¢ã€‚ è®¡ç®—å½’ä¸€åŒ–ç³»æ•°ã€‚ å½’ä¸€åŒ–é‚»æ¥èŠ‚ç‚¹çš„èŠ‚ç‚¹è¡¨å¾ã€‚ å°†ç›¸é‚»èŠ‚ç‚¹è¡¨å¾ç›¸åŠ ï¼ˆâ€æ±‚å’Œ â€œèšåˆï¼‰ã€‚ æ­¥éª¤1-3é€šå¸¸æ˜¯åœ¨æ¶ˆæ¯ä¼ é€’å‘ç”Ÿä¹‹å‰è®¡ç®—çš„ã€‚æ­¥éª¤4-5å¯ä»¥ä½¿ç”¨MessagePassingåŸºç±»è½»æ¾å¤„ç†ã€‚è¯¥å±‚çš„å…¨éƒ¨å®ç°å¦‚ä¸‹æ‰€ç¤ºã€‚ 12345678910111213141516171819202122232425262728293031323334353637from torch_geometric.nn import MessagePassingfrom torch_geometric.utils import add_self_loops, degreeimport torchclass GCNConv(MessagePassing): def __init__(self, in_channels, out_channels): super(GCNConv, self).__init__(aggr='add') # \"Add\" aggregation (Step 5). self.lin = torch.nn.Linear(in_channels, out_channels) def forward(self, x, edge_index): # x has shape [N, in_channels] # edge_index has shape [2, E] # Step 1: Add self-loops to the adjacency matrix. # Adds a self-loop (i,i)âˆˆE to every node iâˆˆV in the graph given by edge_index. # In case the graph is weighted, self-loops will be added with edge weights denoted by fill_value. edge_index, _ = add_self_loops(edge_index, num_nodes=x.size(0)) # Step 2: Linearly transform node feature matrix. x = self.lin(x) # Step 3: Compute normalization: 1/sqrt(degree(i)) * 1/sqrt(degree(j)) row, col = edge_index deg = degree(col, x.size(0), dtype=x.dtype) deg_inv_sqrt = deg.pow(-0.5) deg_inv_sqrt[deg_inv_sqrt == float('inf')] = 0 norm = deg_inv_sqrt[row] * deg_inv_sqrt[col] # Step 4-5: Start propagating messages. return self.propagate(edge_index, x=x, norm=norm) def message(self, x_j, norm): # x_j has shape [E, out_channels] # Step 4: Normalize node features. return norm.view(-1, 1) * x_j 12## download data to current directory#! wget https://github.com/kimiyoung/planetoid/raw/master/data/ind.cora.x 123456789101112131415from torch_geometric.datasets import Planetoiddataset = Planetoid(root='./dataset/Cora', name='Cora')data = dataset[0]# GCNConv: #in_channels: dimension of input vector of linear layer# out_channels: dimension of output vector of linear layer#Note: the linear transform is performed before message passing to reduce the dimension of node representation# After message passing, the amount of nodes doesn't changenet = GCNConv(data.num_features, 64)# data.x: a matrix with each row representing the data in a node# data.edge_index: matrix with shape [2, number of edges], each column representing edge from node to another node, value=index of nodeh_nodes = net(data.x, data.edge_index)print(h_nodes.shape) torch.Size([2708, 64]) 1data.x.shape torch.Size([2708, 1433]) 12 4.2 Overwrite methods: messsage, aggregate, update1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from torch_geometric.datasets import Planetoidimport torchfrom torch_geometric.nn import MessagePassingfrom torch_geometric.utils import add_self_loops, degreefrom torch_sparse import SparseTensorclass GCNConv(MessagePassing): def __init__(self, in_channels, out_channels): super(GCNConv, self).__init__(aggr='add', flow='source_to_target') # \"Add\" aggregation (Step 5). # flow='source_to_target' è¡¨ç¤ºæ¶ˆæ¯ä»æºèŠ‚ç‚¹ä¼ æ’­åˆ°ç›®æ ‡èŠ‚ç‚¹ self.lin = torch.nn.Linear(in_channels, out_channels) def forward(self, x, edge_index): # x has shape [N, in_channels] # edge_index has shape [2, E] # Step 1: Add self-loops to the adjacency matrix. print(\"Before self-loop:\",edge_index.shape) edge_index, _ = add_self_loops(edge_index, num_nodes=x.size(0)) print(\"After self-loop:\",edge_index.shape) # Step 2: Linearly transform node feature matrix. x = self.lin(x) # Step 3: Compute normalization. row, col = edge_index deg = degree(col, x.size(0), dtype=x.dtype) deg_inv_sqrt = deg.pow(-0.5) norm = deg_inv_sqrt[row] * deg_inv_sqrt[col] # Step 4-5: Start propagating messages. # Convert edge index to a sparse adjacency matrix representation, with row = from nodes, col = to nodes, value = 0 or 1 indicating if # two nodes are adjacent. adjmat = SparseTensor(row=edge_index[0], col=edge_index[1], value=torch.ones(edge_index.shape[1])) #print(\"Adjacency matrix:\",adjmat) # æ­¤å¤„ä¼ çš„ä¸å†æ˜¯edge_idexï¼Œè€Œæ˜¯SparseTensorç±»å‹çš„Adjancency Matrix return self.propagate(adjmat, x=x, norm=norm, deg=deg.view((-1, 1))) def message(self, x_j, norm, deg_i): # x_j has shape [E, out_channels] # deg_i has shape [E, 1] # Step 4: Normalize node features. return norm.view(-1, 1) * x_j * deg_i def aggregate(self, inputs, index, ptr, dim_size): print('self.aggr:', self.aggr) print(\"`aggregate` is called\") return super().aggregate(inputs, index, ptr=ptr, dim_size=dim_size) def message_and_aggregate(self, adj_t, x, norm): print('`message_and_aggregate` is called') # æ²¡æœ‰å®ç°çœŸå®çš„æ¶ˆæ¯ä¼ é€’ä¸æ¶ˆæ¯èšåˆçš„æ“ä½œ def update(self, inputs, deg): print(deg) return inputsdataset = Planetoid(root='dataset/Cora', name='Cora')data = dataset[0]net = GCNConv(data.num_features, 64)h_nodes = net(data.x, data.edge_index)# print(h_nodes.shape) Before self-loop: torch.Size([2, 10556]) After self-loop: torch.Size([2, 13264]) Adjacency matrix: SparseTensor(row=tensor([ 0, 0, 0, ..., 2707, 2707, 2707]), col=tensor([ 0, 633, 1862, ..., 1473, 2706, 2707]), val=tensor([1., 1., 1., ..., 1., 1., 1.]), size=(2708, 2708), nnz=13264, density=0.18%) `message_and_aggregate` is called tensor([[4.], [4.], [6.], ..., [2.], [5.], [5.]]) 5. Assignment5.1 Message Passing æœºåˆ¶æ€»ç»“Message Passing æ ¹æ®ä¸Šé¢è®¨è®ºçš„çš„æ¡†æ¶å…¬å¼ï¼Œåœ¨è®¾è®¡Message Passing çš„æµç¨‹å¯ä»¥å½’çº³ä¸ºä»¥ä¸‹å‡ ç‚¹: å®šä¹‰å’Œé€‰å– message å‡½æ•°ï¼Œğœ™(..)ï¼Œå¹¶æ ¹æ®å›¾çš„èŠ‚ç‚¹ä¿¡æ¯çš„è¾“å…¥($x_i^{k-1}, x_j^{k-1}, e_{i,j}$) å¯¹è¾“å…¥è¿›è¡Œå˜æ¢(å¯å¯¼çš„ï¼Œæ¯”å¦‚çº¿æ€§æŠ•æ˜ è¿›è¡Œé™ç»´æˆ–ä¹˜ä¸Šç³»æ•°ä¹‹ç±»çš„) å®šä¹‰å’Œé€‰å– aggregation å‡½æ•° $\\square(..)$, å¯¹è½¬æ¢åçš„ä¿¡æ¯è¿›è¡Œé‚»å±…èŠ‚ç‚¹çš„ä¿¡æ¯èšåˆå¤„ç†ï¼Œ å¸¸ç”¨çš„æœ‰sum, mean, maxä¹‹ç±»çš„ å®šä¹‰å’Œé€‰å–update()å‡½æ•°ï¼ˆ ğ›¾(..) ï¼‰ï¼ŒæŠŠåŸæœ¬çš„èŠ‚ç‚¹ä¿¡æ¯$x_i^{k-1}$ å’Œ èšåˆåçš„é‚»å±…èŠ‚ç‚¹ä¿¡æ¯($\\square(..)$ å‡½æ•°çš„è¾“å‡º)çš„ä¿¡æ¯è¿›è¡Œæ•´åˆï¼Œæ›´æ–°å½“å‰çš„èŠ‚ç‚¹ä¿¡æ¯å¾—åˆ°$x_j^{k}$ã€‚ ç”¨GCNçš„å…¬å¼ä¸¾ä¸ªæ —å­ï¼Œå°±æ˜¯$$\\mathbf{x}_ i^{(k)} = \\sum_{j \\in \\mathcal{N}(i) \\cup { i }} \\frac{1}{\\sqrt{\\deg(i)} \\cdot \\sqrt{\\deg(j)}} \\cdot ( \\mathbf{\\Theta} \\cdot \\mathbf{x}_ j^{(k-1)} ),$$ GCNé‡Œé¢çš„ $\\frac{1}{\\sqrt{\\deg(i)} \\cdot \\sqrt{\\deg(j)}} \\cdot ( \\mathbf{\\Theta} \\cdot \\mathbf{x}_j^{(k-1)} )$ çš„æ“ä½œï¼Œé‡Œé¢çš„$\\mathbf{\\Theta}$ çº¿æ€§æŠ•æ˜ å’Œç”¨degreeåšnormalizationç›¸å¯¹äºæ˜¯ ğœ™(..)å‡½æ•°çš„messageçš„æ­å»º è€Œ $\\sum_{j \\in \\mathcal{N}(i) \\cup { i }}$ è¿™ä¸€æ­¥ç›¸å¯¹äºæŠŠé‚»å±…èŠ‚ç‚¹(åŒ…æ‹¬èŠ‚ç‚¹è‡ªå·±)çš„ä¿¡æ¯è¿›è¡Œèšåˆ, ç›¸å¯¹äºaggregation å‡½æ•° $\\square(..)$ GCNè¿™é‡Œå› ä¸ºåœ¨åšäº†aggregationåæ²¡æœ‰ç”¨åˆ° $x_i^{k-1}$ä¿¡æ¯ï¼Œæ‰€ä»¥update()å‡½æ•°, ğ›¾($x_i^{k-1}, \\square(..)$) å¯ä»¥çœ‹æˆç›´æ¥è¾“å‡º(æˆ–è€…æ˜¯$\\square()$ä¿¡æ¯èšåˆåä¹˜ä¸Š1å°±è¾“å‡º)ã€‚ğ›¾(..)å…¶å®ä¹Ÿå¯ä»¥æ›¿æ¢ä¸ºå…¶ä»–å¯å¯¼çš„çš„éçº¿æ€§å‡½æ•°æ¯”å¦‚ logisticsï¼Œ reluä¹‹ç±»çš„ã€‚ è‡³äºMessagePassing çš„Base Classé‡Œé¢çš„message_and_aggregate()å¯ä»¥çœ‹æˆæ˜¯ $\\square(\\phi(x_i^{k-1}, x_j^{k-1}, e_{i,j}))$ MessagePassing çš„Base Classé‡Œé¢çš„propagate()å‡½æ•°å¯ä»¥çœ‹æˆæ˜¯å¯¹ $\\gamma(x_i^{k-1}, \\square(\\phi(â€¦)))$ æ›´æ–°å‡½æ•°çš„å°è£…ã€‚ è¿™ä¸€ç‚¹å¯ä»¥çœ‹çœ‹å®˜æ–¹æ–‡æ¡£çš„æºç  12 5.2 ç”¨MessagePassing è¿™ä¸ªBaseClasså»å®ç°ä¸€ä¸ªGCN layerè¿™é‡Œé€æ­¥å®ç°å®ç°ä¸€ä¸ªGCNï¼Œ å…¬å¼å¦‚ä¸‹: $$\\mathbf{x}_ i^{(k)} = \\sum_{j \\in \\mathcal{N}(i) \\cup { i }} \\frac{1}{\\sqrt{\\deg(i)} \\cdot \\sqrt{\\deg(j)}} \\cdot ( \\mathbf{\\Theta} \\cdot \\mathbf{x}_ j^{(k-1)} ),$$ è¿™é‡Œä¸€äº›å‡½æ•°å®šä¹‰å¦‚ä¸‹ï¼š $\\phi(..)$: messageå‡½æ•°GCNä¸€æ ·éƒ½æ˜¯linear projectionä¹‹åç”¨degreeè¿›è¡Œnormalization $\\square(..)$ : aggregate å‡½æ•°ç”¨ add $\\gamma(..)$: update å‡½æ•°æ˜¯ç›´æ¥å°†aggregateåçš„ç»“æœè¾“å‡º 5.2.1 è¦†å†™messageå‡½æ•°è¦æ±‚è¯¥å‡½æ•°æ¥æ”¶æ¶ˆæ¯ä¼ é€’æºèŠ‚ç‚¹å±æ€§xã€ç›®æ ‡èŠ‚ç‚¹åº¦d 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144from torch_geometric.datasets import Planetoidimport torchfrom torch import nn, Tensorfrom torch_geometric.nn import MessagePassingfrom torch_geometric.utils import add_self_loops, degreefrom torch_sparse import SparseTensor, matmulclass GCNConv(MessagePassing): def __init__(self, in_channels, out_channels): super(GCNConv, self).__init__(aggr='add', flow='source_to_target') # \"Add\" aggregation (Step 5). # flow='source_to_target' è¡¨ç¤ºæ¶ˆæ¯ä»æºèŠ‚ç‚¹ä¼ æ’­åˆ°ç›®æ ‡èŠ‚ç‚¹ self.lin = torch.nn.Linear(in_channels, out_channels) self.lin2 = torch.nn.Linear(out_channels, out_channels) self.relu = torch.nn.ReLU() def propagate(self, edge_index, size=None, **kwargs): # I just copy the source copy from PyG website r\"\"\"The initial call to start propagating messages. Args: edge_index (Tensor or SparseTensor): A :obj:`torch.LongTensor` or a :obj:`torch_sparse.SparseTensor` that defines the underlying graph connectivity/message passing flow. :obj:`edge_index` holds the indices of a general (sparse) assignment matrix of shape :obj:`[N, M]`. If :obj:`edge_index` is of type :obj:`torch.LongTensor`, its shape must be defined as :obj:`[2, num_messages]`, where messages from nodes in :obj:`edge_index[0]` are sent to nodes in :obj:`edge_index[1]` (in case :obj:`flow=\"source_to_target\"`). If :obj:`edge_index` is of type :obj:`torch_sparse.SparseTensor`, its sparse indices :obj:`(row, col)` should relate to :obj:`row = edge_index[1]` and :obj:`col = edge_index[0]`. The major difference between both formats is that we need to input the *transposed* sparse adjacency matrix into :func:`propagate`. size (tuple, optional): The size :obj:`(N, M)` of the assignment matrix in case :obj:`edge_index` is a :obj:`LongTensor`. If set to :obj:`None`, the size will be automatically inferred and assumed to be quadratic. This argument is ignored in case :obj:`edge_index` is a :obj:`torch_sparse.SparseTensor`. (default: :obj:`None`) **kwargs: Any additional data which is needed to construct and aggregate messages, and to update node embeddings. \"\"\" size = self.__check_input__(edge_index, size) # Run \"fused\" message and aggregation (if applicable). if (isinstance(edge_index, SparseTensor) and self.fuse and not self.__explain__): coll_dict = self.__collect__(self.__fused_user_args__, edge_index, size, kwargs) print(\"Using self-defined message-passing\") msg_aggr_kwargs = self.inspector.distribute( 'message_and_aggregate', coll_dict) out = self.message_and_aggregate(edge_index, **msg_aggr_kwargs) update_kwargs = self.inspector.distribute('update', coll_dict) return self.update(out, **update_kwargs) # Otherwise, run both functions in separation. elif isinstance(edge_index, Tensor) or not self.fuse: coll_dict = self.__collect__(self.__user_args__, edge_index, size, kwargs) msg_kwargs = self.inspector.distribute('message', coll_dict) #print(\"Message kwargs: \",msg_kwargs) out = self.message(**msg_kwargs) # For `GNNExplainer`, we require a separate message and aggregate # procedure since this allows us to inject the `edge_mask` into the # message passing computation scheme. if self.__explain__: edge_mask = self.__edge_mask__.sigmoid() # Some ops add self-loops to `edge_index`. We need to do the # same for `edge_mask` (but do not train those). if out.size(self.node_dim) != edge_mask.size(0): loop = edge_mask.new_ones(size[0]) edge_mask = torch.cat([edge_mask, loop], dim=0) assert out.size(self.node_dim) == edge_mask.size(0) out = out * edge_mask.view([-1] + [1] * (out.dim() - 1)) aggr_kwargs = self.inspector.distribute('aggregate', coll_dict) out = self.aggregate(out, **aggr_kwargs) update_kwargs = self.inspector.distribute('update', coll_dict) return self.update(out, **update_kwargs) def forward(self, x, edge_index): # x has shape [N, in_channels] # edge_index has shape [2, E] # Step 1: Add self-loops to the adjacency matrix. edge_index, _ = add_self_loops(edge_index, num_nodes=x.size(0)) # Step 2: Linearly transform node feature matrix. x = self.lin(x) # Compute degree. row, col = edge_index deg = degree(col, x.size(0), dtype=x.dtype) return self.propagate(edge_index, x=x, deg=deg.view((-1, 1))) def message(self, x_j, deg_i,deg_j): # Accoding to __collect__ function # in https://github.com/rusty1s/pytorch_geometric/blob/master/torch_geometric/nn/conv/message_passing.py # when flow = source_to_target # i= 1, j=0, edge_index_i = edge_index[1] = target, so # deg_i is degree of target node, and x_i is target node data # deg_j is degree of source node and x_j is source # x_j has shape [E, out_channels] # deg_i has shape [E, 1] # Step 3: Normalize node features. print(\"--message is called--\") print(\"x_j: \",x_j.shape) print(\"degree: \", deg_i.shape) print(\"degree: \",deg_j.shape) print() # check if degrees of source nodes and degrees of target nodes are equal print(torch.eq(deg_i, deg_j).all()) # compute normalization deg_i = deg_i.pow(-0.5) deg_j = deg_j.pow(-0.5) norm = deg_i * deg_j return norm.view(-1, 1) * x_jdataset = Planetoid(root='dataset/Cora', name='Cora')data = dataset[0]net = GCNConv(data.num_features, 64)h_nodes = net(data.x, data.edge_index)print(\"H_nodes: \", h_nodes.shape)h_nodes --message is called-- x_j: torch.Size([13264, 64]) degree: torch.Size([13264, 1]) degree: torch.Size([13264, 1]) tensor(False) H_nodes: torch.Size([2708, 64]) tensor([[-0.0336, -0.0263, -0.0141, ..., -0.0157, -0.0207, 0.0233], [-0.0204, -0.0698, -0.0737, ..., -0.0233, 0.0268, -0.0347], [-0.0437, -0.0602, -0.0162, ..., 0.0243, 0.0348, -0.0054], ..., [-0.0067, -0.0016, -0.0004, ..., 0.0237, -0.0289, 0.0044], [ 0.0061, 0.0198, -0.0076, ..., 0.0065, 0.0373, -0.0187], [ 0.0080, 0.0146, -0.0173, ..., -0.0250, 0.0205, 0.0163]], grad_fn=&lt;ScatterAddBackward&gt;) 12 5.2.2 åœ¨ç¬¬ä¸€ä¸ªç±»çš„åŸºç¡€ä¸Šï¼Œå†è¦†å†™aggregateå‡½æ•°è¦æ±‚ä¸èƒ½è°ƒç”¨superç±»çš„aggregateå‡½æ•°ï¼Œå¹¶ä¸”ä¸èƒ½ç›´æ¥å¤åˆ¶superç±»çš„aggregateå‡½æ•°å†…å®¹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101from torch_geometric.datasets import Planetoidimport torchfrom torch import nn, Tensorfrom torch_geometric.nn import MessagePassingfrom torch_geometric.utils import add_self_loops, degreefrom torch_sparse import SparseTensor, matmulclass GCNConv(MessagePassing): def __init__(self, in_channels, out_channels): super(GCNConv, self).__init__(aggr='add', flow='source_to_target') # \"Add\" aggregation (Step 5). # flow='source_to_target' è¡¨ç¤ºæ¶ˆæ¯ä»æºèŠ‚ç‚¹ä¼ æ’­åˆ°ç›®æ ‡èŠ‚ç‚¹ self.lin = torch.nn.Linear(in_channels, out_channels) self.lin2 = torch.nn.Linear(out_channels, out_channels) self.relu = torch.nn.ReLU() def forward(self, x, edge_index): # x has shape [N, in_channels] # edge_index has shape [2, E] # Step 1: Add self-loops to the adjacency matrix. edge_index, _ = add_self_loops(edge_index, num_nodes=x.size(0)) # Step 2: Linearly transform node feature matrix. x = self.lin(x) # Compute degree. row, col = edge_index deg = degree(col, x.size(0), dtype=x.dtype) return self.propagate(edge_index, x=x, deg=deg.view((-1, 1))) def message(self, x_j, deg_i,deg_j): # Accoding to __collect__ function # in https://github.com/rusty1s/pytorch_geometric/blob/master/torch_geometric/nn/conv/message_passing.py # when flow = source_to_target # i= 1, j=0, edge_index_i = edge_index[1] = target, so # deg_i is degree of target node, and x_i is target node data # deg_j is degree of source node and x_j is source # x_j has shape [E, out_channels] # deg_i has shape [E, 1] # Step 3: Normalize node features. print(\"--message is called--\") print(\"x_j: \",x_j.shape) print(\"degree: \", deg_i.shape) print(\"degree: \",deg_j.shape) print() # check if degrees of source nodes and degrees of target nodes are equal print(torch.eq(deg_i, deg_j).all()) # compute normalization deg_i = deg_i.pow(-0.5) deg_j = deg_j.pow(-0.5) norm = deg_i * deg_j return norm.view(-1, 1) * x_j def aggregate(self, inputs, index, ptr, dim_size): #from __collect__() function we know that # when flow = source_to_target # out['index'] = out['edge_index_i'] -&gt; input index = edge_index[i] = edge_index[1] = index of target node # inputs: embedding vectors of source nodes # inputs: the outputs from message function, the normalized source node embeding with shape [E, dim of embedding] print(\"--aggregate` is called--\") print('self.aggr:', self.aggr) print('ptr: ', ptr) print('dim_size: ',dim_size) print(\"inputs: \", inputs.shape) print(\"index: \",index.shape, len(index.unique())) print() uni_idx = index.unique() uni_idx.sort() res= [] # find all unique target node index # for each target node, aggregate(sum or mean ) the information from source node to the target node # and obtain target node embedding for i in uni_idx: # i is the index of target node neighbors = inputs[index == i] # aggregate along different vectors of different nodes if self.aggr==\"mean\": agg_res = neighbors.mean(axis=0) else: agg_res = neighbors.sum(axis=0) res.append(agg_res) res = torch.stack(res) return res dataset = Planetoid(root='dataset/Cora', name='Cora')data = dataset[0]net = GCNConv(data.num_features, 64)h_nodes = net(data.x, data.edge_index)print(\"H_nodes: \", h_nodes.shape)h_nodes --message is called-- x_j: torch.Size([13264, 64]) degree: torch.Size([13264, 1]) degree: torch.Size([13264, 1]) tensor(False) --aggregate` is called-- self.aggr: add ptr: None dim_size: 2708 inputs: torch.Size([13264, 64]) index: torch.Size([13264]) 2708 H_nodes: torch.Size([2708, 64]) tensor([[-0.0141, 0.0188, 0.0067, ..., -0.0314, 0.0296, -0.0301], [ 0.0056, -0.0510, 0.0796, ..., -0.0591, 0.0362, 0.0113], [-0.0034, 0.0314, 0.0107, ..., -0.0433, 0.0407, 0.0185], ..., [ 0.0280, 0.0239, 0.0307, ..., -0.0530, -0.0522, 0.0293], [-0.0094, 0.0380, -0.0108, ..., -0.0115, 0.0182, -0.0060], [-0.0058, -0.0127, -0.0221, ..., -0.0027, 0.0008, -0.0052]], grad_fn=&lt;StackBackward&gt;) 12 5.2.3 åœ¨ç¬¬äºŒä¸ªç±»çš„åŸºç¡€ä¸Šï¼Œå†è¦†å†™updateå‡½æ•°è¦æ±‚å¯¹èŠ‚ç‚¹ä¿¡æ¯åšä¸€å±‚çº¿æ€§å˜æ¢ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181from torch_geometric.datasets import Planetoidimport torchfrom torch import nn, Tensorfrom torch_geometric.nn import MessagePassingfrom torch_geometric.utils import add_self_loops, degreefrom torch_sparse import SparseTensor, matmulclass GCNConv(MessagePassing): def __init__(self, in_channels, out_channels): super(GCNConv, self).__init__(aggr='add', flow='source_to_target') # \"Add\" aggregation (Step 5). # flow='source_to_target' è¡¨ç¤ºæ¶ˆæ¯ä»æºèŠ‚ç‚¹ä¼ æ’­åˆ°ç›®æ ‡èŠ‚ç‚¹ self.lin = torch.nn.Linear(in_channels, out_channels) self.lin2 = torch.nn.Linear(out_channels, out_channels) self.relu = torch.nn.ReLU() def propagate(self, edge_index, size=None, **kwargs): # I just copy the source copy from PyG website r\"\"\"The initial call to start propagating messages. Args: edge_index (Tensor or SparseTensor): A :obj:`torch.LongTensor` or a :obj:`torch_sparse.SparseTensor` that defines the underlying graph connectivity/message passing flow. :obj:`edge_index` holds the indices of a general (sparse) assignment matrix of shape :obj:`[N, M]`. If :obj:`edge_index` is of type :obj:`torch.LongTensor`, its shape must be defined as :obj:`[2, num_messages]`, where messages from nodes in :obj:`edge_index[0]` are sent to nodes in :obj:`edge_index[1]` (in case :obj:`flow=\"source_to_target\"`). If :obj:`edge_index` is of type :obj:`torch_sparse.SparseTensor`, its sparse indices :obj:`(row, col)` should relate to :obj:`row = edge_index[1]` and :obj:`col = edge_index[0]`. The major difference between both formats is that we need to input the *transposed* sparse adjacency matrix into :func:`propagate`. size (tuple, optional): The size :obj:`(N, M)` of the assignment matrix in case :obj:`edge_index` is a :obj:`LongTensor`. If set to :obj:`None`, the size will be automatically inferred and assumed to be quadratic. This argument is ignored in case :obj:`edge_index` is a :obj:`torch_sparse.SparseTensor`. (default: :obj:`None`) **kwargs: Any additional data which is needed to construct and aggregate messages, and to update node embeddings. \"\"\" size = self.__check_input__(edge_index, size) # Run \"fused\" message and aggregation (if applicable). if (isinstance(edge_index, SparseTensor) and self.fuse and not self.__explain__): coll_dict = self.__collect__(self.__fused_user_args__, edge_index, size, kwargs) print(\"Using self-defined message-passing\") msg_aggr_kwargs = self.inspector.distribute( 'message_and_aggregate', coll_dict) out = self.message_and_aggregate(edge_index, **msg_aggr_kwargs) update_kwargs = self.inspector.distribute('update', coll_dict) return self.update(out, **update_kwargs) # Otherwise, run both functions in separation. elif isinstance(edge_index, Tensor) or not self.fuse: coll_dict = self.__collect__(self.__user_args__, edge_index, size, kwargs) msg_kwargs = self.inspector.distribute('message', coll_dict) #print(\"Message kwargs: \",msg_kwargs) out = self.message(**msg_kwargs) # For `GNNExplainer`, we require a separate message and aggregate # procedure since this allows us to inject the `edge_mask` into the # message passing computation scheme. if self.__explain__: edge_mask = self.__edge_mask__.sigmoid() # Some ops add self-loops to `edge_index`. We need to do the # same for `edge_mask` (but do not train those). if out.size(self.node_dim) != edge_mask.size(0): loop = edge_mask.new_ones(size[0]) edge_mask = torch.cat([edge_mask, loop], dim=0) assert out.size(self.node_dim) == edge_mask.size(0) out = out * edge_mask.view([-1] + [1] * (out.dim() - 1)) aggr_kwargs = self.inspector.distribute('aggregate', coll_dict) out = self.aggregate(out, **aggr_kwargs) update_kwargs = self.inspector.distribute('update', coll_dict) return self.update(out, **update_kwargs) def forward(self, x, edge_index): # x has shape [N, in_channels] # edge_index has shape [2, E] # Step 1: Add self-loops to the adjacency matrix. edge_index, _ = add_self_loops(edge_index, num_nodes=x.size(0)) # Step 2: Linearly transform node feature matrix. x = self.lin(x) # Compute degree. row, col = edge_index deg = degree(col, x.size(0), dtype=x.dtype) return self.propagate(edge_index, x=x, deg=deg.view((-1, 1))) def message(self, x_j, deg_i,deg_j): # Accoding to __collect__ function # in https://github.com/rusty1s/pytorch_geometric/blob/master/torch_geometric/nn/conv/message_passing.py # when flow = source_to_target # i= 1, j=0, edge_index_i = edge_index[1] = target, so # deg_i is degree of target node, and x_i is target node data # deg_j is degree of source node and x_j is source # x_j has shape [E, out_channels] # deg_i has shape [E, 1] # Step 3: Normalize node features. print(\"--message is called--\") print(\"x_j: \",x_j.shape) print(\"degree: \", deg_i.shape) print(\"degree: \",deg_j.shape) print() # check if degrees of source nodes and degrees of target nodes are equal print(torch.eq(deg_i, deg_j).all()) # compute normalization deg_i = deg_i.pow(-0.5) deg_j = deg_j.pow(-0.5) norm = deg_i * deg_j return norm.view(-1, 1) * x_j def aggregate(self, inputs, index, ptr, dim_size): #from __collect__() function we know that # when flow = source_to_target # out['index'] = out['edge_index_i'] -&gt; input index = edge_index[i] = edge_index[1] = index of target node # inputs: embedding vectors of source nodes # inputs: the outputs from message function, the normalized source node embeding with shape [E, dim of embedding] print(\"--aggregate` is called--\") print('self.aggr:', self.aggr) print('ptr: ', ptr) print('dim_size: ',dim_size) print(\"inputs: \", inputs.shape) print(\"index: \",index.shape, len(index.unique())) print() uni_idx = index.unique() uni_idx.sort() res= [] # find all unique target node index # for each target node, aggregate(sum or mean ) the information from source node to the target node # and obtain target node embedding for i in uni_idx: # i is the index of target node neighbors = inputs[index == i] # aggregate along different vectors of different nodes if self.aggr==\"mean\": agg_res = neighbors.mean(axis=0) else: agg_res = neighbors.sum(axis=0) res.append(agg_res) res = torch.stack(res) return res def update(self,inputs, deg ): print(\"--update func is called--\") return self.lin2(inputs)dataset = Planetoid(root='dataset/Cora', name='Cora')data = dataset[0]net = GCNConv(data.num_features, 64)h_nodes = net(data.x, data.edge_index)print(\"H_nodes: \", h_nodes.shape)h_nodes --message is called-- x_j: torch.Size([13264, 64]) degree: torch.Size([13264, 1]) degree: torch.Size([13264, 1]) tensor(False) --aggregate` is called-- self.aggr: add ptr: None dim_size: 2708 inputs: torch.Size([13264, 64]) index: torch.Size([13264]) 2708 --update func is called-- H_nodes: torch.Size([2708, 64]) tensor([[-0.0139, -0.0065, 0.1316, ..., 0.0401, -0.1439, -0.0718], [-0.0333, -0.0545, 0.1637, ..., -0.0098, -0.1503, -0.0837], [-0.0245, -0.0277, 0.1248, ..., 0.0264, -0.1423, -0.0829], ..., [-0.0678, -0.0061, 0.1510, ..., 0.0332, -0.1420, -0.0876], [-0.0289, -0.0100, 0.1211, ..., 0.0339, -0.1905, -0.0764], [-0.0255, -0.0036, 0.1290, ..., 0.0366, -0.1623, -0.0631]], grad_fn=&lt;AddmmBackward&gt;) 12 5.2.4 åœ¨ç¬¬ä¸‰ä¸ªç±»çš„åŸºç¡€ä¸Šï¼Œå†è¦†å†™message_and_aggregateå‡½æ•°è¦æ±‚åœ¨è¿™ä¸€ä¸ªå‡½æ•°ä¸­å®ç°å‰é¢messageå‡½æ•°å’Œaggregateå‡½æ•°çš„åŠŸèƒ½ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224from torch_geometric.datasets import Planetoidimport torchfrom torch import nn, Tensorfrom torch_geometric.nn import MessagePassingfrom torch_geometric.utils import add_self_loops, degreefrom torch_sparse import SparseTensor, matmulclass GCNConv(MessagePassing): def __init__(self, in_channels, out_channels): super(GCNConv, self).__init__(aggr='add', flow='source_to_target') # \"Add\" aggregation (Step 5). # flow='source_to_target' è¡¨ç¤ºæ¶ˆæ¯ä»æºèŠ‚ç‚¹ä¼ æ’­åˆ°ç›®æ ‡èŠ‚ç‚¹ self.lin = torch.nn.Linear(in_channels, out_channels) self.lin2 = torch.nn.Linear(out_channels, out_channels) self.relu = torch.nn.ReLU() def propagate(self, edge_index, size=None, **kwargs): # I just copy the source copy from PyG website r\"\"\"The initial call to start propagating messages. Args: edge_index (Tensor or SparseTensor): A :obj:`torch.LongTensor` or a :obj:`torch_sparse.SparseTensor` that defines the underlying graph connectivity/message passing flow. :obj:`edge_index` holds the indices of a general (sparse) assignment matrix of shape :obj:`[N, M]`. If :obj:`edge_index` is of type :obj:`torch.LongTensor`, its shape must be defined as :obj:`[2, num_messages]`, where messages from nodes in :obj:`edge_index[0]` are sent to nodes in :obj:`edge_index[1]` (in case :obj:`flow=\"source_to_target\"`). If :obj:`edge_index` is of type :obj:`torch_sparse.SparseTensor`, its sparse indices :obj:`(row, col)` should relate to :obj:`row = edge_index[1]` and :obj:`col = edge_index[0]`. The major difference between both formats is that we need to input the *transposed* sparse adjacency matrix into :func:`propagate`. size (tuple, optional): The size :obj:`(N, M)` of the assignment matrix in case :obj:`edge_index` is a :obj:`LongTensor`. If set to :obj:`None`, the size will be automatically inferred and assumed to be quadratic. This argument is ignored in case :obj:`edge_index` is a :obj:`torch_sparse.SparseTensor`. (default: :obj:`None`) **kwargs: Any additional data which is needed to construct and aggregate messages, and to update node embeddings. \"\"\" size = self.__check_input__(edge_index, size) # Run \"fused\" message and aggregation (if applicable). if (isinstance(edge_index, SparseTensor) and self.fuse and not self.__explain__): coll_dict = self.__collect__(self.__fused_user_args__, edge_index, size, kwargs) #print(\"Using self-defined message-passing\") msg_aggr_kwargs = self.inspector.distribute( 'message_and_aggregate', coll_dict) out = self.message_and_aggregate(edge_index, **msg_aggr_kwargs) update_kwargs = self.inspector.distribute('update', coll_dict) return self.update(out, **update_kwargs) # Otherwise, run both functions in separation. elif isinstance(edge_index, Tensor) or not self.fuse: coll_dict = self.__collect__(self.__user_args__, edge_index, size, kwargs) msg_kwargs = self.inspector.distribute('message', coll_dict) #print(\"Message kwargs: \",msg_kwargs) out = self.message(**msg_kwargs) # For `GNNExplainer`, we require a separate message and aggregate # procedure since this allows us to inject the `edge_mask` into the # message passing computation scheme. if self.__explain__: edge_mask = self.__edge_mask__.sigmoid() # Some ops add self-loops to `edge_index`. We need to do the # same for `edge_mask` (but do not train those). if out.size(self.node_dim) != edge_mask.size(0): loop = edge_mask.new_ones(size[0]) edge_mask = torch.cat([edge_mask, loop], dim=0) assert out.size(self.node_dim) == edge_mask.size(0) out = out * edge_mask.view([-1] + [1] * (out.dim() - 1)) aggr_kwargs = self.inspector.distribute('aggregate', coll_dict) out = self.aggregate(out, **aggr_kwargs) update_kwargs = self.inspector.distribute('update', coll_dict) return self.update(out, **update_kwargs) def forward(self, x, edge_index): # x has shape [N, in_channels] # edge_index has shape [2, E] # Step 1: Add self-loops to the adjacency matrix. edge_index, _ = add_self_loops(edge_index, num_nodes=x.size(0)) # Step 2: Linearly transform node feature matrix. x = self.lin(x) # Compute degree. row, col = edge_index deg = degree(col, x.size(0), dtype=x.dtype) adjmat = SparseTensor(row=edge_index[0], col=edge_index[1], value=torch.ones(edge_index.shape[1])) return self.propagate(adjmat, x=x, deg=deg.view((-1, 1))) def message(self, x_j, deg_i,deg_j): # Accoding to __collect__ function # in https://github.com/rusty1s/pytorch_geometric/blob/master/torch_geometric/nn/conv/message_passing.py # when flow = source_to_target # i= 1, j=0, edge_index_i = edge_index[1] = target, so # deg_i is degree of target node, and x_i is target node data # deg_j is degree of source node and x_j is source # x_j has shape [E, out_channels] # deg_i has shape [E, 1] # Step 3: Normalize node features. print(\"--message is called--\") print(\"x_j: \",x_j.shape) print(\"degree: \", deg_i.shape) print(\"degree: \",deg_j.shape) print() # check if degrees of source nodes and degrees of target nodes are equal print(torch.eq(deg_i, deg_j).all()) # compute normalization deg_i = deg_i.pow(-0.5) deg_j = deg_j.pow(-0.5) norm = deg_i * deg_j return norm.view(-1, 1) * x_j def aggregate(self, inputs, index, ptr, dim_size): #from __collect__() function we know that # when flow = source_to_target # out['index'] = out['edge_index_i'] -&gt; input index = edge_index[i] = edge_index[1] = index of target node # inputs: embedding vectors of source nodes # inputs: the outputs from message function, the normalized source node embeding with shape [E, dim of embedding] print(\"--aggregate` is called--\") print('self.aggr:', self.aggr) print('ptr: ', ptr) print('dim_size: ',dim_size) print(\"inputs: \", inputs.shape) print(\"index: \",index.shape, len(index.unique())) print() uni_idx = index.unique() uni_idx.sort() res= [] # find all unique target node index # for each target node, aggregate(sum or mean ) the information from source node to the target node # and obtain target node embedding for i in uni_idx: # i is the index of target node neighbors = inputs[index == i] # aggregate along different vectors of different nodes if self.aggr==\"mean\": agg_res = neighbors.mean(axis=0) else: agg_res = neighbors.sum(axis=0) res.append(agg_res) res = torch.stack(res) return res def message_and_aggregate(self, adj_t, x_j, index,deg_i, deg_j): # note: # adj_t: adjacency matrix # norm: normalization coefficient 1/sqrt(deg_i)*sqrt(deg_j) # number of '1' in adj_t = length of norm ## Print something to debug #print('`message_and_aggregate` is called') #print(\"adj_t: \",adj_t) #print(\"deg:\", deg) print(\"--message_and_aggregate is called --\") # Step3: compute normalization deg_i = deg_i.pow(-0.5) deg_j = deg_j.pow(-0.5) norm = deg_i * deg_j # Step4: compute normalized message inputs = norm.view(-1, 1) * x_j # Step5: aggregate function sum uni_idx = index.unique() uni_idx.sort() res= [] # find all unique target node index # for each target node, aggregate(sum or mean ) the information from source node to the target node # and obtain target node embedding for i in uni_idx: # i is the index of target node neighbors = inputs[index == i] # aggregate along different vectors of different nodes if self.aggr==\"mean\": agg_res = neighbors.mean(axis=0) else: agg_res = neighbors.sum(axis=0) res.append(agg_res) res = torch.stack(res) return res def update(self,inputs, deg ): print(\"--update func is called--\") return self.lin2(inputs)dataset = Planetoid(root='dataset/Cora', name='Cora')data = dataset[0]net = GCNConv(data.num_features, 64)h_nodes = net(data.x, data.edge_index)print(\"H_nodes: \", h_nodes.shape)h_nodes --message_and_aggregate is called -- --update func is called-- H_nodes: torch.Size([2708, 64]) tensor([[-0.0301, -0.0607, -0.0843, ..., -0.0092, 0.0735, 0.1196], [-0.0287, -0.0805, -0.0924, ..., -0.0665, 0.0596, 0.0680], [-0.0236, -0.0952, -0.1220, ..., -0.0735, 0.0296, 0.0909], ..., [-0.0257, -0.0769, -0.0840, ..., -0.0068, 0.0807, 0.1330], [-0.0402, -0.0765, -0.1098, ..., -0.0396, 0.0407, 0.1058], [-0.0421, -0.0787, -0.1024, ..., -0.0455, 0.0361, 0.1054]], grad_fn=&lt;AddmmBackward&gt;) 12 5.3 è®¾è®¡è‡ªå®šä¹‰ä¸€ä¸ªGCN layerè¿™é‡Œæˆ‘è‡ªå®šä¹‰çš„GCN layerå…¬å¼å¦‚ä¸‹ï¼š$$\\mathbf{x}i^{(k)} = \\sigma(\\frac{1}{|\\mathcal{N}(i)|+1} \\times \\sum{j \\in \\mathcal{N}(i) \\cup { i }} \\frac{1}{\\sqrt{\\deg(i)} \\cdot \\sqrt{\\deg(j)}} \\cdot ( \\mathbf{\\Theta} \\cdot \\mathbf{x}_j^{(k-1)} ) ) + \\mathbf{\\Theta} \\cdot \\mathbf{x}_i^{(k-1)} ,$$ è¿™é‡Œä¸€äº›å‡½æ•°å®šä¹‰å¦‚ä¸‹ï¼š $\\phi(..)$: messageå‡½æ•°å’Œä¹‹å‰çš„GCNä¸€æ ·éƒ½æ˜¯linear projectionä¹‹åç”¨degreeè¿›è¡Œnormalization $\\square(..)$ : aggregate å‡½æ•° ç”¨æ¥mean $\\gamma(..)$: update å‡½æ•°æ˜¯å…ˆç”¨äº†ReLu activationå‡½æ•°, åœ¨åŠ ä¸ŠshortcutæŠŠä¹‹å‰æŠ•æ˜ ä¹‹åçš„è¾“å…¥åŠ ä¸Šæ¥ï¼Œæ¨¡æ‹Ÿäº†resnetçš„ç»“æ„ è¿™é‡Œåªç”¨äº† message_and_aggregate å‡½æ•°ï¼Œæ‰€ä»¥æ²¡æœ‰å®ç°messageï¼Œ aggregateçš„å•ç‹¬çš„å‡½æ•° propagate å‡½æ•°æ˜¯ç›´æ¥ä»å®˜æ–¹æ–‡æ¡£copyè¿‡æ¥ï¼Œæ–¹ä¾¿ç†è§£GNNçš„propagateçš„æµç¨‹çš„ã€‚ ä»ä¸­å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœè¾“å…¥åˆ°propagateçš„tensoræ˜¯SparseTensor, é‚£ä¹ˆä¼šç›´æ¥è°ƒç”¨message_and_aggregateå‡½æ•°ï¼Œè€Œä¸æ˜¯å•ç‹¬è°ƒç”¨ä¸¤ä¸ªå‡½æ•°ï¼Œæ‰€ä»¥åªè¦å®ç°è¿™ä¸ªåˆå¹¶çš„å‡½æ•°å°±è¡Œäº† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171from torch_geometric.datasets import Planetoidimport torchfrom torch import nn, Tensorfrom torch_geometric.nn import MessagePassingfrom torch_geometric.utils import add_self_loops, degreefrom torch_sparse import SparseTensor, matmulclass MyGCNConv(MessagePassing): def __init__(self, in_channels, out_channels): super(MyGCNConv, self).__init__(aggr='mean', flow='source_to_target') # \"Add\" aggregation (Step 5). # flow='source_to_target' è¡¨ç¤ºæ¶ˆæ¯ä»æºèŠ‚ç‚¹ä¼ æ’­åˆ°ç›®æ ‡èŠ‚ç‚¹ self.lin = torch.nn.Linear(in_channels, out_channels) self.relu = torch.nn.ReLU() def propagate(self, edge_index, size=None, **kwargs): # I just copy the source copy from PyG website r\"\"\"The initial call to start propagating messages. Args: edge_index (Tensor or SparseTensor): A :obj:`torch.LongTensor` or a :obj:`torch_sparse.SparseTensor` that defines the underlying graph connectivity/message passing flow. :obj:`edge_index` holds the indices of a general (sparse) assignment matrix of shape :obj:`[N, M]`. If :obj:`edge_index` is of type :obj:`torch.LongTensor`, its shape must be defined as :obj:`[2, num_messages]`, where messages from nodes in :obj:`edge_index[0]` are sent to nodes in :obj:`edge_index[1]` (in case :obj:`flow=\"source_to_target\"`). If :obj:`edge_index` is of type :obj:`torch_sparse.SparseTensor`, its sparse indices :obj:`(row, col)` should relate to :obj:`row = edge_index[1]` and :obj:`col = edge_index[0]`. The major difference between both formats is that we need to input the *transposed* sparse adjacency matrix into :func:`propagate`. size (tuple, optional): The size :obj:`(N, M)` of the assignment matrix in case :obj:`edge_index` is a :obj:`LongTensor`. If set to :obj:`None`, the size will be automatically inferred and assumed to be quadratic. This argument is ignored in case :obj:`edge_index` is a :obj:`torch_sparse.SparseTensor`. (default: :obj:`None`) **kwargs: Any additional data which is needed to construct and aggregate messages, and to update node embeddings. \"\"\" size = self.__check_input__(edge_index, size) # Run \"fused\" message and aggregation (if applicable). if (isinstance(edge_index, SparseTensor) and self.fuse and not self.__explain__): coll_dict = self.__collect__(self.__fused_user_args__, edge_index, size, kwargs) print(\"Using self-defined message-passing\") msg_aggr_kwargs = self.inspector.distribute( 'message_and_aggregate', coll_dict) out = self.message_and_aggregate(edge_index, **msg_aggr_kwargs) update_kwargs = self.inspector.distribute('update', coll_dict) return self.update(out, **update_kwargs) # Otherwise, run both functions in separation. elif isinstance(edge_index, Tensor) or not self.fuse: coll_dict = self.__collect__(self.__user_args__, edge_index, size, kwargs) msg_kwargs = self.inspector.distribute('message', coll_dict) out = self.message(**msg_kwargs) # For `GNNExplainer`, we require a separate message and aggregate # procedure since this allows us to inject the `edge_mask` into the # message passing computation scheme. if self.__explain__: edge_mask = self.__edge_mask__.sigmoid() # Some ops add self-loops to `edge_index`. We need to do the # same for `edge_mask` (but do not train those). if out.size(self.node_dim) != edge_mask.size(0): loop = edge_mask.new_ones(size[0]) edge_mask = torch.cat([edge_mask, loop], dim=0) assert out.size(self.node_dim) == edge_mask.size(0) out = out * edge_mask.view([-1] + [1] * (out.dim() - 1)) aggr_kwargs = self.inspector.distribute('aggregate', coll_dict) out = self.aggregate(out, **aggr_kwargs) update_kwargs = self.inspector.distribute('update', coll_dict) return self.update(out, **update_kwargs) def forward(self, x, edge_index): # x has shape [N, in_channels] # edge_index has shape [2, E] # Step 1: Add self-loops to the adjacency matrix. edge_index, _ = add_self_loops(edge_index, num_nodes=x.size(0)) # Step 2: Linearly transform node feature matrix. x = self.lin(x) # Step 3: Compute normalization. row, col = edge_index deg = degree(col, x.size(0), dtype=x.dtype) deg_inv_sqrt = deg.pow(-0.5) # note: norm is in shape of (number of edge, ) norm = deg_inv_sqrt[row] * deg_inv_sqrt[col] print(\"Get degree Shape: \", edge_index.shape) print(\"Norm Shape: \",norm.shape) # Step 4-5: Start propagating messages. # Convert edge index to a sparse adjacency matrix representation, with row = from nodes, col = to nodes. # When value = 1 in adjacency matrix, it indicates two nodes are adjacent. # adjmat = SparseTensor(row=edge_index[0], col=edge_index[1], value=torch.ones(edge_index.shape[1])) # è¿™é‡Œ adjacency matrix çš„å€¼ä»1 å˜æˆ normalization çš„å€¼ï¼Œæ–¹ä¾¿ä¹˜æ³•è®¡ç®— adjmat = SparseTensor(row=edge_index[0], col=edge_index[1], value=norm) # æ­¤å¤„ä¼ çš„ä¸å†æ˜¯edge_idexï¼Œè€Œæ˜¯SparseTensorç±»å‹çš„Adjancency Matrix return self.propagate(adjmat, x=x, norm=norm, deg=deg.view((-1, 1))) def message(self, x_j, norm, deg_i): # x_j has shape [E, out_channels] # deg_i has shape [E, 1] # Step 4: Normalize node features. return norm.view(-1, 1) * x_j * deg_i def aggregate(self, inputs, index, ptr, dim_size): print('self.aggr:', self.aggr) print(\"`aggregate` is called\") return super().aggregate(inputs, index, ptr=ptr, dim_size=dim_size) def message_and_aggregate(self, adj_t, x, norm,deg): # note: # adj_t: adjacency matrix # norm: normalization coefficient 1/sqrt(deg_i)*sqrt(deg_j) # number of '1' in adj_t = length of norm ## Print something to debug #print('`message_and_aggregate` is called') #print(\"adj_t: \",adj_t) #print(\"deg:\", deg) adj_t = adj_t.to_dense() N = len(adj_t) out = [] x0 = x[:] for i in range(N): # è®¡ç®—æ¯ä¸ª xi çš„neighborä¼ è¿‡æ¥çš„ä¿¡æ¯çš„å¹³å‡å€¼ x_sum = torch.matmul(x.T,adj_t[i]) x_avg = x_sum/deg[i] out.append(x_avg) out = torch.stack(out) return [out, x0] def update(self, inputs, deg): print(\"Update result\") print(\"Degree\",deg) # resnetçš„ç»“æ„ x0 = inputs[1] output = self.relu(inputs[0]) + x0 return outputdataset = Planetoid(root='dataset/Cora', name='Cora')data = dataset[0]net = MyGCNConv(data.num_features, 64)h_nodes = net(data.x, data.edge_index) Get degree Shape: torch.Size([2, 13264]) Norm Shape: torch.Size([13264]) Using self-defined message-passing Update result Degree tensor([[4.], [4.], [6.], ..., [2.], [5.], [5.]]) 1h_nodes tensor([[-2.4017e-02, 4.7570e-02, 1.1954e-02, ..., 1.3043e-02, 2.0967e-02, -8.4416e-02], [-8.5681e-02, 1.2029e-01, 1.0756e-01, ..., 5.4046e-02, -8.9611e-02, -1.9092e-01], [ 6.2691e-02, -2.7604e-02, -6.0106e-02, ..., -3.0790e-05, 7.8295e-03, -7.2708e-02], ..., [ 2.0562e-02, 6.4994e-02, 1.0240e-01, ..., -3.2108e-03, 6.4759e-02, 1.3680e-02], [-1.9234e-02, -2.0179e-02, 3.0165e-02, ..., -1.4412e-01, -4.2793e-02, -5.4195e-02], [-2.6318e-02, -2.6606e-02, 9.8404e-02, ..., -5.1031e-02, -2.9973e-02, 1.8722e-02]], grad_fn=&lt;AddBackward0&gt;) 12 Reference[1] Datawhale å‚è€ƒèµ„æ–™: https://github.com/datawhalechina/team-learning-nlp/blob/master/GNN/Markdown%E7%89%88%E6%9C%AC/4-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.md [2] PyGå®˜æ–¹æ–‡æ¡£ï¼šhttps://pytorch-geometric.readthedocs.io/en/latest/index.html[3] paper: https://arxiv.org/pdf/2007.02133.pdf[4] paper: https://arxiv.org/pdf/1609.02907.pdf[5] Deep Learning on Graph: https://github.com/datawhalechina/team-learning-nlp/blob/master/GNN/Markdown%E7%89%88%E6%9C%AC/4-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.md[6] PyG MessagePassing å‡½æ•°è§£é‡Š: https://blog.csdn.net/qq_41987033/article/details/103377561","link":"/2021/06/18/GNN-2-MessagePassing/"},{"title":"Quick tutorial JavaScript with D3.js","text":"IntroductionAbout this passageThis passage simply introduces how to combine HTML, CSS and Javascript together to design a web page. Then D3.js, a javascript package for data visualization is introduced and applied to visualize some simple data. About HTML, CSS, JavaScriptHTML: HTML stands for Hyper Text Markup Language. It is the standard markup language for Web pages. Elements in HTML are the building blocks of HTML pages, represented by &lt;&gt; tags CSS: it stands for Cascading Style Sheets. It describes how HTML elements are to be displayed. JavaScript: JavaScript is the Programming Language for the Web. It can update and change both HTML and CSS. It can calculate, manipulate and validate data Combining HTML, CSS, JavaScript for a webpageTo start with, Letâ€™s create a folder that will contain all HTML, CSS, JavaScript files we will create. Write a HTML fileFirst, we write an empty HTML file with title â€œDemoâ€ and empty content for passage &lt;p&gt; &lt;\\p&gt; and heading &lt;h1&gt;&lt;\\h1&gt; 12345678910&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt; Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; Then we put Javascript into HTML directly 1234567891011121314151617181920212223&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt; Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt; &lt;/p&gt; &lt;script&gt; var headers = document.getElementsByTagName(\"h1\"); for (var i = 0; i &lt; headers.length; i++) { var header = headers.item(i); header.innerHTML = \"Hello I'm Header\"; } var paragraphs = document.getElementsByTagName(\"p\"); for (var i = 0; i &lt; paragraphs.length; i++) { var paragraph = paragraphs.item(i); paragraph.innerHTML = \"I'm Passage\"; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; The tag &lt;\\script&gt;&lt;\\script&gt; tells HTML the code inside this block is Javascript. In this script, we select the element with tag name â€˜h1â€™ and â€˜pâ€™ using document.getElementsByTagName() and then input text â€œHello Iâ€™m Headerâ€ and â€œIâ€™m Passageâ€. This will let HTML display such texts in corresponding elements. Using Javascript file instead of internal scriptTo use JavaScript file rather than script inside HTML, we first create a JavaScript file called â€œmyjs.jsâ€ in the same folder. Then copy the JavaScript code from HTML to Javascirpt. 12345678910var headers = document.getElementsByTagName(\"h1\"); for (var i = 0; i &lt; headers.length; i++) { var header = headers.item(i); header.innerHTML = \"Hello I'm Header\"; }var paragraphs = document.getElementsByTagName(\"p\"); for (var i = 0; i &lt; paragraphs.length; i++) { var paragraph = paragraphs.item(i); paragraph.innerHTML = \"I'm Passage\"; } In HTML file, we replace the script with a sentence, shown as below. 1234567891011&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;D3 Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World &lt;/p&gt; &lt;h1&gt;&lt;/h1&gt; &lt;script id=\"myjs\" src=\"myjs.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; â€œidâ€ï¼Œâ€typeâ€ attributes tell HTML we are looking for a file with name â€œmyjsâ€ and file type of JavaScript. Define style with CSS file Internal CSS code Elementsâ€™ styles, like color, font size, etc can be defined using CSS code. To add CSS inside HTML, here is an example: 1234567891011121314151617181920212223242526272829303132333435363738394041424344 &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;D3 Demo&lt;/title&gt; &lt;/head&gt; &lt;style&gt; h2 { color: blue; font-size: 12px; font-family: \"Open Sans\"; text-anchor: middle; } &lt;/style&gt; &lt;body&gt; &lt;p&gt;Hello World &lt;/p&gt; &lt;h1&gt;&lt;/h1&gt; &lt;script id=\"myjs\" src=\"myjs.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ~~~ The tag \\&lt;style&gt; tells the HTML the style settings (blue color, font-size = 12 pixel, ...) for all h2 element. &lt;br&gt;- __External CSS code__Usually, using a separated css file, rather than internal css code inside HTML file, can help further improvement for our project. It is more flexible to use css for element style design. To use external CSS file, replace the style codes in HTML with \\&lt;link&gt; tag~~~HTML&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;D3 Demo&lt;/title&gt; &lt;/head&gt; &lt;link id =\"mystyle\" href=\"mystyle.css\" rel=\"stylesheet\" type=\"text/css\" /&gt; &lt;body&gt; &lt;p&gt;Hello World &lt;/p&gt; &lt;h1&gt;&lt;/h1&gt; &lt;script id=\"myjs\" src=\"myjs.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Then Create a CSS file, called â€œmystyle.cssâ€ and copy the style code to CSS file 123456h2 { color: blue; font-size: 12px; font-family: \"Open Sans\"; text-anchor: middle; } The CSS file is linked to the HTML file by &lt;link&gt; tags in HTML. â€œidâ€ is the identity of element â€œlinkâ€ and â€œhrefâ€ is set to be â€œmystyle.cssâ€ file. Attribute â€œtypeâ€ is the file type of â€œmycss.cssâ€ file, hence it is css or text type. What is D3.jsD3.js is a JavaScript library for manipulating documents based on data. D3 helps you bring data to life using HTML, SVG, and CSS. D3â€™s emphasis on web standards gives you the full capabilities of modern browsers without tying yourself to a proprietary framework, combining powerful visualization components and a data-driven approach to DOM manipulation Import D3.jsTo import D3.js library, we can either add this line to the HTML file, then the D3.js library from the website will be applied. 1&lt;script src=\"http://d3js.org/d3.v3.min.js\" charset=\"utf-8\"&gt;&lt;/script&gt; Or download D3.js library from https://d3js.org/ to the folder directly.Here is an example of importing D3.js library and my javascript (D3-demo.js), css files (mystyle.css) 1234567891011121314&lt;html&gt; &lt;link id=\"mystyle\" href= 'mystyle.css' rel=\"stylesheet\" type=\"text/css\" /&gt; &lt;script src=\"http://d3js.org/d3.v3.min.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;D3 Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World &lt;/p&gt; &lt;h1&gt;&lt;/h1&gt; &lt;script id=\"myjs\" src='D3-demo.js' type=\"text/javascript\"&gt;&lt;/script&gt; &lt;div id=\"chart\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; Selection, Insertion, Remove for elements Selection and Modification 123456789101112131415161718192021222324252627// Using JavaScript to change URL to stylesheet and JavaScript in HTML// #mystyle ï¼š element with id \"mystyle\"// #myjs ï¼š element with id \"myjs\"// Note: to Select element by ID, we need to add # ahead id namecss_src= \"mystyle.css\"js_src=\"D3-demo.js\"var mycss= d3.select(\"#mystyle\").attr(\"href\",css_src)var myjs = d3.select(\"#myjs\").attr (\"src\",js_src)// Change Passage textvar p = d3.select(\"body\") .selectAll(\"p\") .text(\"d3js.org\");// Change color of passage text//ä¿®æ”¹æ®µè½çš„é¢œè‰²å’Œå­—ä½“å¤§å°p.style(\"color\",\"red\") .style(\"font-size\",\"72px\");//Change &lt;h1&gt; element's text and text style: color, font sizevar h = d3.select(\"body\") .selectAll(\"h1\") .text(\"Heading\"); h.style(\"color\",\"red\") .style(\"font-size\",\"72px\");// Append &lt;h2&gt; tag to &lt;p&gt; section, with text \"Here is h2\"var h2 = d3.select(\"body\").select(\"p\").append(\"h2\").text(\"Here is h2\"); Bar Plot 1234567891011121314151617181920212223242526// Setup Canvas element by appending tag &lt;svg&gt; into &lt;body&gt; section// with width=300 pixels and height= 300 pixelsvar width = 300; //ç”»å¸ƒçš„å®½åº¦var height = 300; //ç”»å¸ƒçš„é«˜åº¦var svg = d3.select(\"body\") //é€‰æ‹©æ–‡æ¡£ä¸­çš„bodyå…ƒç´  .append(\"svg\") //æ·»åŠ ä¸€ä¸ªsvgå…ƒç´  .attr(\"width\", width) //è®¾å®šå®½åº¦ .attr(\"height\", height); // Append Rectangle bars to Canvas// Set width of each bar = each dataset value var dataset = [ 250 , 210 , 170 , 130 , 90 ]; var rectHeight = 25; //æ¯ä¸ªçŸ©å½¢æ‰€å çš„åƒç´ é«˜åº¦(åŒ…æ‹¬ç©ºç™½)svg.selectAll(\"rect\") .data(dataset) .enter() .append(\"rect\") .attr(\"x\",50) .attr(\"y\",function(d,i){ return i * rectHeight; }) .attr(\"width\",function(d){ return d; }) .attr(\"height\",rectHeight-2) .attr(\"fill\",\"steelblue\"); Copy all codes above and open our HTML file in browser, we can see something like this. Reference[1] https://wiki.jikexueyuan.com/project/d3wiki/selection.html[2] https://d3js.org/[3] https://www.w3schools.com/","link":"/2020/07/12/JS-tutorial-with-D3js/"},{"title":"ML-K-mean-Cluster","text":"Introduction to K-mean ClusteringIn Chinese, we usually say â€œç‰©ä»¥ç±»èšâ€ï¼Œ which means somethings in the same class can be grouped together based on their similar attributes. For example, when we group different types of fruit, like apple, cherry, blackberry, together based on their color, then we can group apple and cherry into the same class and the blackberry into another class. In K-mean clustering, it uses the same idea, by assigning different data points to the same cluster center based on the distance between data point and different cluster centers. By grouping data together simply, we can explore the similarity among data points and potential data pattern, which can help us analyze the internal features between data. Note that K-mean clustering is an unsupervised, non-parameter learning method, since it doesnâ€™t use labels created by human or any numerical parameters/ weights like linear, logistic regression to estimate the distribution of data. How K-mean Clustering works?The steps in K-Mean-Clustering are following: Pick the number of clusters K Randomly assign K cluster centers in feature space In the feature space, each data point is assigned to the cluster, whose center is closest to this point, based on distance measurement (Usually Euclidean Distance) In each cluster, re-compute and update the center/mean value of this cluster based on data points in the cluster. Repeat Step 3 to 4 until the cluster of each data point doesnâ€™t change, or called Converged. Here is an image to demonstrate the process of K-mean clustering. Distributed Version of K-mean ClusteringAs K-mean clustering is a simple straight-forward unsupervised learning method, it can be extended to distributed version easily.In distributed version of K-mean Clustering, we have: Partition big data data points evenly into n processes. Mapper Function: Each process uses its local data points to do K-mean clustering. Each process has the same K value Shuffle / Sort K cluster centers from each process. Then we have K * n cluster centers Reducer Function: In the Kn cluster center points, we do K-mean clustering again to find K cluster centers of Kn center points Send the K cluster centers found in step 4 back to each process (then each process has the same K centers) and repeat step 2 to 5 until K centers donâ€™t move (Converge) Properties of K-mean ClusteringAlthough K-Mean Clustering is very easy to compute, it has different advantages and disadvantages. Advantage Computing mean of data is easy and fast Can explore potential similarity on low-dimensional data points Disadvantage Need to specify the K value and we donâ€™t know which K is the best. Cluster Pattern can be affected by scale of data, Since K-mean clustering is distance-based method. If different attributes are not in same scale, the cluster pattern will be distorted and some data points may be assigned to wrong clusterSo K-mean Cluster need normalization of data Cluster is Sensitive to outlier data point (data outside the normal range of cluster) and cluster will shift a lot when computing mean.For example:I have a dataset like [-100, -1, 0, 1, 5,6,7], where -100 is a outlier point as it is pretty far away from other data points. If I have two cluster centers 0, 8, then [-100, -1, 0, 1] will belong to cluster 0 and [5,6, 7] belongs to cluster 8.When I update the centers of two clusters, they become (-100-1+0+1) / 4 = -25, and (5+6+7)/3 = 6. We can see that -25 this center is actually very far away from data points (-1, 0, 1) due to outlier -100. In the next assignment of points, all (-1, 0, 1) points will be assigned to another cluster based on distance. Hence the clustering pattern will be distorted. K-mean Clustering needs to store all data points to compute. It can lead to large space complexity when handling large data. K-mean Clustering can detect Convex patterns only, such as circle, retangle, triangle. But for non-convex patterns, like U-shape, V-shape, patterns, it can not make cluster correctly. Not work directly in high dimensional data and unstructured data like image. When to Use When we want to simply visualize the data distribution, we can use PCA, t-SNE to reduce dimension of data and use K-mean clustering to visualize them When the data is in low dimension Some extension of clustering K-medoid clustering: using median rather than mean to update clustring Hierarchical Clustering: use distance matrix as clustering criteria. Without the need of value K but need terminal state BIRCH CF-Tree: tree-based hierarchical clustering Density clustering DBSCAN OPTICS â€¦ Reference[1] https://i.ytimg.com/vi/_aWzGGNrcic/hqdefault.jpg","link":"/2020/11/23/ML-K-mean-Cluster/"},{"title":"GNN-1-Basic","text":"1. Graph Basicå‚è€ƒèµ„æ–™: â€œChapter 2 - Foundations of Graphs, Deep Learning on Graphsâ€ å›¾çš„è¡¨ç¤ºå®šä¹‰ä¸€ï¼ˆå›¾ï¼‰ï¼š ä¸€ä¸ªå›¾è¢«è®°ä¸º $\\mathcal{G}={\\mathcal{V}, \\mathcal{E}}$ï¼Œå…¶ä¸­ $\\mathcal{V}={v_{1}, \\ldots, v_{N}}$ æ˜¯æ•°é‡ä¸º $N=|\\mathcal{V}|$ çš„ç»“ç‚¹çš„é›†åˆï¼Œ $\\mathcal{E}={e_{1}, \\ldots, e_{M}}$ æ˜¯æ•°é‡ä¸º $M$ çš„è¾¹çš„é›†åˆã€‚ å›¾ç”¨èŠ‚ç‚¹è¡¨ç¤ºå®ä½“ï¼ˆentities ï¼‰ï¼Œç”¨è¾¹è¡¨ç¤ºå®ä½“é—´çš„å…³ç³»ï¼ˆrelationsï¼‰ã€‚ èŠ‚ç‚¹å’Œè¾¹çš„ä¿¡æ¯å¯ä»¥æ˜¯ç±»åˆ«å‹çš„ï¼ˆcategoricalï¼‰ï¼Œç±»åˆ«å‹æ•°æ®çš„å–å€¼åªèƒ½æ˜¯å“ªä¸€ç±»åˆ«ã€‚ä¸€èˆ¬ç§°ç±»åˆ«å‹çš„ä¿¡æ¯ä¸ºæ ‡ç­¾ï¼ˆlabelï¼‰ã€‚ èŠ‚ç‚¹å’Œè¾¹çš„ä¿¡æ¯å¯ä»¥æ˜¯æ•°å€¼å‹çš„ï¼ˆnumericï¼‰ï¼Œç±»åˆ«å‹æ•°æ®çš„å–å€¼èŒƒå›´ä¸ºå®æ•°ã€‚ä¸€èˆ¬ç§°ç±»åˆ«å‹çš„ä¿¡æ¯ä¸ºå±æ€§ï¼ˆattributeï¼‰ã€‚ å¤§éƒ¨åˆ†æƒ…å†µä¸­ï¼ŒèŠ‚ç‚¹å«æœ‰ä¿¡æ¯ï¼Œè¾¹å¯èƒ½å«æœ‰ä¿¡æ¯ã€‚ å®šä¹‰äºŒï¼ˆå›¾çš„é‚»æ¥çŸ©é˜µï¼‰ï¼š ç»™å®šä¸€ä¸ªå›¾$\\mathcal{G}={\\mathcal{V}, \\mathcal{E}}$ï¼Œå…¶å¯¹åº”çš„é‚»æ¥çŸ©é˜µè¢«è®°ä¸º$\\mathbf{A} \\in{0,1}^{N \\times N}$ã€‚$\\mathbf{A}_{i, j}=1$è¡¨ç¤ºå­˜åœ¨ä»ç»“ç‚¹$v_i$åˆ°$v_j$çš„è¾¹ï¼Œåä¹‹è¡¨ç¤ºä¸å­˜åœ¨ä»ç»“ç‚¹$v_i$åˆ°$v_j$çš„è¾¹ã€‚ åœ¨æ— å‘å›¾ä¸­ï¼Œä»ç»“ç‚¹$v_i$åˆ°$v_j$çš„è¾¹å­˜åœ¨ï¼Œæ„å‘³ç€ä»ç»“ç‚¹$v_j$åˆ°$v_i$çš„è¾¹ä¹Ÿå­˜åœ¨ã€‚å› è€Œæ— å‘å›¾çš„é‚»æ¥çŸ©é˜µæ˜¯å¯¹ç§°çš„ã€‚ åœ¨æ— æƒå›¾ä¸­ï¼Œå„æ¡è¾¹çš„æƒé‡è¢«è®¤ä¸ºæ˜¯ç­‰ä»·çš„ï¼Œå³è®¤ä¸º**å„æ¡è¾¹çš„æƒé‡ä¸º$1$**ã€‚ å¯¹äºæœ‰æƒå›¾ï¼Œå…¶å¯¹åº”çš„é‚»æ¥çŸ©é˜µé€šå¸¸è¢«è®°ä¸º$\\mathbf{W} \\in{0,1}^{N \\times N}$ï¼Œå…¶ä¸­$\\mathbf{W}{i, j}=w{ij}$è¡¨ç¤ºä»ç»“ç‚¹$v_i$åˆ°$v_j$çš„è¾¹çš„æƒé‡ã€‚è‹¥è¾¹ä¸å­˜åœ¨æ—¶ï¼Œè¾¹çš„æƒé‡ä¸º$0$ã€‚ ä¸€ä¸ªæ— å‘æ— æƒå›¾çš„ä¾‹å­ï¼š å…¶é‚»æ¥çŸ©é˜µ(Adjacency matrix)ä¸ºï¼š $$\\mathbf{A}=(\\begin{array}{lllll} 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\\\ 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\end{array})$$ äºŒã€å›¾çš„å±æ€§å®šä¹‰ä¸‰ï¼ˆç»“ç‚¹çš„åº¦ï¼Œdegreeï¼‰ï¼š å¯¹äºæœ‰å‘æœ‰æƒå›¾ï¼Œç»“ç‚¹$v_i$çš„å‡ºåº¦ï¼ˆout degreeï¼‰ç­‰äºä»$v_i$å‡ºå‘çš„è¾¹çš„æƒé‡ä¹‹å’Œï¼Œç»“ç‚¹$v_i$çš„å…¥åº¦ï¼ˆin degreeï¼‰ç­‰äºä»è¿å‘$v_i$çš„è¾¹çš„æƒé‡ä¹‹å’Œã€‚ æ— å‘å›¾æ˜¯æœ‰å‘å›¾çš„ç‰¹æ®Šæƒ…å†µï¼Œç»“ç‚¹çš„å‡ºåº¦ä¸å…¥åº¦ç›¸ç­‰ã€‚ æ— æƒå›¾æ˜¯æœ‰æƒå›¾çš„ç‰¹æ®Šæƒ…å†µï¼Œå„è¾¹çš„æƒé‡ä¸º$1$ï¼Œé‚£ä¹ˆç»“ç‚¹$v_i$çš„å‡ºåº¦ï¼ˆout degreeï¼‰ç­‰äºä»$v_i$å‡ºå‘çš„è¾¹çš„æ•°é‡ï¼Œç»“ç‚¹$v_i$çš„å…¥åº¦ï¼ˆin degreeï¼‰ç­‰äºä»è¿å‘$v_i$çš„è¾¹çš„æ•°é‡ã€‚ ç»“ç‚¹$v_i$çš„åº¦è®°ä¸º$d(v_i)$ï¼Œå…¥åº¦è®°ä¸º$d_{in}(v_i)$ï¼Œå‡ºåº¦è®°ä¸º$d_{out}(v_i)$ã€‚ å®šä¹‰å››ï¼ˆé‚»æ¥ç»“ç‚¹ï¼Œneighborsï¼‰ï¼š ç»“ç‚¹$v_i$çš„é‚»æ¥ç»“ç‚¹ä¸ºä¸ç»“ç‚¹$v_i$ç›´æ¥ç›¸è¿çš„ç»“ç‚¹ï¼Œå…¶è¢«è®°ä¸º**$\\mathcal{N(v_i)}$**ã€‚ ç»“ç‚¹$v_i$çš„$k$è·³è¿œçš„é‚»æ¥èŠ‚ç‚¹ï¼ˆneighbors with $k$-hopï¼‰æŒ‡çš„æ˜¯åˆ°ç»“ç‚¹$v_i$è¦èµ°$k$æ­¥çš„èŠ‚ç‚¹ï¼ˆä¸€ä¸ªèŠ‚ç‚¹çš„$2$è·³è¿œçš„é‚»æ¥èŠ‚ç‚¹åŒ…å«äº†è‡ªèº«ï¼‰ã€‚ å®šä¹‰äº”ï¼ˆè¡Œèµ°ï¼Œwalkï¼‰ï¼š $walk(v_1, v_2) = (v_1, e_6,e_5,e_4,e_1,v_2)$ï¼Œè¿™æ˜¯ä¸€æ¬¡â€œè¡Œèµ°â€ï¼Œå®ƒæ˜¯ä¸€æ¬¡ä»èŠ‚ç‚¹$v_1$å‡ºå‘ï¼Œä¾æ¬¡ç»è¿‡è¾¹$e_6,e_5,e_4,e_1$ï¼Œæœ€ç»ˆåˆ°è¾¾èŠ‚ç‚¹$v_2$çš„â€œè¡Œèµ°â€ã€‚ ä¸‹å›¾æ‰€ç¤ºä¸º$walk(v_1, v_2) = (v_1, e_6,e_5,e_4,e_1,v_2)$ï¼Œå…¶ä¸­çº¢è‰²æ•°å­—æ ‡è¯†äº†è¾¹çš„è®¿é—®åºå·ã€‚ åœ¨â€œè¡Œèµ°â€ä¸­ï¼ŒèŠ‚ç‚¹æ˜¯è¿è¡Œé‡å¤çš„ã€‚ å®šç†å…­ï¼š æœ‰ä¸€å›¾ï¼Œå…¶é‚»æ¥çŸ©é˜µä¸º $\\mathbf{A}$, $\\mathbf{A}^{n}$ä¸ºé‚»æ¥çŸ©é˜µçš„$n$æ¬¡æ–¹ï¼Œé‚£ä¹ˆ$\\mathbf{A}^{n}[i,j]$ç­‰äºä»ç»“ç‚¹$v_i$åˆ°ç»“ç‚¹$v_j$çš„é•¿åº¦ä¸º$n$çš„è¡Œèµ°çš„ä¸ªæ•°ã€‚ å®šä¹‰ä¸ƒï¼ˆè·¯å¾„ï¼Œpathï¼‰ï¼š â€œè·¯å¾„â€æ˜¯ç»“ç‚¹ä¸å¯é‡å¤çš„â€œè¡Œèµ°â€ã€‚ å®šä¹‰å…«ï¼ˆå­å›¾ï¼Œsubgraphï¼‰ï¼š æœ‰ä¸€å›¾$\\mathcal{G}={\\mathcal{V}, \\mathcal{E}}$ï¼Œå¦æœ‰ä¸€å›¾$\\mathcal{G}^{\\prime}={\\mathcal{V}^{\\prime}, \\mathcal{E}^{\\prime}}$ï¼Œå…¶ä¸­$\\mathcal{V}^{\\prime} \\in \\mathcal{V}$ï¼Œ$\\mathcal{E}^{\\prime} \\in \\mathcal{E}$å¹¶ä¸”$\\mathcal{V}^{\\prime}$ä¸åŒ…å«$\\mathcal{E}^{\\prime}$ä¸­æœªå‡ºç°è¿‡çš„ç»“ç‚¹ï¼Œé‚£ä¹ˆ$\\mathcal{G}^{\\prime}$æ˜¯$\\mathcal{G}$çš„å­å›¾ã€‚ å®šä¹‰ä¹ï¼ˆè¿é€šåˆ†é‡ï¼Œconnected componentï¼‰ï¼š ç»™å®šå›¾$\\mathcal{G}^{\\prime}={\\mathcal{V}^{\\prime}, \\mathcal{E}^{\\prime}}$æ˜¯å›¾$\\mathcal{G}={\\mathcal{V}, \\mathcal{E}}$çš„å­å›¾ã€‚è®°å±äºå›¾$\\mathcal{G}$ä½†ä¸å±äº$\\mathcal{G}^{\\prime}$å›¾çš„ç»“ç‚¹é›†åˆè®°ä¸º$\\mathcal{V}/\\mathcal{V}^{\\prime}$ ã€‚å¦‚æœå±äº$\\mathcal{V}^{\\prime}$çš„ä»»æ„ç»“ç‚¹å¯¹ä¹‹é—´å­˜åœ¨è‡³å°‘ä¸€æ¡è·¯å¾„ï¼Œä½†ä¸å­˜åœ¨ä¸€æ¡è¾¹è¿æ¥å±äº$\\mathcal{V}^{\\prime}$çš„ç»“ç‚¹ä¸å±äº$\\mathcal{V}/\\mathcal{V}^{\\prime}$çš„ç»“ç‚¹ï¼Œé‚£ä¹ˆå›¾$\\mathcal{G}^{\\prime}$æ˜¯å›¾$\\mathcal{G}$çš„è¿é€šåˆ†é‡ã€‚ å®šä¹‰åï¼ˆè¿é€šå›¾ï¼Œconnected graphï¼‰ï¼š å½“ä¸€ä¸ªå›¾åªåŒ…å«ä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œå³å…¶è‡ªèº«ï¼Œé‚£ä¹ˆè¯¥å›¾æ˜¯ä¸€ä¸ªè¿é€šå›¾ã€‚ å®šä¹‰åä¸€ï¼ˆæœ€çŸ­è·¯å¾„ï¼Œshortest pathï¼‰ï¼š $v_{s}, v_{t} \\in \\mathcal{V}$ æ˜¯å›¾$\\mathcal{G}={\\mathcal{V}, \\mathcal{E}}$ä¸Šçš„ä¸€å¯¹ç»“ç‚¹ï¼Œç»“ç‚¹å¯¹ $v_{s}, v_{t} \\in \\mathcal{V}$ ä¹‹é—´æ‰€æœ‰è·¯å¾„çš„é›†åˆè®°ä¸º $P_{\\mathrm{st}}$ ã€‚ç»“ç‚¹å¯¹$v_{s}, v_{t}$ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ $p_{\\mathrm{s} t}^{\\mathrm{sp}}$ä¸º$\\mathcal{P}_{\\mathrm{st}}$ ä¸­é•¿åº¦æœ€çŸ­çš„ä¸€æ¡è·¯å¾„ï¼Œå…¶å½¢å¼åŒ–å®šä¹‰ä¸º$$p_{\\mathrm{s} t}^{\\mathrm{sp}}=\\arg \\min {p \\in \\mathcal{P}{\\mathrm{st}}}|p|$$å…¶ä¸­ï¼Œ$p$è¡¨ç¤º$\\mathcal{P}_{\\mathrm{st}}$ä¸­çš„ä¸€æ¡è·¯å¾„ï¼Œ$|p|$æ˜¯è·¯å¾„$p$çš„é•¿åº¦ã€‚ å®šä¹‰åäºŒï¼ˆç›´å¾„ï¼Œdiameterï¼‰ï¼š ç»™å®šä¸€ä¸ªè¿é€šå›¾$\\mathcal{G}={\\mathcal{V}, \\mathcal{E}}$ï¼Œå…¶ç›´å¾„ä¸ºå…¶æ‰€æœ‰ç»“ç‚¹å¯¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„çš„æœ€å°å€¼ï¼Œå½¢å¼åŒ–å®šä¹‰ä¸º $$diameter(\\mathcal{G})=\\max_{v_{s}, v_{t} \\in \\mathcal{V}} \\min_{p \\in \\mathcal{P}_{s t}}|p|$$ å®šä¹‰åä¸‰ï¼ˆæ‹‰æ™®æ‹‰æ–¯çŸ©é˜µï¼ŒLaplacian Matrixï¼‰ï¼š ç»™å®šä¸€ä¸ªå›¾$\\mathcal{G}={\\mathcal{V}, \\mathcal{E}}$ï¼Œå…¶é‚»æ¥çŸ©é˜µä¸º$A$ï¼Œå…¶æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µå®šä¹‰ä¸º$\\mathbf{L=D-A}$ï¼Œå…¶ä¸­$\\mathbf{D=diag(d(v_1), \\cdots, d(v_N))}$ã€‚ å®šä¹‰åå››ï¼ˆå¯¹ç§°å½’ä¸€åŒ–çš„æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µï¼ŒSymmetric normalized Laplacianï¼‰ï¼š ç»™å®šä¸€ä¸ªå›¾$\\mathcal{G}={\\mathcal{V}, \\mathcal{E}}$ï¼Œå…¶é‚»æ¥çŸ©é˜µä¸º$A$ï¼Œå…¶è§„èŒƒåŒ–çš„æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µå®šä¹‰ä¸º $$\\mathbf{L=D^{-\\frac{1}{2}}(D-A)D^{-\\frac{1}{2}}=I-D^{-\\frac{1}{2}}AD^{-\\frac{1}{2}}}$$ ä¸‰ã€å›¾çš„ç§ç±» åŒè´¨å›¾ï¼ˆHomogeneous Graphï¼‰ï¼šåªæœ‰ä¸€ç§ç±»å‹çš„èŠ‚ç‚¹å’Œä¸€ç§ç±»å‹çš„è¾¹çš„å›¾ã€‚ å¼‚è´¨å›¾ï¼ˆHeterogeneous Graphï¼‰ï¼šå­˜åœ¨å¤šç§ç±»å‹çš„èŠ‚ç‚¹å’Œå¤šç§ç±»å‹çš„è¾¹çš„å›¾ã€‚ äºŒéƒ¨å›¾ï¼ˆBipartite Graphsï¼‰ï¼šèŠ‚ç‚¹åˆ†ä¸ºä¸¤ç±»ï¼Œåªæœ‰ä¸åŒç±»çš„èŠ‚ç‚¹ä¹‹é—´å­˜åœ¨è¾¹ã€‚ å››ã€å›¾ç»“æ„æ•°æ®ä¸Šçš„æœºå™¨å­¦ä¹  èŠ‚ç‚¹é¢„æµ‹ï¼šé¢„æµ‹èŠ‚ç‚¹çš„ç±»åˆ«æˆ–æŸç±»å±æ€§çš„å–å€¼ ä¾‹å­ï¼šå¯¹æ˜¯å¦æ˜¯æ½œåœ¨å®¢æˆ·åˆ†ç±»ã€å¯¹æ¸¸æˆç©å®¶çš„æ¶ˆè´¹èƒ½åŠ›åšé¢„æµ‹ è¾¹é¢„æµ‹ï¼šé¢„æµ‹ä¸¤ä¸ªèŠ‚ç‚¹é—´æ˜¯å¦å­˜åœ¨é“¾æ¥ ä¾‹å­ï¼šKnowledge graph completionã€å¥½å‹æ¨èã€å•†å“æ¨è å›¾çš„é¢„æµ‹ï¼šå¯¹ä¸åŒçš„å›¾è¿›è¡Œåˆ†ç±»æˆ–é¢„æµ‹å›¾çš„å±æ€§ ä¾‹å­ï¼šåˆ†å­å±æ€§é¢„æµ‹ èŠ‚ç‚¹èšç±»ï¼šæ£€æµ‹èŠ‚ç‚¹æ˜¯å¦å½¢æˆä¸€ä¸ªç¤¾åŒº ä¾‹å­ï¼šç¤¾äº¤åœˆæ£€æµ‹ å…¶ä»–ä»»åŠ¡ å›¾ç”Ÿæˆï¼šä¾‹å¦‚è¯ç‰©å‘ç° å›¾æ¼”å˜ï¼šä¾‹å¦‚ç‰©ç†æ¨¡æ‹Ÿ â€¦â€¦ äº”ã€åº”ç”¨ç¥ç»ç½‘ç»œäºå›¾é¢ä¸´çš„æŒ‘æˆ˜åœ¨å­¦ä¹ äº†ç®€å•çš„å›¾è®ºçŸ¥è¯†ï¼Œæˆ‘ä»¬å†æ¥å›é¡¾åº”ç”¨ç¥ç»ç½‘ç»œäºå›¾é¢ä¸´çš„æŒ‘æˆ˜ã€‚ è¿‡å»çš„æ·±åº¦å­¦ä¹ åº”ç”¨ä¸­ï¼Œæˆ‘ä»¬ä¸»è¦æ¥è§¦çš„æ•°æ®å½¢å¼ä¸»è¦æ˜¯è¿™å››ç§ï¼šçŸ©é˜µã€å¼ é‡ã€åºåˆ—ï¼ˆsequenceï¼‰å’Œæ—¶é—´åºåˆ—ï¼ˆtime seriesï¼‰ï¼Œå®ƒä»¬éƒ½æ˜¯è§„åˆ™çš„ç»“æ„åŒ–çš„æ•°æ®ã€‚ç„¶è€Œå›¾æ•°æ®æ˜¯éè§„åˆ™çš„éç»“æ„åŒ–çš„ï¼Œå®ƒå…·æœ‰ä»¥ä¸‹çš„ç‰¹ç‚¹ï¼š ä»»æ„çš„å¤§å°å’Œå¤æ‚çš„æ‹“æ‰‘ç»“æ„ï¼› æ²¡æœ‰å›ºå®šçš„ç»“ç‚¹æ’åºæˆ–å‚è€ƒç‚¹ï¼› é€šå¸¸æ˜¯åŠ¨æ€çš„ï¼Œå¹¶å…·æœ‰å¤šæ¨¡æ€çš„ç‰¹å¾ï¼› å›¾çš„ä¿¡æ¯å¹¶éåªè•´å«åœ¨èŠ‚ç‚¹ä¿¡æ¯å’Œè¾¹çš„ä¿¡æ¯ä¸­ï¼Œå›¾çš„ä¿¡æ¯è¿˜åŒ…æ‹¬äº†å›¾çš„æ‹“æ‰‘ç»“æ„ã€‚ ä»¥å¾€çš„æ·±åº¦å­¦ä¹ æŠ€æœ¯æ˜¯ä¸ºè§„åˆ™ä¸”ç»“æ„åŒ–çš„æ•°æ®è®¾è®¡çš„ï¼Œæ— æ³•ç›´æ¥ç”¨äºå›¾æ•°æ®ã€‚åº”ç”¨äºå›¾æ•°æ®çš„ç¥ç»ç½‘ç»œï¼Œè¦æ±‚ é€‚ç”¨äºä¸åŒåº¦çš„èŠ‚ç‚¹ï¼› èŠ‚ç‚¹è¡¨å¾çš„è®¡ç®—ä¸é‚»æ¥èŠ‚ç‚¹çš„æ’åºæ— å…³ï¼› ä¸ä½†èƒ½å¤Ÿæ ¹æ®èŠ‚ç‚¹ä¿¡æ¯ã€é‚»æ¥èŠ‚ç‚¹çš„ä¿¡æ¯å’Œè¾¹çš„ä¿¡æ¯è®¡ç®—èŠ‚ç‚¹è¡¨å¾ï¼Œè¿˜èƒ½æ ¹æ®å›¾æ‹“æ‰‘ç»“æ„è®¡ç®—èŠ‚ç‚¹è¡¨å¾ã€‚ä¸‹é¢çš„å›¾ç‰‡å±•ç¤ºäº†ä¸€ä¸ªéœ€è¦æ ¹æ®å›¾æ‹“æ‰‘ç»“æ„è®¡ç®—èŠ‚ç‚¹è¡¨å¾çš„ä¾‹å­ã€‚å›¾ç‰‡ä¸­å±•ç¤ºäº†ä¸¤ä¸ªå›¾ï¼Œå®ƒä»¬åŒæ ·æœ‰ä¿©é»„ã€ä¿©è“ã€ä¿©ç»¿ï¼Œå…±6ä¸ªèŠ‚ç‚¹ï¼Œå› æ­¤å®ƒä»¬çš„èŠ‚ç‚¹ä¿¡æ¯ç›¸åŒï¼›å‡è®¾è¾¹ä¸¤ç«¯èŠ‚ç‚¹çš„ä¿¡æ¯ä¸ºè¾¹çš„ä¿¡æ¯ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªå›¾æœ‰ä¸€æ ·çš„è¾¹ï¼Œå³å®ƒä»¬çš„è¾¹ä¿¡æ¯ç›¸åŒã€‚ä½†è¿™ä¸¤ä¸ªå›¾æ˜¯ä¸ä¸€æ ·çš„å›¾ï¼Œå®ƒä»¬çš„æ‹“æ‰‘ç»“æ„ä¸ä¸€æ ·ã€‚ å…­ã€ç»“è¯­åœ¨æ­¤ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†ç®€å•çš„å›¾è®ºçŸ¥è¯†ã€‚å¯¹äºå­¦ä¹ æ­¤æ¬¡ç»„é˜Ÿå­¦ä¹ åç»­çš„å†…å®¹ï¼ŒæŒæ¡è¿™äº›å›¾è®ºçŸ¥è¯†å·²ç»è¶³å¤Ÿã€‚å¦‚æœæœ‰å°ä¼™ä¼´å¸Œæœ›æŒæ¡æ›´å¤šçš„å›¾è®ºçŸ¥è¯†å¯ä»¥å‚é˜…å‚è€ƒæ–‡çŒ®â€œChapter 2 - Foundations of Graphs, Deep Learning on Graphsâ€ã€‚ å‚è€ƒèµ„æ–™ Chapter 2 - Foundations of Graphs, Deep Learning on Graphs 2. Practiceå…ˆçœ‹çœ‹torchçš„version ä»¥åŠtorchä½¿ç”¨çš„cuda version 12import torchtorch.version.cuda, torch.__version__ ('11.1', '1.8.1') æ ¹æ®å®ƒä»¬çš„ç‰ˆæœ¬å¯¹ ä¸‹é¢çš„htmlçš„åå­—è°ƒæ•´ï¼Œ è¿™é‡Œæˆ‘ç”¨çš„æ˜¯torch cuda æ˜¯ 11.1ï¼Œtorch æ˜¯1.8.1æ‰€ä»¥ç”¨torch-1.8.1+cu111.html 12345# pip install torch-scatter -f https://pytorch-geometric.com/whl/torch-1.8.1+cu111.html --no-cache# pip install torch-sparse -f https://pytorch-geometric.com/whl/torch-1.8.1+cu111.html --no-cache# pip install torch-cluster -f https://pytorch-geometric.com/whl/torch-1.8.1+cu111.html --no-cache# pip install torch-spline-conv -f https://pytorch-geometric.com/whl/torch-1.8.1+cu111.html --no-cache# pip install torch-geometric æµ‹è¯•å®‰è£…å¥½çš„torch_geometric,å¦å¤–ä¹Ÿä¸‹è½½coraæ•°æ®è¿›è¡Œæµ‹è¯• 1234567891011121314151617from torch_geometric.datasets import KarateClubdataset = KarateClub()data = dataset[0] # Get the first graph object.print(data)print('==============================================================')print(f'Number of node features:{data.num_node_features}') # èŠ‚ç‚¹å±æ€§çš„ç»´åº¦print(f'Number of node features: {data.num_features}')# åŒæ ·æ˜¯èŠ‚ç‚¹å±æ€§çš„ç»´åº¦print(f'Number of edge features: {data.num_edge_features}') # è¾¹å±æ€§çš„ç»´åº¦print(f'Average node degree: {data.num_edges /data.num_nodes:.2f}') # å¹³å‡èŠ‚ç‚¹åº¦print(f'if edge indices are ordered and do not contain duplicate entries.: {data.is_coalesced()}') # æ˜¯å¦è¾¹æ˜¯æœ‰åºçš„åŒæ—¶ä¸å«æœ‰é‡å¤çš„è¾¹print(f'Number of training nodes: {data.train_mask.sum()}') # ç”¨ä½œè®­ç»ƒé›†çš„èŠ‚ç‚¹print(f'Training node label rate: {int(data.train_mask.sum()) / data.num_nodes:.2f}') #ç”¨ä½œè®­ç»ƒé›†çš„èŠ‚ç‚¹çš„æ•°é‡print(f'Contains isolated nodes: {data.contains_isolated_nodes()}') # æ­¤å›¾æ˜¯å¦åŒ…å«å­¤ç«‹çš„èŠ‚ç‚¹print(f'Contains self-loops: {data.contains_self_loops()}') # æ­¤å›¾æ˜¯å¦åŒ…å«è‡ªç¯çš„è¾¹print(f'Is undirected: {data.is_undirected()}') # æ­¤å›¾ æ˜¯å¦æ˜¯æ— å‘å›¾ Data(edge_index=[2, 156], train_mask=[34], x=[34, 34], y=[34]) ============================================================== Number of node features:34 Number of node features: 34 Number of edge features: 0 Average node degree: 4.59 if edge indices are ordered and do not contain duplicate entries.: True Number of training nodes: 4 Training node label rate: 0.12 Contains isolated nodes: False Contains self-loops: False Is undirected: True 1! wget https://github.com/kimiyoung/planetoid/raw/master/data/ind.cora.x --2021-06-14 13:56:45-- https://github.com/kimiyoung/planetoid/raw/master/data/ind.cora.x Resolving github.com (github.com)... 140.82.112.4 Connecting to github.com (github.com)|140.82.112.4|:443... connected. HTTP request sent, awaiting response... 302 Found Location: https://raw.githubusercontent.com/kimiyoung/planetoid/master/data/ind.cora.x [following] --2021-06-14 13:56:46-- https://raw.githubusercontent.com/kimiyoung/planetoid/master/data/ind.cora.x Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.110.133, 185.199.111.133, 185.199.108.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.110.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 22119 (22K) [application/octet-stream] Saving to: â€˜ind.cora.xâ€™ ind.cora.x 100%[===================&gt;] 21.60K --.-KB/s in 0s 2021-06-14 13:56:46 (69.8 MB/s) - â€˜ind.cora.xâ€™ saved [22119/22119] 123456789from torch_geometric.datasets import Planetoiddataset = Planetoid(root='./dataset/Cora', name='Cora')# Cora()len(dataset)# 1dataset.num_classes# 7dataset.num_node_features# 1433 Downloading https://github.com/kimiyoung/planetoid/raw/master/data/ind.cora.x Downloading https://github.com/kimiyoung/planetoid/raw/master/data/ind.cora.tx Downloading https://github.com/kimiyoung/planetoid/raw/master/data/ind.cora.allx Downloading https://github.com/kimiyoung/planetoid/raw/master/data/ind.cora.y Downloading https://github.com/kimiyoung/planetoid/raw/master/data/ind.cora.ty Downloading https://github.com/kimiyoung/planetoid/raw/master/data/ind.cora.ally Downloading https://github.com/kimiyoung/planetoid/raw/master/data/ind.cora.graph Downloading https://github.com/kimiyoung/planetoid/raw/master/data/ind.cora.test.index Processing... Done! 1433 12345678910data = dataset[0]# Data(edge_index=[2, 10556], test_mask=[2708],# train_mask=[2708], val_mask=[2708], x=[2708,1433], y=[2708])data.is_undirected()# Truedata.train_mask.sum().item()# 140data.val_mask.sum().item()# 500data.test_mask.sum().item() 1000 3. Torch_geometric Data set ä½¿ç”¨åœ¨ from torch_geometric.data import Dataè°ƒç”¨ Data classä¹‹åï¼Œ Dataåˆ›å»ºçš„å®ä¾‹æ—¶çš„è¾“å…¥æœ‰ä»¥ä¸‹: data.x:èŠ‚ç‚¹çš„æ•°æ®çŸ©é˜µï¼Œè¿™ä¸ªçŸ©é˜µçš„å¤§å°ä¸º [num_nodes, num_node_features] data.edge_index: å›¾çš„è¿æ¥ä¿¡æ¯ï¼Œå­˜æ”¾åœ¨Coordinate format (COO format) å®ƒçš„çŸ©é˜µå¤§å°ä¸º[2, num_edges] data typeæ˜¯torch.long data.edge_attr: è¾¹çš„ç‰¹å¾çŸ©é˜µå®ƒçš„shapeæ˜¯ [num_edges, num_edge_features] data.y: ç”¨äºè®­ç»ƒå›¾ç¥ç»ç½‘ç»œçš„targetï¼Œå®ƒèƒ½å¤Ÿæœ‰ä¸åŒçš„å½¢çŠ¶ï¼Œå¯ä»¥æ˜¯å¯¹åº”èŠ‚ç‚¹ç‰¹å¾çš„targetï¼Œä¹Ÿå¯ä»¥æ˜¯å¯¹åº”æ•´ä¸ªå›¾çš„target, e.g., node-level targets of shape [num_nodes, *] or graph-level targets of shape [1, *] data.pos: èŠ‚ç‚¹çš„ä½ç½®ä¿¡æ¯ï¼Œå®ƒçš„shapeæ˜¯ [num_nodes, num_dimensions]ï¼Œ æ¯ä¸€è¡Œä»£è¡¨æœ‰ä¸€ä¸ªnodeçš„ä½ç½® è¯¦æƒ…å¯ä»¥å‚è€ƒå®˜æ–¹æ–‡æ¡£: https://pytorch-geometric.readthedocs.io/en/latest/notes/introduction.html 4. Assignmentè¿™é‡Œå®è·µä¸€éï¼Œ é€šè¿‡æŠŠData classç»§æ‰¿è‡ªå®šä¹‰è‡ªå·±çš„graph datasetï¼Œ è¿™ä¸ªå’Œtorchçš„è‡ªå®šä¹‰datasetçš„åˆ›å»ºå¾ˆç›¸ä¼¼ã€‚ é¢˜ç›®: è¯·é€šè¿‡ç»§æ‰¿Data ç±»å®ç°ä¸€ä¸ªç±»ï¼Œä¸“é—¨ç”¨äºè¡¨ç¤ºâ€œæœºæ„-ä½œè€…-è®ºæ–‡â€çš„ç½‘ç»œã€‚è¯¥ç½‘ç»œåŒ…å«â€œæœºæ„â€œã€â€ä½œè€…â€œå’Œâ€è®ºæ–‡â€ä¸‰ç±»èŠ‚ç‚¹ï¼Œä»¥åŠâ€œä½œè€…-æœºæ„â€œå’Œâ€œä½œè€…-è®ºæ–‡â€œä¸¤ç±»è¾¹ã€‚å¯¹è¦å®ç°çš„ç±»çš„è¦æ±‚ï¼š1ï¼‰ç”¨ä¸åŒçš„å±æ€§å­˜å‚¨ä¸åŒèŠ‚ç‚¹çš„å±æ€§ï¼›2ï¼‰ç”¨ä¸åŒçš„å±æ€§å­˜å‚¨ä¸åŒçš„è¾¹ï¼ˆè¾¹æ²¡æœ‰å±æ€§ï¼‰ï¼›3ï¼‰é€ä¸€å®ç°è·å–ä¸åŒèŠ‚ç‚¹æ•°é‡çš„æ–¹æ³•ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192from torch_geometric.data import Dataimport numpy as npclass MyGraphData(Data): def __init__(self, data, labels, **args ): \"\"\" data: structural data, a table. Each column of table is one type of node so in this case: we have author, department, paper 3 different types of node. each value in the table represent a data value/ID value in a data node in graph Example: author depart paper 1 1 1 2 1 2 Then author #1 in department 1 writes 1 paper author #2 in department 2 writes 2 papers This is a heterogenuous graph I consider the missing value and isolated nodes in the input data as well. **args: other args passed to the Graph Data \"\"\" super(MyGraphData, self).__init__() self.data = data self.edge_index = None self.x = None self.y = None self.node_list = [] self.labels = labels self.create_graph(self.data) pass def create_graph(self,data): self.edge_index = [] for row in self.data.values: # we get 3 nodes here, each has type / target: department, author, paper respectively dept = row[0] author = row[1] paper = row[2] print(dept, author, paper) dept_node_index = self.__add_node(self.node_list, dept, self.labels['dept']) #if dept !=None else None author_node_index = self.__add_node(self.node_list, author, self.labels['author']) #if author !=None else None paper_node_index = self.__add_node(self.node_list, paper, self.labels['paper']) #if paper !=None else None # add undirected author-department edge if dept_node_index!=None and author_node_index!=None: self.edge_index.append([dept_node_index, author_node_index]) self.edge_index.append([ author_node_index,dept_node_index]) # add undirected author-paper edge if author_node_index!=None and paper_node_index!=None: self.edge_index.append([ author_node_index,paper_node_index]) self.edge_index.append([ paper_node_index,author_node_index]) # first row = from node , second row = to node self.edge_index = torch.tensor(np.array(self.edge_index).T, dtype= torch.long) # gather value of each node into a feature matrix x self.x = torch.tensor([node[0] for node in self.node_list], dtype= torch.float) # gather target for each node self.y = torch.tensor([node[1] for node in self.node_list], dtype = torch.float) return self.x, self.edge_index, self.y def __add_node(self, node_ls, node, target): if node == None or np.isnan(node): return None if node_ls.count([node, target]) ==0: # check if node exists node_ls.append([node, target]) # return the index of the unique node node_idx = node_ls.index([node, target]) return node_idx @property def dept_nums(self): return self.data['dept'].nunique() @property def author_nums(self): return self.data['author'].nunique() @property def paper_nums(self): return self.data['paper'].nunique() @property def isolated_nodes(self): iso_nodes = [] for n in range(len(self.node_list)): if n not in self.edge_index: iso_nodes.append(self.node_list[n]) return iso_nodes 1234# Data(edge_index=[2, 4], x=[3, 1])import pandas as pdx = pd.DataFrame(data= [[1,1,1],[2,2,1],[None, None, 3]], columns=[\"dept\",\"author\",\"paper\"])data = MyGraphData(data = x, labels = {\"dept\":0,\"author\":1,\"paper\":2}) 1.0 1.0 1.0 2.0 2.0 1.0 nan nan 3.0 12345678print(\"Test Results:\")print(f\"Number of authors: {data.author_nums}\")print(f\"Number of papers: {data.paper_nums}\")print(f\"Number of departments: {data.dept_nums}\")print(f\"Number of isolated nodes: {len(data.isolated_nodes)}\")print(f\"Edge index: {data.edge_index}\")print(f\"x representation matrix: {data.x}\")print(f\"Node index [value, label]: {data.node_list}\") Test Results: Number of authors: 2 Number of papers: 2 Number of departments: 2 Number of isolated nodes: 1 Edge index: tensor([[0, 1, 1, 2, 3, 4, 4, 2], [1, 0, 2, 1, 4, 3, 2, 4]]) x representation matrix: tensor([1., 1., 1., 2., 2., 3.]) Node index [value, label]: [[1.0, 0], [1.0, 1], [1.0, 2], [2.0, 0], [2.0, 1], [3.0, 2]] 12","link":"/2021/06/15/GNN-1-Basic/"},{"title":"DeepLearning-1 ConvolutionNetwork","text":"IntroductionConvolution neural network has been applied to different domains widely for feature extractor / filter. One of the most successful area is computer vision, in which convolution network is trained and used to extract the general feature we are interested in. This article summarizes how forward passing and backpropagation works in CNN to train the CNN filters. Then some properties of CNN are mentioned. Terms in CNN N: number of data points/ samples in dataset C: number of channel in one sample. Example: in RGB image, it has 3 channels: Red, Green, Blue H: height of one data point matrix / amount of rows in one sample W: width / amount of columns in one sample x: input with shape (N, C, H, W) y: output of convolution network kernel/filter/weight: filter with trainable weights and shape of (KH, KW), where KH: height / rows of kernel, KW: width/ columns of kernel b: bias term. One kernel correponds to one bias stride: The number of pixel between adjacent receptive fields in horizonal, vertical directions. padding: the number of rows, columns added to the boundaries/edges of a sample matrix. Usually, we set the padding row/column values to zeros. We usually set padding = (1,1) or (2,2) to add 1 or 2 row(s)/column(s) to each edge of sample matrix Ho: height/ amount of rows of output fromm convolution Wo: width/ amount of columns of output from convolution Output shape from convolution network: Ho = 1 + (H + 2*padding - KH )/stride Wo = 1 + (W + 2*padding - KW )/stride if Ho, Wo are not integer, that means when moving the kernel along input, index out of range occurs. In this case, we can simply drop the last column/row that make index out of range. Or, we can add zero columns/rows to fill the out of range pieces in matrix. How does CNN workForward pass in CNN Convolution with 1-D Input: without padding, stride =1, channel =1After we define some terms above, let consider there is 1-D input X with shape: C=1, H=1, W=4 and 1-D kernel K with shape KH=1, KW = 3.$$X = [x1, x2, x3, x4], K = [w1, w2,w3]$$ Then the output of convolution is$$Y = \\begin{bmatrix}y_1 \\\\y_2\\end{bmatrix}$$ where $y_1 = w_1 * x_1 + w_2 * x_2 + w_3 * x_3 +b$ and $y_2 = w_1 * x_2 + w_2 * x_3 + w_3 * x_4 +b$ where b is the bias term in convolution Convolution with 2-D Input: stride =1, no padding, channel =1$$X = \\begin{bmatrix}x1 &amp; x2 &amp; x3 \\\\x4 &amp; x5 &amp; x6 \\\\x7 &amp; x8 &amp; x9\\end{bmatrix} ,K = \\begin{bmatrix}w1 &amp; w2 \\\\w3 &amp; w4\\end{bmatrix}$$ Based on these equations, Ho = 1 + (H + 2*padding - KH )/stride Wo = 1 + (W + 2*padding - KW )/stride we know that the output Y has shape H =2, W= 2: $$Y = \\begin{bmatrix}y1 &amp; y2 \\\\y3 &amp; y4\\end{bmatrix}$$ $$y1 = sum( \\begin{bmatrix}x1 &amp; x2 \\\\x4 &amp; x5\\end{bmatrix} * \\begin{bmatrix}w1 &amp; w2 \\\\w3 &amp; w4\\end{bmatrix} ) +b = w1x1 + w2x2 + w3x4 + w4x5 + b$$ where * is element-wise multiplicationSimilarly, we have $$\\begin{matrix}y2 = w1x2 + w2x3 + w3x5 + w4x6 + b, \\\\y3 = w1x4 + w2x5 + w3x7 + w4x8 + b, \\\\y4 = w1x5 + w2x6 + w3x8 + w4x9 + b \\\\\\end{matrix}$$ Convolution with 2-D Input: with padding = (1,1) stride =1, channel =1Here I add 1 row, 1 column zeros pad to four edges of 2-D matrix. Then the sample X becomes 4 by 4 matrix. After padding, we will do the same forward pass process as step 2. $$X = \\begin{bmatrix}0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\0 &amp; x1 &amp; x2 &amp; x3 &amp; 0 \\\\0 &amp; x4 &amp; x5 &amp; x6 &amp; 0 \\\\0 &amp; x7 &amp; x8 &amp; x9 &amp; 0 \\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{bmatrix}$$ and$$K = \\begin{bmatrix}w1 &amp; w2 &amp; w3 \\\\w4 &amp; w5 &amp; w6 \\\\w7 &amp; w8 &amp; w9 \\\\\\end{bmatrix}$$ The output Y becomes:$$Y = \\begin{bmatrix}y1 &amp; y2 &amp; y3 \\\\y4 &amp; y5 &amp; y6 \\\\y7 &amp; y8 &amp; y9 \\\\\\end{bmatrix}$$ where$$y1 = w_1 * 0 + w_2 * 0 + w_3 * 0 + w_4 * 0 + w_5 * x_1 + w_6 * x_2 + w_7 * 0 +w_8 * x_4 + w_9 * x_5$$ Let denote the $i^{th}$ row and $j^{th}$ column entry in output Y as $y_{i,j}$, the $h^{th}$ row and $w^{th}$ column entry in kernel K as $w_{h,w}$, the number of stride as $s$. We can write down the formula to compute every entry in output Y:$$y_{i,j} = \\sum_{h=1}^{KH}\\sum_{w = 1}^{KW} w_{h,w} * x_{s * i+h-1, s * j+w -1}$$ Convolution with 2-D Input: with channel =3, padding = (1,1) stride =1when channel of sample X is more than 1, we will need the amount of kernels K equal to the number of input channel $C_{in}$.Example: Input X with Channel C=3$$X_R = \\begin{bmatrix}xr1 &amp; xr2 &amp; xr3 \\\\xr4 &amp; xr5 &amp; xr6 \\\\xr7 &amp; xr8 &amp; xr9\\end{bmatrix}$$ $$X_G = \\begin{bmatrix}xg1 &amp; xg2 &amp; xg3 \\\\xg4 &amp; xg5 &amp; xg6 \\\\xg7 &amp; xg8 &amp; xg9\\end{bmatrix}$$ $$X_B = \\begin{bmatrix}xb1 &amp; xb2 &amp; xb3 \\\\xb4 &amp; xb5 &amp; xb6 \\\\xb7 &amp; xb8 &amp; xb9\\end{bmatrix}$$ Then we will need one kernel for each input channel. Hence we will have 3 kernels $K_R, K_G,K_B$. The output of this convolution network is the sum of all convolution output$$Y = conv(X_R, K_R) + conv(X_G, K_G) + conv(X_B, K_B)$$ In this cases, the output channel is still C= 1. If we want the output channel to be more than 1. Let say the output channel $C_{out}$ =3, then we have $C_{out} * C_{in}$ kernels in total and each kernel has shape of $W_o * H_o$. Hence we will have parameters with amount of $C_{out} * C_{in} * W_o * H_o$ or $C_{out} * C_{in} * (1 + (H + 2 * pad - KH) / stride ) * (1 + (W + 2 * pad - KW) / stride )$ Chain RuleBefore talking about how to update the weight in kernel, let talk about the chain rule first.Denote loss function as $L(y_p, y_t)$, where $y_p$ is prediction / output from estimator and $y_p =f_w(x)$ is a function of input x, $y_t$ is target, where x, y,w are all scalar values Let: $y_p = f_w(x) =wx$$$L(w) = L(y_p, y_{t}) = (y_p - y_{t})^2 = (f_w(x) - y_{t})^2 = (wx - y_{t})^2$$ Then in chain rule to find the gradient of weight w, we have$$\\nabla_w L(w) = \\frac{dL(w)}{dw} = \\frac{dL}{dy_p} * \\frac{dy_p}{dw} = [2 *(y_p - y_t)] * [x] = 2x(wx - y_t)$$ By chain rule, we can extend $ \\frac{dL}{dy_p} * \\frac{dy_p}{dw}$ to $\\frac{dL}{dy_p} * \\frac{dy_p}{dy_1} * \\frac{dy_1}{dy_2} *â€¦\\frac{dy_i}{dw}$ in many terms Backpropagation in CNNLetâ€™s go back the feed forward step in CNN, we have equation$$y_{i,j} =f_w(x) = \\sum_{h=1}^{KH}\\sum_{w = 1}^{KW} w_{h,w} * x_{s * i+h-1, s * j+w -1}$$ Where the output vector of convolution is $Y$ and $y_{i,j}$ is the $i^{th}$ row and $j^{th}$ column entry of Y. $Y^t$ is the target. $x_{i,j}$ is the $i^{th}$ row and $j^{th}$ column entry of input X. Define loss function $L(w)$ . Then gradient of weight $w_{h,w}$ in kernel is obtained by$$\\frac{dL(w)}{dw_{h,w}} = \\sum_{i=1}^{H}\\sum_{j=1}^{W}\\frac{dL}{dy_{i,j}} * \\frac{dy_{i,j}}{dw_{h,w}}$$ Example: $$X = \\begin{bmatrix}x_{11} &amp; x_{12} &amp; x_{13} \\\\x_{21} &amp; x_{22} &amp; x_{23} \\\\x_{31} &amp; x_{32} &amp; x_{33}\\end{bmatrix} , K = \\begin{bmatrix}w_{11} &amp; w_{12} \\\\w_{21} &amp; w_{22}\\end{bmatrix}$$ $$Y = \\begin{bmatrix}y_{11} &amp; y_{12} \\\\y_{21} &amp; y_{22}\\end{bmatrix}$$ Let Loss function be $L(w) = 0.5* \\sum_i\\sum_j (y_{i,j} - y^{t}_{i,j})^2$and we have $$\\frac{dL}{dy_{i,j}} = (y_{i,j} - y^{t}_{i,j})$$ $$\\frac{dL}{dy} = \\begin{bmatrix}\\frac{dL}{dy_{11}} &amp; \\frac{dL}{dy_{12}} \\\\\\frac{dL}{dy_{21}} &amp; \\frac{dL}{dy_{22}}\\end{bmatrix}$$ $$\\frac{dy_{11}}{dw_{11}} = \\frac{d(w_{11} * x_{11} + w_{12} * x_{12} + w_{21} * x_{21} + w_{22} * x_{22} +b)}{dw_{11}}$$ $$\\frac{dy_{11}}{dw_{11}} = x_{11}$$ Similarly, we have $$\\frac{dy}{dw_{11}} = \\begin{bmatrix}\\frac{dy_{11}}{dw_{11}} &amp; \\frac{ddy_{12}}{dw_{11}} \\\\\\frac{ddy_{21}}{dw_{11}} &amp; \\frac{ddy_{22}}{dw_{11}}\\end{bmatrix} = \\begin{bmatrix}x_{11} &amp; x_{12} \\\\x_{21} &amp; x_{22}\\end{bmatrix}$$ Finally, gradient of weight $w_{11}$ becomes$$\\frac{dL}{dw_{11}} = sum(\\frac{dL}{dy} * \\frac{dy}{dw_{11}} ) = \\sum_{i=1}^{2}\\sum_{j=1}^{2}\\frac{dL}{dy_{i,j}} * \\frac{dy_{i,j}}{dw_{1,1}}$$ $$\\frac{dL}{dw_{11}} = \\sum_{i=1}^{2}\\sum_{j=1}^{2} (y_{i,j}-y^t_{i,j})*x_{i,j}$$ where * is element-wise multiplication Repeat doing this, we can find the gradient for all weights in all kernels. Properties in CNN the weight matrix in CNN is small and save memory compared with traditional dense network.For example, if we have an 1818 input matrix we want to output a 3x3 matrix, we can either use a 16x16 convolution kernel with stride =1, or 9 3x3 kernels to do this.In this case, 933 is smaller than 1616. Hence CNN with deeper convolution network and small filter can save memory Updating weights in CNN is fast, as the weight / kernel is small CNN can be used for transfer learning by transferring learned kernels CNN can be used for down-sampling data, reducing data size.For example, in ResNet, it uses pixel convolution: kernel size =1 * 1 and stride =2 to down sample data by half of original size in each channel of matrix Reference[1] https://towardsdatascience.com/backpropagation-in-a-convolutional-layer-24c8d64d8509 [2] https://arxiv.org/pdf/1512.03385.pdf","link":"/2020/11/02/DL-ConvolutionNetwork/"},{"title":"Some Useful Linux-commands","text":"Here is some useful linux commands du -h file check the file size pwd show the current directory location locate file find the file name alias name=â€â€¦â€ alias some commands tar -xzvf file.tar.gz -x extract file, -v show extraction process, -f output to given file name, -z using gzip or unzip to extract gz format cat /proc/cpuinfo display information of cpus nvidia-smi -L list the gpus. need to install nvidia first diff a b show difference between a and b files chmod ugo file-nameugo is a oct number used to set the access mode of the file, indicating r (read), w (write), x (executive) mode of the file to different groups of users.For example if ugo = 666, then it means user, group and other groups can read, write the file, but can not execute the file. 12345678910111213permission to: user(u) group(g) other(o) /Â¯Â¯Â¯\\ /Â¯Â¯Â¯\\ /Â¯Â¯Â¯\\octal: 6 6 6binary: 1 1 0 1 1 0 1 1 0what to permit: r w x r w x r w xbinary - 1: enabled, 0: disabledwhat to permit - r: read, w: write, x: executepermission to - user: the owner that create the file/folder group: the users from group that owner is member other: all other users Palmetto Commands: Need to be in login node (name node), not computing node or shell in jupyter Hub checkquota: check my disk space quota module avail : list available packages qstat -xf jobid: check the status of job with id: jobid qstat -Qf queuename : check status of a queue References[1] https://www.runoob.com/linux/linux-comm-tar.html","link":"/2020/11/12/Linux-commands/"},{"title":"Cpp review 1","text":"Important Keywords const Type Meaning Explanation const int x constant variable Value of x must be initialized first const int *x constant content; mutable pointer; d constant content pointer x points to. address of pointer x is mutable. x can be initialized after defintion int * const x constant pointer; mutable content; pointer x must be initialized first; const int* const x Constant pointer; Constant content x must be initialized first const Class a constant class var content of member var of a can not be changed; can not call not-constant functions;(avoid changing member values) void func(const int x) const var as input function can not change the local variable; const int&amp; funct(x) return constant reference pointer using this reference can not change its content const int funct(x) return constant var return a constant variable int func() const constant member function Function is unable to change member values in the class const MyClass c constant Class variable variable c can not call non-const member function and c can not change member variable values define Macro preprocesing keyword. Different from const, #define doesnâ€™t have data type Compiler replaces the words only without checking the variable and its memory. E.g #define A B. Replace A with B only, compiler doesnâ€™t check the type of A. In C++ program, usually use const rather than define for security. sizeof(x) / sizeof x check number of bytes of variable based on data type sizeof class_variable = sum of bytes of all member variables in class in 64-bit machine, sizeof pointer = 8 bytes = 64 bits static static global var only visiable to current file data is stored in global memory, whereas local var is stored in stack and heap. Automatically initialized as 0 Eg: 12static int a;int main(){...} static local var It is initialized once stored in global memory without releasing memory until program terminates can be used in local code block only. static function visible to current file only can be defined in public, protected, private region. static class member: used for private class info, rather than instance info Different from common private member (which can be called and modified via this pointer), static class member DO NOT have this pointer Only private and protected member can define static. Public member can not define static.However, static function can be defined in public region as well. Can be called only by private/protected class function Initialization for static member inside class requires const definition Initialization for static member outside class requires that it can be initialized once. Initialization must be outside code block, like global variable Example code: 12345678910111213class myclass{ public: void func(){cout&lt;&lt;b;} // call private var inside member function private: static int a; //or static const int a =0; static int a=0;//wrong, a must be const static int b;}int myclass::b = 10; // way to initialize staic class member, like global var, but won't conflict global var.int main(){...} external Tell the compiler that there is an function, whose implement of function is in other file. inline inline function tell the compiler to embed the code of the function into every place where the function is called. So, inline function reduce the time used to expand the function by using more memory. Normal function in C/C++ is expanded by compiler only when they are call. This requires longer time to run program Inline function has higher memory complexity and lower time complexity than normal function Not suitable for construtor function (since it will generate lots of codes ) Not suitable for virtual function inline function is unable to use render/loop operation Note: Inline function doesnâ€™t support loop and switch Usually, inline function is used when function has a few codes. (usually less than 10 lines) typedef and #define It is a sentence not command for compiler, so it requires â€œ;â€ compared with #define Compiler check the grammar and type of typedef, but doesnâ€™t check type of #define #define simply replaces the notation with new one, it doesnâ€™t check the grammar or operation in definition Example: 123typdef struct A{...} B; //define A as type B#define A B // define / replace B with A#define func(x) x*x explicit Require constructor to run explictlyEg:1234567c = myclass(1);//orc= (myclass) 12; // convert type explictlymyclass c;c = 1; // Not allowed, need (myclass) 1 Using Declaration of â€œusingâ€ keyword: It indicates the class we use is from std library. Example: 1using std::vector; It indicates the class vector is from std Compile command: It tells the compiler to use the whole namespace (every element from this namespace) Example: 1using namespace std; Variable type global local static Operators Operator computes from right to left: &lt;condition-expression&gt; ? &lt;return if condition=__True__&gt; : &lt;return if condition =__False__&gt;It returns value from right to left = Operator Priority arithmetic operator: *, % , / are higher than +, - Relationship operator: &gt;, &lt; , &gt;=ï¼Œ&lt;= are higher than !=, == logic operator: ! higher than &amp;&amp;, &amp;&amp; higher than || logic bit operator: ~ higher than &amp;, &amp; higher than | Grammar a++ and ++a a++: return another local variable contain value of a. Then a=a+1 ++a: a=a+1 and then return a. Speed: a++ &gt; a+=1 &gt; a=a+1. Switch input must be one of char,short, int 123456switch(a):{ case x1: ....; break; case x2:....; break; default: ....; break} Pointer and reference Pointer Reference Pointer is a variable Reference is an essentially implicit pointer or the representation of the address of a memory piece Pointer can be empty or uninitialized; Reference requires variable to be initialized before using reference. nullptr virtual pointer Pointer and Array Array Pointer: the pointer pointing to the address of an array Array Name: array name is not a pointer, but just return the address of the array (address of the first element) Pointer for array element: 123int arr[] = {1,2,3,4,5};int *p = arrcout&lt;&lt;*p++; *p++ : return element *p, then p++ ++*p: (*p) element +1 and then return. Without changing the address pointer p pointing to Array Pointer 123int arr[] = {1,2,3,4,5};size =5;int (*p)[size] = &amp;arr; (*p)[size] : array pointer, pointing to array NOT element size of (*p)[size] must be number of element in arr p++: address skip the whole array size (5 * 4 byteshere), not element size (*p)[0]: return arr[0] Wild Pointer(é‡æŒ‡é’ˆ) pointer that has not been initialized before using Dangling Pointer(æ‚¬ç©ºæŒ‡é’ˆ) pointer that point to invalid memory address (after memory released) Macro and PreprocesssorDifference between Class and StructureObject-Oriented DesignBasic Features of OOD in C++ Three Traits Encapsulation(å°è£…æ€§)A mechanism of bundling the data, and the functions that use them and data abstraction is a mechanism of exposing only the interfaces and hiding the implementation details from the user Polymorphism(å¤šæ€)Different classes inherent from the same parent class can have different methods, class members. It diversifies features of classes. Polymorphims in C++ is achieved by using virtual keyword. Inheritance(ç»§æ‰¿)The members of the base class become members of thederived class. It helps save our time and avoid re-writing the same codes. Publich, Protected, private Properties Private Protected Public Accessibility only Base Class member/method only Base Class and Child Class member/method Any instance and Class member Inheritance Properties: Private Inheritance: Base Classâ€™s private members wonâ€™t be inherited by Child Class Base Classâ€™s public and protected members will be converted to be private in Child Class Protected Inheritance: Base Classâ€™s private members wonâ€™t be inherited by Child Class Base Classâ€™s protected, public members wil become protected in Child Class, Base Classâ€™s members can not be accessed by Child Class of Base Classâ€™s Child Class. Public Inheritance: Base Classâ€™s private members wonâ€™t be inherited by Child Class Base Classâ€™s protected, public members donâ€™t change (Still protected, or public) Types of overloading overloading the amount of parameter Example 12345Class A{ publich: void func(int a) {} void func(int a, int b) {}} overloading the data types of parameter Example 12345Class A{ publich: void func(int a) {} char func(char a) {}} overloading of const and non-const methods 123456Class A{ publich: void func(int a) {} // the const method can not change class member values void func(int a) const {}} overloading of Operators Example: 1234Class A{publich: int operator + (const int a, const int b) {}} Operators that can not be overloaded: :: , pointer operator . *, condition operator ?: , sizeof, typeof const_cast static_cast dynamic_cast reinterpret_cast Methods that can not be inherent Constructor Deconstructor Friend method Operators Methods that can be inherited static functions non-static functions non-static members (Note: static members must be private or protected that are usually unable to be inherent) Virtual function (used for polymorphism) Interface and Virtual class, method and pointer Pure virtual functionit is applied by using virtual keyword and =0 behind the function. 1234class A{ public: virtual int func(int x) =0;} Abstract ClassAbstract class provide an appropriate base class from which other classes can inheritAn abstract class must contain at least one pure virtual function InterfaceInterface describes the behavior a class without a particular implementation of that class.Interface in C++ is implemented by using Abstract class. Virtual Function and PolymorphismA Child of base class can overload the virtual function and give particular implement of the function to achieve polymorphism Virtual Function mechanism: using virtual pointer and virtual table In base class with virtual function, Compiler creates an virtual pointer vptr and a virtual table vtbl vptr points to the address of vtbl to write and store the addresses of all virtual functions in this base class. The pointer vptr is stored at the beginning of the memory of the base class. (the first element of the Class is vptr ) Example: For class A and Class B, each of them have virtual pointer __vptr__ pointing to a virtual table, which stores addresses of virtual functions. In addition, the virtual pointer of each class is stored at the beginning of the class. 4. In __single inheritance__ (a class is allowed to inherit only one class), child class will inherit the vptr from base class, but __create a new vtbl table to store addresses of new virtual functions and inherited/overrided virtual functions__ 5. In __multiple inheritance__: + child class inherits multiple vptr, then creates multiple vtbls, in which each vtbl corresponds to each base class (Hence __the number of vtbl = number of base class inherited__). + __All addresses of new virtual functions will be stored at the end of the first vtbls__ Template and Generic Function A generic function defines a general set of operations that will be applied to various types of data. Memory allocation and Types of memory new and malloc new malloc A keyword a function it calls the operator operator new() -&gt; malloc()-&gt; then call constructor in class directly allocate memory without using constructor return class pointer return void pointer can be overloading can not be overloading No need to tell size of memory Need to tell size of memory delete and free delete free A keyword a function it calls the operator operator delete() -&gt; free()-&gt; then call deconstructor in class directly free memory without using constructor return class pointer return void pointer can be overloading can not be overloading No need to check if memory exists Need to check memory first create and delete Class array 123456int size=10;ClassA* a = new ClassA[size]delete[] a; // input is an array of int class int ClassA::func(int[] a){....} malloc, calloc, realloc and alloca malloc: allocate memory without initialization calloc: allocate memory and initialize them to zero realloc: extend the memory with bigger size than before. alloca: allocate tempory memory on stack on local scope. Memory will be released outside the scope. Hence no need to use free() link and compile in C++ Dynamic Link Static Link Regular Expression (re)STL containerReference[1] https://www.tutorialspoint.com/cplusplus/cpp_overloadinging.htm [2] https://blog.csdn.net/csdn_chai/article/details/78041050","link":"/2021/03/08/Cpp-review/"},{"title":"Model Evaluation and Selection","text":"IntroductionIn order to do something better in our study, our jobs or even our life, evaluation step is an indispensable part of improvement. Otherwise, How do we know our work is good or bad? In addition, â€œgoodâ€ and â€œbadâ€ are ambiguous terms if we donâ€™t have any evaluation methods. Similarly, in machine learning, in order to training a â€œbetterâ€ model, we need concrete evaluation metrics to tell us if our models perform well, so that we can choose the best one. The goal of this passage is to conclude the common useful ways to evaluate and improve our machine learning models. My Thoughts are also provided. Evaluation Metrics Confusion MatrixIn classification task, we have predictions from our model on the test set and ground truth labels/targets indicating the real class of each sample in dataset.Let consider we are predicting if data belongs to class â€œCâ€ or not. Then Confusion matrix is Actual class\\prediction C not C sum C TP FN actual P= TP+FN Not C FP TN actual N = FP+TN sum predicted Pâ€™ = TP+FP predicted Nâ€™ = FN+TN All True positive (TP): the amount of samples that are predicted as class â€œCâ€ and they actually belong to class â€œCâ€. False positive (FP): the amount of samples that are predicted as class â€œCâ€ and they actually DONâ€™T belong to class â€œCâ€. False Negative (FN): the amount of samples that are predicted as Not class â€œCâ€ and they actually belong to class â€œCâ€. True Negative (TN): the amount of samples that are predicted as not class â€œCâ€ and they actually donâ€™t belong to class â€œCâ€. Accuracy:measure how accurate the predictions are $acc = \\frac{TP+TN}{TP+TN+FP+FN}$ Error Rate: 1-acc Sensitivity/Recall: (Precentage of correct positive prediction on Actual positive )Recognition rate on True positive:$sens = \\frac{TP}{predicted Pâ€™} = \\frac{TP}{TP+FN}$ Specificity:(Precentage of correct negative prediction on Actual negative )How many positive predictions in true data are recognized by model?Recognition rate on True Negative: $spec = \\frac{TN}{predicted Nâ€™} = \\frac{TN}{TN+FP}$ Precision: (Percentage of correct positive prediction on all positive prediction) Measure what % of tuples that the classifier labeled as positive are actually positive How many positive predictions of your model are correct? $precision = \\frac{TP}{predicted Pâ€™} = \\frac{TP}{TP+FP}$ __F-score: $F_\\beta$__: It weighs precision and recall $$ F_\\beta = \\frac{(1+\\beta^2) * precision*recall}{\\beta^2 * precision+recall}$$ $\\beta$ controls the weight of precision. Higher $\\beta$ weigh more to precision than recall and hence precision is given more attention. F-1 score ($\\beta =1$): $$ F_1 = \\frac{2 * precision * recall}{precision+recall}$$ Both precision and recall are given equal weights. When to use Recall, Sensitivity and F-1 to evaluate model? Sensitivity/Recall:When we want the model to be more sensitive to positive cases and would like to predict more False Positive than False Negative.Example:In disease detection, we would like to use recall more than precision, since we want to detect disease and cure earily, we only care if we get disease or not (Positive or not)Cybersecurity, fault detection. We care if fault occurs/ prediction is positive or not only. Even if more FP than FN are in prediction, it help us reduce the possibility of missing faults (FN) Precision:when we care real positive cases, or both FN and TP. That is, we donâ€™t want the model to predict more FP than FN. False negative also matters.Example:Spam detection: when mailbox detects a spam, it will directly delete/remove that email. However, if that email is actually not a spam (False positive), but an important email, then deleting it leads to an unexpected result.In this case, we want to reduce the false positive cases to avoid deleting an important email. Hence, we donâ€™t use FP, but use FN and precision instead. F-Score:when we care both precision and recall, but want to weigh them.This depends on the assumption in the real cases. If the real case assumes both precision and recall are important, then we use F-score. Score used for GAN:Inception Score, FID. For more details, Please read this article Estimation of Model Accuracy Holdout The purpose of holdout is to evaluate how well the model performs on the unseen dataset. It is used to evaluate the both the framework of model and the hyperparameters of model Process: Split dataset into two independent datasets randomly: training set (usually 80%) and test set (usually 20%) Train the initial model with training set and then test model with test set Repeat steps 1~2 k times and calculate average accuracy of the k accuracies obtained Note: The test sets in k iterations may be repeated Accuracy of model could be unstable due to the split method on dataset.For example, if after randomly spliting dataset into training set and test set, all samples belonging to class â€œCâ€ are in test set, then model can not learn features from class â€œCâ€ and hence perform worse. Otherwise, it could perform better if it learn features from class â€œCâ€ from training set. Cross Validation The purpose of Cross Validation is to evaluate the framework of the model, rather than how good the hyper parameters of the model is. K-fold 1. Split the training set into k-subsets: {D1, D2,..Dk} with (almost) equal size. 2. Loop through k iterations. At $i^th$ iteration, select subset Di as validation set and the remaining k-1 subsets as training set. 3. Compute accuracy of each iteration 4. Compute the mean of accuracies obtained in k iterations. Leave One out It is a case of k-fold cross validation with setting K= N, the number of data point in training set. It hence takes N-1 iterations to evaluate model. Stratified Cross validation It is a case of K-fold cross validation with each setting: each set contains approximately the same percentage of samples of each target class as the complete set. __For example:__ In a dataset S= {A1,A2,A3,B1,B2,B3,C1,C2,C3}, which has classes A,B,C. Each class occupies 30% of total dataset.In Stratified 3-fold Cross-validation, S= {K1,K2,K3}. To make each class of data in each fold have the same percentage, we have: K1 ={A1,B1,C1}, K2 ={A2,B2,C2}, K3 ={A3,B3,C3} such that the percentage of each class of sample in each fold is still 30%. Note for Cross-Validation When K is small, the variance in performance of model could be large, since each fold contains more data and hence becomes noisy. When K is large, eg. in LeaveOneOut, K=N, variance of performance of model would be smaller. In each fold of training set, we need to start training the initial model again, rather than training the model from the last fold. Cross validation is to evaluate the performance of the framework of the model, rather than of the parameters of the model. Bootstrap (Sample-based) Samples the given training tuples uniformly with replacement d times as training set. The remaining data tuples form the test set (or validation set).That is,the tuples/samples that have been chosen can still be chosen with equal possibility Train model with training set Compute average accuracy of model on both training set and test set Repeat steps 1~3 k times, then compute average accuracy of all accuracy obtained in k iterations. Comparison among methods Above holdout Purpose Holdout is mainly used to evaluate how well the model performs on the unseen dataset. It evaluates both framework and hyperparameter of the model. Different from cross-validation, the holdout data can be any size (usually 20% of the training dataset), while cross-validation requires validation data has the same size as each fold. When the amount of fold is small (like 2) in cross-validation, it could waste the training set. Advantages Less expensive in computation, Easy to compute, compared with cross-validation, since it splits test set randomly Disadvantages Estimated accuracy may be unstable (Accuracy is easy to change), since holdout depends on the dataset split methods on training set and test set. When to Use When the dataset is very large and hard to compute multiple subset Cross-validation Advantages The estimated accuracy is much stable than holdout , since it trains model on multiple different train-test set splits. It guarantees to train model with all samples. Disadvantages The Cost for computation is expensive when dataset is very large. When value K is smaller, the variance in performance of model will be larger and model is easier to overfit (training with more data samples could be more noisy). When value K is smaller, it could waste the training set. For example, in 2-fold, we use only half of training set to train the model, which is a waste of training data. When to Use when dataset is not very large (10000 samples or even more) when you have powerful computational device. Bootstrap Advantages Performance of model doesnâ€™t depend on the split method on dataset When dataset is small or insufficient, or imbalanced (some classes are more than other significantly), it may reduce overfitting effect by sampling with replacement Less expensive on computation compared with cross validation Disadvantages Need to determine what sampling method to use When to Use when dataset is small or insufficient (In this case, we may use Over-sampling to repeat some data) when dataset is imbalanced when dataset is pretty large (In this case, we may use down-sampling to select part of data for training) Comparison of performances among different modelHow do we know the performances between models are similar? t-Test / Studentâ€™s t test Read this paper Model Selection ROC curve: receiver operating charatistic curve (true positive rate -VS- False positive rate)we first let model output possibility of each class and then set the threshold to convert possibility to 0, 1 binary classification labels.The threshold is usually default as 0.5.Based on the binary classification, compute true positive rate TPR/recall (TP/(TP+FN)) and false positive rate/FPR (FP/(FP+TN) = FP/real negative)Since threshold is set to 0.5, during training of model, the performance of model will change and hence TPR and FPR will change.The changing TPR and FPR leads to the ROC curve AUC: area under curve ( ROC curve)Since TPR and FPR range from 0 to 1, hence AUC has range [0, 1]. AUC usually is inside [0.5, 1] because a good model usually can classify sample correctly with 0.5 possibility. Physical Meaning of AUC:AUC is the possibility that a random-chosen positive sample is ranked more highly than a randomly-chosen negative sample.In other words, AUC is the possibility that a modelâ€™s prediction possibility of a random positive sample is more higher than a random negative sample. Then when AUC of a model is larger, it is more likely for the model to predict positive sample as 1 , rather than negative sample as 1. Example: when threshold =0.5 Case 1 Sample A B C D Possibility 0.9 0.8 0.51 0.3 Prediction 1 1 1 0 Ground Truth 1 1 0 0 In case 1 we see that possibility that positive sample is ranked higher than negative sample, since all positive sample has possibility greater than negative sample and TPR = 2/2=1 as FPR = 1/2 =0.5 &lt; TPR. Hence in this case, it is a good model. Case 2 Sample A B C D Possibility 0.9 0.3 0.51 0.6 Prediction 1 0 1 1 Ground Truth 1 1 0 0 In case 2, we see that TPR = 1/2 &lt; FPR= 2/2=1 and AUC is small. The possibility that positive sample ranked higher than negative sample is small. The prediction possibilty of positive sample is also small than negative sample in sample B,D. Hence the model performance is not good enough. Improvement on Accuracy: Ensembling method Bagging (bootstrap aggregation) Main Idea:Its goal is to reduce variance by using multiple classifiers, like decision tree. It uses boostrap method to sample data and train multiple classifiers and then average the prediction over a collection of classifiers (for continuous value prediction, regression), or return the prediction with maximum votes (forclassification)Random forest is a bagging approach, which bags a set of decision trees together. Assumptions we have training set with size of D and a set of models with size of K Training: Similar to Bootstrap, at each iteration i, a training set Di of d tuples is sampled with replacement from training set. A classifier model Mi is learned for each training set Di Prediction: Each Classifier Mi returns prediction for input X. Discrete value output: The bagged classifier counts the votes and assigns the class with the most votes to X Continous value output:take the average value of each prediction for a given test sample. Advantages: Better than a single classifier from the classifier set. More robust in noisy data and hence smaller variance Disadvantages: 1.Its training depends on sampling techniques, which could affect the accuracy The prediction may be not precise, since it uses average value of classifiersâ€™ predictions.For example, if valid prediction values are 1,2,or 3, then the average of predictions from different model could lead to a floating point number. Properties of Random Forest Comparable in accuracy to Adaboost, but more robust to errors and outliers. Insensitive to the number of attributes selected for consideration at each split, and faster than boosting Boosting Main Idea:Its goal is to improve accuracy, let models better fit training set. It uses weighted votes from a collection of classifiers Training: Each training sample/tuple is given a weight, eg $w_i$ for the $i^{th}$ tuple. Then we have training set {(X0,y0, w0), â€¦ ,(Xi,yi, wi)}where $X_i$ and $y_i$ are training sample and target We have k classifiers {M0, M1,â€¦Mk}. Each classifier is learned from the whole training set iteratively. That is, if we have k classifiers, then we need to iterate the training set at least k times (at $i^{th}$ iteration, we train the $i^{th}$ classifier), so that each classifier can learn the training set. After classifier $M_i$ is learned on training set, classifier $M_{i+1}$ paies more attention to the training samples that are misclassified by $M_i$ Prediction: The final Model combines the votes of each individual classifier. Either find the prediction with largest sum of weights (Classification), or find the average of all prediction values (Regression) The weight of each classifierâ€™s vote is a function of its accuracy Advantages Boosting can be extended to numeric prediction Better fit the training set since it adjusts the weights of training set and gives more attention to the misclassified sample. Disadvantages Easy to overfit. Need Additional techniques to avoid overfitting. (I will discuss the methods dealing with Overfitting ). Questions: How to pay more attention to misclassified samples? give Higher weights? But How to compute weights?Answer: This depends on the actual boosting algorithm, like GradientBoosting, AdaBoosting AdaBoosting Assumption:Assume we have training set with size of D and a set of classifier models with size of T __Error of model $M_i$__ Error($M_i$) = $\\sum_i^D (w_i \\times err(X_i))$ if using normalized weight (weight in range [0,1]), then Error($M_i$) = $\\frac{\\sum_i^D (w_i \\times err(X_i))}{(\\sum_j^D w_j)} $ Note: In classification, $err(X_i)= 1(C_i(X_i) !=Y_i)$, $C_i(X_I)$ means the prediction of model $M_i$ on sample $X_i$. If the prediction is correction $error(X_i) =0$, otherwise 1. Weight of model $M_i$â€™s voting: $\\alpha_i$ $\\alpha_i = log\\frac{1-error(M_i)}{error(M_i)} + log(K-1)$. Note: K = the number of classes in dataset. When K=1, log(K-1) term can be ignored Update of weight $w_i = w_i \\cdot exp(\\alpha_i \\cdot 1(M_j(X_i) != Y_i))$ The weight $w_i$ of the $i^{th}$ training tuple $X_i$ is updated by timing exponential value of weight of model only when this model $M_j$ misclassifies the $X_i$ ( That is $M_j(X_i) !=Y_i$ and hence $1(M_j(X_i) !=Y_i) =1 $). Prediction $C(X_i) = argmax_{k} \\sum_{j=1}^T \\alpha_{m}\\cdot 1(M_j(X_i)== Y_i)$ where $1(M_j(X_i)== Y_i)$ is equal to 1 if prediction is correct, otherwise, 0. The prediction of the whole model has the largest sum of weight of models, NOT the weight of training tuple! More detail for AdaBoosting, Read this paper Stacking Main Idea:It combines and trains a set of heterogeneous classifiers in parallel.It consists of 2-level models:level-0: base modelModels fit on the training data and whose predictions are compiled.level-1: Meta-ModelIt learns how to best combine the predictions of the base models. Training: split the training data into K-folds one of base models is fitted on the K-1 parts and predictions are made for Kth part. Repeat step 2 for each fold Fit the base model on the whole train data set to calculate its performance on the test set. repeat step 2~4 for each base model Predictions from the train set are used as features for the second level model. Classification: Second level model is used to make a prediction on the test set. Advantage: It harness the capabilities of a range of well-performing models on a classification or regression task and make predictions that have better performance than any single model in the ensemble. Disadvantage: It could be computational expensive since it uses k-fold method and use multiple level models. Comparison among Ensembling, boosting and bagging Goal of bagging is to reduce variance and noise while boosting is to improve accuracy using weighted models. Stacking is to improve accuracy of model using hetergenerous models. Adaboost let classifiers pay more attention to the misclassified samples, but if those misclassified samples are outlier or noisy data, it will affect a lot and lead to larger variance.However, bagging and ensemble uses averaging and voting methods and each classifier has equal weight, which is less sensitive to the noise data and outlier. Reference[1] https://blog.csdn.net/weixin_37352167/article/details/85028835[2] https://machinelearningmastery.com/stacking-ensemble-machine-learning-with-python/[3] https://en.wikipedia.org/wiki/Student%27s_t-test[4] https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fnmeth.3945/MediaObjects/41592_2016_Article_BFnmeth3945_Fig1_HTML.jpg","link":"/2020/08/13/Model-Eval-Selection/"},{"title":"ML Model - Regression models","text":"IntroductionThis article is to first introduce types of machine learning models and summarize properties of seven regression models: Linear Regression and Logistic Regression, Lasso Regression, Ridge Regression, Elastic Net Regression and Stepwise regression. Type of machine learning modelParametric/ non-parametric modelsIn general, Machine Learning model can be classified into two types of models based on the critic that if model uses parameters to estimate model or not.In this case, machine learning model can be divided into two types: parametric model and non-parametric model.The following are some useful machine models: parametric: Linear regression, Logistic regression Neural Network non-parametric: K-Nearest neighbor (K-NN) K-Mean Clustering Decision Tree Random Forest Naive Bayesian etcâ€¦Note that the â€œparametricâ€ here is the parameters the model use to estimate the function, distribution. The parameters that control the complexity, performance of model are excluded. For example, K-Mean clustering and K-NN requires us to choose a k value to do clustering/ classification tasks. This k value is not the parameter we consider here. linear/non-linear model Linear modelThe linear model is the model that can be expressed by the formula$yâ€™ = w_0 + w_1x_1 +â€¦.+w_nx_n = w_0+ \\sum_{i}^nw_ix_i$where x is the data point from dataset, $w_i$ is the parameters used to adjust the model and $w_0$ is the bias term. $yâ€™$ is the prediction from the estimator.This formula is linear since it just involves first order terms and linear combination.Note that the real label is$y = \\epsilon + w_0+ \\sum_{i}^nw_ix_i$where $\\epsilon$ is the irreducible error between prediction $yâ€™$ and true label $y$. In the following discussion, I discuss $yâ€™$ prediction from model rather than label $y$. Non-linear modelNon-linear model in other word is the model that can not be expressed by the linear formula above. If there are second order term like $x^2, x^3, x_1x_2$, it is non-linear model as wellHence we can easly know that models like Naive Bayesian, K-NN, K-mean clustering, logistic regression, etc are non-linear models Linear RegressionThe formula of Linear Regression is$$yâ€™ = w_0 + w_1x_1 +â€¦.+w_nx_n $$where $w_0$ is a constant and $yâ€™$ is the prediction from model. To simplify it, we have: $$yâ€™ = \\sum_{i=1}^nw_ix_i + w_0$$Obviously, the linear regression model is a linear model. Optimize Model Maximum Likelihood Estimation (MLE) Assume the data distribution is normal distribution, then the likelihood function used to estimate the real data distribution is: $$P(y=y_i|x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{(y_i-f(x))^2}{2\\sigma}}$$ where f(x) is the linear regression estimator, estimating the mean of normal distribution $\\mu$. Then the weight solution of the regression model is $$W = argmax_w P(Y|X)$$ Loss Function to minimize The loss function used to update the parameter in Linear regression is mean square error (MSE) $$ MSE = \\frac{1}{N}\\sum_i^N{ (y_i - yâ€™_i)^2 }$$ or sum square error (SSE) $$ SSE = \\sum_i^N{ (y_i - yâ€™_i)^2 }$$ where $y_i$ is the $i^{th}$ label and $yâ€™_i$ is the $i^{th}$ prediction from model Properties of MSE/SSE: SSE / MSE error actually assumes that the distribution of data is Normal distribution and the Linear regression model is actually estimating the mean of Normal distribution with a fixed variance $\\sigma$. The negative log likelihood of normal distribution is as follow: $$ -log(\\Pi_i^nP(y=y_i|x_i)) \\ \\propto -log(e^{\\sum_i^n\\frac{-(y_i-f(x_i)^2)}{2\\sigma}}) \\ \\propto \\sum_i^n(y_i-f(x_i))^2 $$ where $y_i$ is the $i^{th}$ label and $x_i$ is the $i^{th}$ feature vector. It is easy to see that maximize the likelihood function is equivalent to minimize the negative log likelihood function or the SSE /MSE. Hence to minimize the MSE error is actually estimating the normal distribution function $P(Y|X)$. Properties Linear regression is an unbias model, which is sensitive to outliers.For example, In the following linear regression There is an outlier at x= 50, y= 30.During update with gradient descent w = w - 2x(y - wx). The outlier value changes the weight a lot and shift the line away from the $y=4x$. This is because in the update of parameter $w$, each data point is given equal weight to change the parameter $w$.Hence linear regression is sensitive to outliers. The output/prediction from linear regression is to estimate the expected value/ mean of normal distribution Logistic RegressionLogistic regression is an non-linear model as it can not be expressed into the linear form.The formula of Logistic Regression model: $$ P(y=y_i|x) = p_i = \\frac{1}{1+e^{-wx}} $$ Optimize Model Maximum Likelihood Estimation (MLE): we want to maximize the log likelihood function (The distribution estimated by the model) to get close to the real distribution function. In binary classification problem, we assume the data distribution is Bernoulli distribution, $ P(y=y_i|x) = p^{y_i}(1-p)^{1-y_i}$ï¼Œ since this distribution considers the possibility of P(y=0|x) and P(y=1|x). Then the log likelihood function / log Bernoulli distribution is following: $$ logP(y_1,y_2,..y_n| x_1, x_2..x_n) =log(P(y_1|x_1)P(y_2|x_2)..P(y_n|x_n))$$ $$ =\\sum_i^n log(p_i^{y_i}(1-p_i)^{1-y_i})= \\sum_i^n[y_ilog(p_i)+(1-y_i)log(1-p_i)]$$ Since we only care the effect of weight vector and data X to the likelihood function, it can be re-written as $$ \\sum_i^n[y_ilog(h_w(x_i))+(1-y_i)log(1-h_w(x_i))]$$ where $x_i, y_i$ are feature vector and binary label, $h_w(x_i) = p_i$ is the logistic regression, estimating the possiibility that if $x_i$ belongs to class 0 or class 1. The log function here is used to simplify the likelihood function and convert the multiplication into summation. This gives us easier way to analyze it. Maximizing the log likelihood is equivalent to maximize the original likelihood function. Notice that when $p_i$ predicted by the model is as same as its label $y_i$, then $p_i^{y_i}(1-p_i)^{1-y_i}$=1, the likelihood function is maximized. The optimal solution of weight matrix in logistic regression is $$W = argmax_W (\\sum_i^n(y_ilog(h_w(x_i))+(1-y_i)log(1-h_w(x_i)))) $$ Binary Cross-Entropy When we add the negative sign to the log likelihood function, we can get $$ - \\sum_i^n log(p_i^{y_i}(1-p_i)^{1-y_i})= -\\sum_i^n(y_ilog(p_i)+(1-y_i)log(1-p_i)) $$ This form is also called binary cross-entropy. To maximize the likelihood function to real distribution of data, is actually equivalent to minimize the binary cross entropy. Cross entropy is to measure the uncertainty between $y_i$ and $p_i$, $1-y_i$ and $1-p_i$. Higher the entropy is, less similar they are. So binary cross entropy assume the data is in Bernoulli distribution The goal to train the logisitic regression using binary cross-entropy is to let $h_w(x_i)$ get as close to $y_i$ as possible. Properties Logistic function actually projects the range of linear regression into range of [0,1]. Y-axis in logistic regression= possibility that input x belongs to one class, while the linear regression output range is ($-\\infty, +\\infty$). Logisitic regression is an bias model, since it considers the feature values X close to 0 are different and hence the gradient close to x=0 is large. However, when x is far away from x=0, such as $+\\infty, -\\infty $, the gradient of logistic function is close to 0 and it â€œconsidersâ€ there is no much difference between two features x1 and x2 when both x1 and x2 $\\to \\infty$. Logistic Regression has vanishing gradient problem. Since the gradient of logistic regression is : $$(\\frac{1}{1+e^{-wx}})â€™ =\\frac{ e^{-wx}}{(1+e^{-wx})^2} = (\\frac{1}{1+e^{-wx}})(1-\\frac{1}{1+e^{-wx}})$$ when it predicts some sample X as a value very close to 0 or 1, the gradient will be very close to 0 and the weight is hard to update any more. The gradient is actually vanishing in this case. When it think a sample X is class y, then it wonâ€™t be willing to change its mind. This is a reason why it is â€œbiased modelâ€ as well Logistic Regression is widely used for binary classification problem, it can be regarded as a two-classes version of softmax function. Using Maximum Likelihood estimation requires large data sample size in order to estimate the real distribution. Assumption in Logistic Regression is that the logarithem value of the ratio of possibility of class =1 to possibility of class =0 is linear, which can be estimated by linear regression.Proof:$$ log(\\frac{P(Y=1|X)}{P(Y=0|X)}) = log(\\frac{P(Y=1|X)}{1- P(Y=1|X)})=wx \\$$ $$ (1- P(Y=1|X))*e^{wx} = P(Y=1|X)$$ $$ P(Y=1|X) = \\frac{e^{wx}}{1+e^{wx}} = \\frac{1}{1+e^{-wx}}$$ Logistic Regression is to find a linear separation boundary /a line that separate the data in sample space for classification problem. Since in logistic regression $\\frac{1}{1+e^{-wx}}$, when $-wx&gt;0$, $h_w(x)&gt;0.5$ and it predicts class 1, otherwise, class 0. The line $-wx=0$ in 2-D space shown in the left figure below is actually the decision boundary. The data x with $-wx&gt;0$ is above the line and is classified as class1. Polynomial Regression$$yâ€™ = w_0 + w_1x_1 + w_2x_2^2 +w_3x_3^3+â€¦w_nx_n^n$$where yâ€™, $w_i$, $x_i$ are all scalar values in this case and yâ€™ is the predicted value from model. Different from linear regression, polynomial regression involves higher order terms. Optimize ModelSum square error$$ SSE = \\sum_i^N{ (y_i - yâ€™_i)^2}$$It is as same as the linear regression Properties It is very easy for Polynomial regression to over-fitting as the order increase. It is an biased model as well. It predicts the expected value of Y, which is as same as linear regression To implement polynomial regression, we can first construct polynomial features, like $x_1^2, x_1x_2, x_2^2$, etc. Then apply linear regression to polynomial features Lasso regressionThe prediction model of lasso regression is still linear regression:$$yâ€™=\\sum_{i=1}^nw_ix_i +w_0$$ Optimize Model Loss function to minimize in Lasso regression: $$min \\sum_i^n(y_i - wx_i -w_0)^2 + \\lambda||w||_{1}$$ where $y_i$ is a scalar value, a label, $x_i$ is a feacture column vector, $w$ is the weight vector. $\\sum_i^n(y_i - wx_i)^2$ is the least square error (or called L2 norm distance between y and x). Note that mean square error is scaled version of sum square error. Minimize the sum square error is equivalent to minimize the mean square error, so this term is as same as loss function in Linear regression The second term in the loss function is the L1- regularization term used to reduce overfitting effect, in which $||w||_1 = \\sum_i^n|w_i|$ is the L1 norm format. Principle of L1-Regularization term $$min \\sum_i^n(y_i - wx_i -w_0)^2 + \\lambda||w||_{1} $$ is equivalent to optimize the problem: $$min \\sum_i^n(y_i - wx_i -w_0)^2 \\ \\text{ subject to } ||w||_1 \\leq C $$ where C is a constant. Assume there are two variables in feature vector $x_i$ and only two weight variables, then to visualize it in 2-D space, we have: The x, y axis represent the weight variables. The blue point is the optimal point of the minimum least square error term. The orange region describes the constraints $||w||_1 \\leq C$, hence the intercepts on x, y axis are equal to $C$. The main idea of L1 regularization term is that when the weight vector satisfies the constraint, then the weight vector must be inside the orange region. We need to find the point with the smallest distance to blue point inside this region. When C is small enough such that weight vector can not reach the optimal point, then the model can reduce over-fitting effect. By using lagrange multiplier, the constraint problem can be converted to: $$min \\sum_i^n(y_i - wx_i-w_0)^2 + \\lambda (||w||_{1}-C) $$ where $\\lambda$ is the lagrange multiplier coefficient used to weigh the regularization term and $\\lambda$ is adjusted by user manually. Larger $\\lambda$ is, more regularization term affect. We can see that during minimization process, $C$ and $\\lambda$ are actually constants, so we can ignore this term and get: $$min \\sum_i^n(y_i - wx_i)^2 + \\lambda||w||_{1} $$ Properties It involves L1 regularization term to limit the range of weights and reduce over-fitting effect Lasso regularization can be used to do feature selectionSince in the figure above, we can see when the optimal solution to this constraint problem is at one of the angles of the square, some weight parameters are driven to be 0 and this leads to a sparse model. That is, the model filters out some features in $x_i$. As $\\lambda$ increases, more weights are driven to 0 and more features are not selected. We can not decide which features should be excluded in Lasso regression, since we donâ€™t know which parameters become 0. Feature selection with lasso regression is not stable. Since during training the model, some weights may be very close to 0, but not equal to 0. That is, the features that are expected to be filtered out are actually not filtered out and still affect the model performance.In addition, different initialization of weights may lead to different feature selection. Ridge RegressionThe prediction model of Ridge regression is linear regression as well: $$y = \\sum_{i=1}^nw_ix_i +w_0$$ But the loss function is different. Read the following. Optimize Model Loss function to minimize in Ridge regression: $$min \\sum_i^n(y_i - wx_i -w_0)^2+ \\lambda||w||_{2}^2$$ Ridge regression is similar to Lasso regression, except that the regularization term here use L2 norm distance. Then the constraint region in 2-D space becomes a circle, shown in below. Since the constraint region becomes a circle, it is almost impossible to drive some weights to be zeros unless the blue point (optimal point of least square error) is on the axis. Hence, Ridge regression can not be used for feature selection. Properties Ridge regression can not be used for feature selection Ridge regression can be used to reduce multi-collinearity effect of features and soothe the over-fitting effect.multi-collinearity means that some features have a linear correlated relationship. For example, one feature value increases, another feature value may increase or decrease linearly. If model focuses on the similar features, it may become over-fitting on such feature. The reason is that in the circle region, assume features $x_1$ and $x_2$ are collinear, if $w_1$ increases and the model weigh more on feature $x_1$, then $w_2$ will decrease and model weighs less on feature $x_2$. In this case, model could avoid focusing on learning similar features heavily and reduce the multi-collinearity effect.3. Reduce the variance in model error and reduce over-fitting effect Ridge regression is more stable than Lasso regression for avoiding over-fitting Elastic Net RegressionThe prediction model of Ridge regression is linear regression as well: $$yâ€™ = \\sum_{i=1}^nw_ix_i +w_0$$ Optimize Model Loss function to minimize$$min \\sum_i^n(y_i - wx_i- w_0)^2 + \\lambda_1||w||_{1} + \\lambda_2 ||w||_{2}$$ where $y_i$ is the label, $w$ is the weight vector and $w_0$ is the scalar bias. $x_i$ is the feature vector.Elastic net regression combines L1, L2 regularization terms together. Hence it can be regarded as the combination of weighed Ridge regression and weighed Lasso regression. Properties Combine the advantages of Lasso regression and Ridge regression. Stepwise RegressionIn statistics, stepwise regression is a method of fitting regression models in which the choice of predictive variables is carried out by an automatic procedure.Since there are multiple variable / features in feature vectors, we want to select the most important features to construct our regression model. Different combinations of variables lead to different regression model. Stepwise regression is to select the different feature variables and fit different models and then get the best one with least Residual sum square error Stepwise regression approachesAssume there are p features in dataset to pick. There are several types of approaches in stepwise regression for variable selection. Forward Stepwise Regression /selection Begin with the null model { a model that contains an intercept but no predictors. Fit p simple linear regressions and add to the null model the predictor that results in the lowest RSS. Add to that model the predictor that results in the lowest RSS among all two-predictor models. Continue until some stopping rule is satisfied, for example when all remaining variables have a p-value above some threshold. P-value is to measure how significantly different two models are using statistic technique There are p(p+1)/2 models to evaluate Backward Stepwise Regression (Backward elimination) Start with all predictors in the model. Remove the predictor with the largest p-value { that is, the predictor that is the least statistically significant. The new (p -1 )-predictor model is fit, and the predictor with the largest p-value is removed. Continue until a stopping rule is reached. There are p(p+1)/2 models to evaluate Bidirectional Stepwise Regression combine two methods above to see which predictor should be included or excluded from model Subset SelectionSubset selection is another variable selection method, in addition to stepwise regression Assume there are p features in dataset to pick fit all models for all subset pick the best model with smallest residual sum square error There are $2^p$ models to evaluate SummaryThis article summarizes the seven regression methods and their properties.Key things to note: Linear regression is to estimate the mean of normal distribution MSE assumes data is in normal distribution Logistic regression is an biased model to estimate the possibility that input x belongs to a class. Logistic regression assume data is in Bernoulli distribution. Binary cross entropy assumes data distribution is Bernoulli distribution Lasso Regression (L1 regularization) is good to do feature selection, but could be unstable. It can also reduce the over-fitting effect Ridge Regression can not be used for feature selection, but is good to reduce multi-collinearity effect and avoid overfitting Elastic Net Regression combines Lasso and Ridge regression Stepwise Regression and Subset selection are used to combine and select feature variables to find the estimators with the least SSE error. Reference[1] Stepwise Regression [2] https://www.analyticssteps.com/blogs/7-types-regression-technique-you-should-know-machine-learning [3] https://www.listendata.com/2018/03/regression-analysis.html [4] BIshop-PatternRecognition-MachineLearning.pdf [5] https://strata.uga.edu/8370/rtips/images/outlier.png","link":"/2020/09/30/ML-Model-LR/"},{"title":"Recommendation-System-1- Collaborative Filtering and Content-based Filtering","text":"Introduction to Recommendation systemIn recommendation system, we want to let it give recommendations of items to users based on usersâ€™ visit history or other data.if we represent the items and users in a table, it would be something like this: users\\items item 1 item 2 item 3 user 1 1 - - user 2 - 1 - user 3 - - 1 user 4 1 1 - In this table, each row represent a user and column represent an item. The cell with value 1 means that user buys the corresponding item. For example, the cell of user1 - item 1 =1 means user 1 buys item 1. Then recommendation system is to predict if the empty cells in the table will become 1 or not. Or predict if that user will buy the item or not. Building such recommendation system can help encourage users to consume items by recommending somethings attracting them and let companies make profits Collaborative Filtering is one type of common methods in constructing recommendation system. Its main idea is to find the similarity between users or between items to rank the items and then pick and recommend the top K items to users.In content-based filtering, it utilizes the content features of items and the contents users may like to compute similarity between item and user and make recommendation. There are three common ways to do recommendation user-based It first computes similarity between users, then pick top K items that the most similar user like to the current user Item-based It recommends new items to current user based on the similarity between new items and items that user has brought before content-based It computes the similarity between user and item based on the tags/topics the user like and the tags/topics that item contains. Then it recommends the most similar item to the user. Cold Start ProblemIn recommendation system, we also face a problem that when a new user or a new item comes to the platform, we donâ€™t have enough information (like the preference of new users, tags/contents of new items) about them to make recommendation. Hence Cold start problem mainly can be divided into two types: Cold start of user: We donâ€™t have enough information about new users and can not determine the preference of users to do recommendation Cold start of item: We donâ€™t have enough information of new items and donâ€™t know the tags and contents those items may have User-based filtering (similarity between users)The main idea in user-based filtering is that we first find the similarity between each two users based on the item vectors of the two users.Then pick the user who is most similar to the current user. In the item list of the selected user, we pick the K top frequent visited items to the current user. How it works AssumptionAssume we have a user-item table users\\items item 1 item 2 item 3 item 4 user 1 1 - 1 1 user 2 1 1 1 - user 3 - - 1 1 user 4 1 1 - 1 where 1 represent the ratign from the user to the item the user purchase, - mean the user doesnâ€™t buy the item. Denote the $i^{th}$ user and the $j^{th}$ user as ui, uj, respectively and N(ui), N(uj) are the set of items the $i^{th}$ user purchased and the set of items $j^{th}$ user purchased respectively. |N(ui)| is the number of items the $i^{th}$ user purchased. Step 1: Compute Similarity between a pair of usersIn order to compute the similarity between a pair of users, we need a way to measure the distance between users.One common way is cosine distance, denoted as cos(ui, uj): $$cos(ui, uj) = \\frac{ |N(ui) \\cap N(uj) |}{\\sqrt{|N(ui)| \\times|N(uj)|} }$$ where $|N(ui) \\cap N(uj)|$ means the size of the intersection set between the set of items purchased by ui and the set of items purchased by uj. Example:In the table above, we want to compute cos(u1, u2), then we can see the intersection of the items from u1 and items from u2 is [item1, item3], so $|N(ui) \\cap N(uj)|=2$. Both u1 and u2 users purchase 3 items, so $|N(u1)|=|N(u2)|=3$ Then similarity between user 1 and user 2 is:$$cos(u1, u2) = \\frac{ 2}{\\sqrt{3 \\times 3} }$$ Based on this, we can compute similarity between every pair of users in table.There are other choices to compute similarity, such as Euclidean distance, dot product, Pearsonâ€™s Correlation. Step 2: Predict the interest of the $i^{th}$ user, ui, on the $x^{th}$ item, ix In this step, we first pick the top K users who are most similar to ui. Then We pick the users who rated the item ix from the K users.Finally we compute the estimated rating of ui on item ix using user similarity and ratings from those users. Estimated rating of ui on item ix is $$R(ui, ix) = \\sum_{v\\in M} { cos(ui, v) \\times R(v, ix)}$$ where M is the intersection between the set of the top K similar users and users who rated the item ix. The $R(v, ix)$ is the rating of user v on item ix. Note that we can also use K-Nearest Neighbor method, rather than cosine similarity to find the top K simiar users as well. In this case, we may use Euclidean distance or other distance to measure similarity. Properties Advantages Easy to implement It is good to explore group interests on items, since it measures similarity between users in a group Good to use this method when the update of incoming new items is faster than the update of incoming new users(Computing similarity between new user and other existing users is time expensive when there is millions of users. But updating similarity after adding new items is much easy, we just need to update N(ui)) Disadvantages Sparsity. The percentage of rating from users is low User-based collaborative filtering is also a memory-based mehtod, since it requires memory to store similarity between users. when update frequency of user is faster than the update frequency of items, it is time-expensive, especially there are millions of users Cold start problem. When there is no sufficient information about users or item, it is hard to estimate similarity efficiently update is slow when there are large amount of users or items When to use when we want to explore group interests or similarity between users in a group The number of users is smaller than the number of items. Or Incoming new users amount is smaller than incoming new items amount. Item-based filtering (similarity between items)The main idea in Item-based is to compute the similarity between new item and the items purchased by users to predict if users will buy the new item. How it worksUsing the user-item table above users\\items item 1 item 2 item 3 item 4 user 1 1 - 1 1 user 2 1 1 1 - user 3 - - 1 1 user 4 1 1 - 1 Denote the $i^{th}$ item as xi. M(xi) is the set of users who purchased item xi and |M(xi)| is the size of this set Step 1: Compute similarity between a pair of itemsThe cosine similarity of item xi and item xj is similarity to the similarity between users: $$cos(xi, xj) = \\frac{ |M(xi) \\cap M(xj) |}{\\sqrt{|M(xi)| \\times|M(xj)|} }$$ In this example, $cos(x1, x2) = \\frac{ |M(x1) \\cap M(x2) |}{\\sqrt{|M(x1)| \\times|M(x2)|} } = \\frac{2}{\\sqrt{3\\times 2} } $ Step 2: Predict Rating of user ui on item xiWe pick the K items which are most similar to item xi based on computed item similarity. Then find the intersection Q between these K items and the set of items user ui purchased.Then estimated rating of user ui on item xi is $$R(ui, xi) = \\sum_{y \\in Q} { cos(xi, y) \\times R(ui, y)}$$ where Q is the intersection set between K items and the set of items user ui purchased. y is item from Q. $R(ui, y)$ is rating of user ui on item y. Properties Advantages Item-based Collaborative filtering is good for personalized recommendation, since it is based on similarity of items user purchased, which shows userâ€™s preference information. Good to use this method when there are a large amount of users. Easy to compute as well Good Explainability Disadvantages It is memory-based model as well. Hence it needs to store information of items, users. If there are millions of items, the computation is expensive Cold Start problem. For new item, it is hard for us to compute similarity between items since there is lack of users using the new item Sparsity. The number of users using new items could be small and it is hard to compute similarity Time complexity is high when there are millions of items and users When to use when we want to make personalized recommendations to users when the amount of items is not pretty large. Or the update frequency of items is smaller than update frequency of usersâ€™ information. When we have enough information about items and cold start effect is small. Content-based filtering (based on tags/content of items)Letâ€™s consider that there are some tags/contents in items and users may prefer some tags/contents and hence like the items that contain such tags/contents. Based on this setting, we can construct an item vector $v_i$ and an user vector $u_i$. $v_i$ and $u_i$ have the same shape Each entry in the vector represents whether this item contains the corresponding tags/contents, or whether this user like or dislike the corresponding content / tag. The user vector is given by this formula:$$u_i = \\frac{1}{n}\\sum_i^nu_i - \\frac{1}{m}\\sum_j^mu_j$$ where $u_i$ is the item vector that user likes and $u_j$ is the item vector that user dislikes. Each entry in user vector is the difference between the level of prefering this contents and the level of disliking this contents. If entry is negative, then user may dislike that content. After computing the user vector, we can compute the similarity between user vector and item vectors to see which item is most likely to be purchased by user based on userâ€™s interests. The similarity can be computed by dot product similarity: $$similarity(ui, vi) = &lt;ui, vi&gt;$$ where &lt;ui, vi&gt; is dot product of ui, vi. Note that for ui, vi, we donâ€™t use normalization here, since when there are large amount of contents but item has only a few contents, the vector will be very sparse. Normalization in a sparse vector will make the non-zero values pretty small and even close to 0, which make computation difficult and may loss precision. Steps in content-based filtering are as follow: Compute item-content vectors and user vectors Compute similarity between user and items Rank items to recommend Examplein a item-content table: item tag1 tag2 tag3 v1 1 0 1 v2 1 0 0 v3 0 1 0 v4 0 1 1 in a user-item table: user item1 item2 item3 item4 u1 1 1 -1 -1 Step1: compute item vectors and user vectorin item-content table, 1 represents item vi contains this tag/content, otherwise, it doesnt. In user-item table, 1 indicates this user like this item and -1 means user dislike this item.Hence item vectors are v1 = [1, 0, 1], v2 = [1, 0, 0], v3= [0, 1, 0], v4=[0, 1, 1]Then user vector u1 = $\\frac{v1+v2}{2} - \\frac{v3+v4}{2}$ = [1, 0, 0.5] - [0, 1, 0.5] = [1, -1, 0]. In this case, we can see user1 like tag1 and dislike tag2 and be neutral about tag3. Step2: compute similarity between user and itemsSim(u1, v1) = &lt;u1, v1&gt; = 1 * 1 + 0 * (-1) + 1 * 0 = 1Sim(u1, v2) = &lt;u1, v2&gt; = 1 * 1 + 0 * (-1) + 0 * 0 = 1Sim(u1, v3) = &lt;u1, v3&gt; = 0 * 1 + 1 * (-1) + 0 * 0 = -1Sim(u1, v4) = &lt;u1, v4&gt; = 0 * 1 + 1 * (-1) + 1 * 0 = -1 Step3: ranking and recommenduser likes v1, v2 and dislikes v3, v4. Update of user vectorSince user vector is just the difference between the average of like item vectors and the average of dislike item vectors. When the $k^{th}$ item comes, we can update either the like vector or dislike vector to update the user vector. Let the average of K1 item vectors that user likes as $$u^+_{k-1}= \\frac{1}{k1-1}\\sum^{k1-1}_iv_i$$ the average of K2 item vectors that user dislikes as $$u^-_{k-1} = \\frac{1}{k2-1}\\sum^{k2-1}_jv_j$$ and K1 + K2 = k-1 user vector for k-1 items is $$u_{k-1} = u_{k-1}^+ -u_{k-1}^-$$ When the $K^{th}$ item comes, if user like this item, then we update like vector $$u_{k}^+ = \\frac{(k1-1)u_{k-1}^+ + v_k }{k1} , u_{k}^- = u_{k-1}^-$$ if user dislikes the item, just update dislike vector $$u_{k}^- = \\frac{(k2-1)u_{k-1}^- + v_k }{k2} , u_{k}^+ = u_{k-1}^+$$ This enable us to update the user vector on the fly. Properties Advantages Easy and very fast to compute similarity even when there are large amount of items or users. Utilize the content information to explore potential contents that user likes Compared with Item-based and user-based method, it is less sensitive to Cold Start problem, since contents of item can be defined easily. Disadvantages Sparsity of item vectors. Item vector could be sparse when there are a lot of contents and content follow long-tail distribution (Note long-tail distribution of feature/item can also lead to the sparsity) Very easy to converge to certain scope. Since content/tag could be long-tail distribution and most of items have similar content, then a small change in the item vector will lead to large change of similarity.For example, a user vector u= [100, 0, 1, -100], due to long-tail distribution of contents, the values between contents are quick different. For item vectors v1 = [1, 0, 0, 0 ] and v2= [0, 0, 1, 0], sim(u1,v1) and sim(u1,v2) would be very different. When to useWhen we have more information about items and want to use those contents in recommendation. Reference[1] https://medium.com/@cfpinela/recommender-systems-user-based-and-item-based-collaborative-filtering-5d5f375a127f [2] https://zh.wikipedia.org/wiki/%E5%8D%94%E5%90%8C%E9%81%8E%E6%BF%BE [3] https://ars.els-cdn.com/content/image/1-s2.0-S1110866515000341-gr3.jpg [4] https://towardsdatascience.com/introduction-to-recommender-systems-1-971bd274f421","link":"/2020/12/15/Recommendation-System-1/"},{"title":"PySpark-Note-1","text":"IntroductionThis note is to introduce some useful functions in PySpark and also do some practice with them to analyze SF crime dataset. Then KMean Clustering model is applied to show how to use ML model in PySpark. List of Useful Functions Create Spark Session SparkSession Create spark session, the main entry to create DataFrame, register DataFrame as tables, execute SQL over tables, cache tables, and read parquet files. 123456from pyspark.sql import SparkSessionspark = SparkSession.builder \\.master(\"local\") \\.appName(\"Word Count\") \\.config(\"spark.some.config.option\", \"some-value\") \\.getOrCreate() Explanation: .master(â€˜localâ€™): sets the Spark master URL to connect to. â€œlocalâ€ mean run spark locally. Just like a local server .appName(â€œWord Countâ€) : application name .config(â€œspark.some.config.optionâ€, â€œsome-valueâ€): configure some key-value pair in application .getOrCreate(): Gets an existing SparkSession or, if there is no existing one, creates a new one SQLContext As of Spark 2.0, this is replaced by SparkSession. However, this class is kept here for backward compatibility. A SQLContext can be used create DataFrame, register DataFrame as tables, execute SQL over tables, cache tables,and read parquet files. Load data After we create a SparkSession, we can use the following code to read data from CSV or JSON file. Returned Object: PySpark DataFrame object csv12345678# Set delimiter = \";\" between columns# Skip header of file if header=True. # Otherwise, load header as data recordspark.read.options(header= True,delimiter=\";\") \\.csv(\"path-to-dataset/dataset.csv\")# orspark.read.options(header= True,delimiter=\";\") \\.format('csv').load(\"path-to-dataset/dataset.csv\") json123spark.read.json(\"path-to-dataset/dataset.json\")#orspark.read.format('json').load(\"path-to-dataset/dataset.json\") Useful functions of pyspark.sql.DataFrame with SQL Create DataFrame and SQL table df.createDataFrame(data, schema=None): create PySpark dataframe data: a list of tuples,each tuple contains the data of a row schema: a list of column names of dataframe 12345spark = SparkSession.builder\\.master(\"local\").appName(\"Word Count\")\\.config(\"spark.some.config.option\", \"some-value\").getOrCreate()l1 = [('Alice', 1)]new_row1 = spark.createDataFrame(l1,[\"name\",\"age\"]) df.createGlobalTempView(view_name) Creates a global temporary view with this DataFrame. df.createOrReplaceTempView(view_name): Creates or replaces a local temporary view with this DataFrame. df.registerDataFrameAsTable(table_name): Registers the given DataFrame as a temporary table in the catalog. Show Columns, Rows, Statistic description df.columns: a list of column names df.summary(): Computes specified statistics for numeric and string columns, with count - mean - stddev - min - max. df.describe(): Computes basic statistics for numeric and string columns. Similar to summary() df.printSchema(): print Schema / decriptions of each column, like data type Query and Selection df.head(10): return the top 10 rows in Row type, not DataFrame df.tail(10):return the last 10 rows in Row type, not DataFrame df.where(condition) or df.filter(condition) : select the rows which satisfy the conditions. Return a DataFrame 12345678# Select ages that are &lt; 100 and City name = \"SF\"# Using SQL expression in conditionsdf.where(\"age &lt; 100 and city in ('SF') \")#Using Spark APIfrom pyspark.sql import Rowfrom pyspark.sql.functions import coldf.where(col(\"age\")&lt;100 &amp; col('city').isin([\"SF\"])) df.column.isin([â€˜aâ€™,â€™bâ€™])Check if the value in a column is in the list or not df.column.between(lower_bound, upper_bound)check if the value is within a range or not df.select([â€œcolumn-nameâ€]):select the columns based on a list of given column-names df.take(N):Return a list the top N rows in Row() format df.collect():convert pyspark dataframe to a list of row in Row() format Handle data df.withColumn(â€˜column_nameâ€™, col):append a column to dataframe with name â€œcolumn_nameâ€ col: a Column expression for the new column. we can use UDF (user defined function) to it as well. 1df = df.withColumn(\"age\", df.age+2) df.withColumnRenamed(â€œold nameâ€,â€new nameâ€):rename a column in the dataframe df.drop([â€œcolumn-nameâ€]), df.dropna(subset =[â€œcolumn-nameâ€])):drop columns and drop the rows with NaN in selected columns df.dropDuplicates([â€œcolumn-name-to-remove-duplicated-valueâ€]):drop duplicated rows in selected coumns df.fillna(), df.fill_duplicates(): fill na with given values df.spark.sql.Row(age=10, name=â€™Aâ€™):Return a row with elements: age=10, name=â€™Aâ€™ df.orderBy([â€œcolumn-nameâ€], ascending=False), df.sortBy():orderBy is an alias of sortBy, they sort the dataframe along given column names df.groupby().agg() / df.groupby().count()Apply aggregation function, such as count() to a group 123# First select group based on column A, B. Then count the amount of group \"A\"from pyspark.sql import functions as Fdf.groupby([\"A\"]).agg(F.count(df.A)) Append New Rows df.union():Return a new DataFrame containing union of rows in this and another DataFrame, based on position. df.unionByName([â€œcolunm-nameâ€])The difference between this function and union() is that this function resolves columns by name (not by position) 12new_row = spark.createDataFrame([(\"A\",1)],[\"name\",\"count\"])df = df.union() SQL df = SparkSession.sql(â€œselect * from tableâ€) Display Data df.show(n) Data Types Convertion with Pandas df.toPandas()convert dataframe to pandas dataframe df.toDF()convert a list of Rows to PySpark dataframe Convert Pandas DataFrame to PySpark DataFrame using Schema 12345from pyspark.sql.types import *mySchema = StructType([ StructField(\"col name1\", IntegerType(), True)\\ ,StructField(\"col name2\", StringType(), True)\\ ,StructField(\"col name3\", IntegerType(), True)])spark_df = spark.createDataFrame(df, mySchema) Using Resilient distributed Dataset (RDD) RDD represents an immutable, partitioned collection of elements that can be operated on in parallel. Please refer to the official website about RDD Practice with Example: SF Crime data Requirements: Find a platform for distributed computing, like databricks Install PySpark Download SF Crime Data for Demo 12345import requestsr = requests.get(\"https://data.sfgov.org/api/views/tmnf-yvry/rows.csv?accessType=DOWNLOAD\")with open(\"sf_crime.csv\",\"w\") as f f.write(r.content) f.close() Load Data with PySpark 12345678910111213from pyspark.sql import SparkSessionfrom pyspark.sql.functions import to_date, to_timestamp, hourfrom pyspark.sql.functions import year, month, dayofmonth, date_formatfrom pyspark.sql.functions import from_unixtime, unix_timestamp# create SparkSession entry to handle dataspark = SparkSession \\ .builder \\ .appName(\"crime analysis\") \\ .config(\"spark.some.config.option\", \"some-value\") \\ .getOrCreate()# load csv datadf_opt1 = spark.read.option(\"header\", \"true\").csv(data_path) Visualize Data 1234567891011# Create a view called \"sf_crime\" to the dataframe, so that we can use SQL# to query data laterdf_opt1.createOrReplaceTempView('sf_crime')# if using databricks, we can use display function to see the datadisplay(df_opt1 )# ordf_opt1.show()# or # show the schema of dataframedf_opt1.printSchema() Clean DataChange the string data type to date type, integer type and other suitable data type 12345678910# convert data type and replace datadf_opt1 = df_opt1.withColumn('Hour', hour(df_opt1['Time']))# convert string to date type using unix_timestampdf_opt1 = df_opt1.withColumn(\"Date\", to_date( from_unixtime(unix_timestamp(df_opt1['Date'], 'MM/dd/yyy'))))df_opt1 = df_opt1.withColumn(\"Year\", year(df_opt1.Date))df_opt1 = df_opt1.withColumn(\"Month\", month(df_opt1.Date))df_opt1 = df_opt1.withColumn(\"Day\", dayofmonth(df_opt1.Date))df_opt1 = df_opt1.withColumn('HasCriminal', (df_opt1[\"category\"]!=\"NON-CRIMINAL\"))df_opt1 = df_opt1.withColumn(\"X\", df_opt1[\"X\"].cast(\"double\"))df_opt1 = df_opt1.withColumn(\"Y\", df_opt1[\"Y\"].cast(\"double\")) Query and Select data Iâ€™m interested inI want to analyze the count of crime of each category here, so there are two ways to do this. 12345678910# Display Count of cime using SQLcrimeCategory = spark.sql(\"SELECT category, COUNT(*) AS crime_counts FROM sf_crime GROUP BY category ORDER BY crime_counts DESC\")crimes_pd_df = crimeCategory.toPandas()display(crimeCategory)# Display Count of crime of each category Using PySparkcrime_category_df = df_opt1.groupby('category').count().orderBy('count',ascending=False)crime_category_df = crime_category_df.withColumnRenamed('count', 'crime_counts')crime_category_df = crime_category_df.toPandas()display(crime_category_df) Result Advance Topic: Machine Learning ModelUsing KMean Clustering to find the 5 centers in which crimes occur frequently Select Position data X,Y and then Use Interquantile Range method to find outliers of positionSince KMean Clustering is sensitive to the outlier as it uses mean method to find the center of clusters, we need to remove outliers first. Quantile Based method to remove outlier: The outlier is defined as the data point that drop outside the range [Q1-1.5IQR , Q3+1.5IQR],where Q1 and Q3 are the first and third quantile of dataset and IQR = Q3-Q1 is the interquantile range. API in PySpark to find quantile: df.approxQuantile(col, probabilities, relativeError):col: column to find quantileprobabilities: a list of quantile probabilities we want to find. Here I want to find Q1 =0.25 and Q3=0.75return: the a list values that correspond to the quantile in probabilities list. 1234567891011121314151617# select the positions where crimes occurcrime_cluster_df = df_opt1.where(\"hasCriminal =true\").select([\"Hour\", \"PdDistrict\", \"X\",\"Y\", \"DayOfWeek\", \"category\",\"Resolution\",\"hasCriminal\"])# crime_cluster_df.show()#Find the Q1, Q 3 Quantilebounds = { c: dict( zip([\"q1\", \"q3\"], crime_cluster_df.approxQuantile(c, [0.25, 0.75], 0)) ) for c in crime_cluster_df.select([\"X\",\"Y\"]).columns}# compute lower bound and upper bound of normal datafor c in bounds: iqr = bounds[c]['q3'] - bounds[c]['q1'] bounds[c]['lower'] = bounds[c]['q1'] - (iqr * 1.5) bounds[c]['upper'] = bounds[c]['q3'] + (iqr * 1.5) Remove Outliers based on upper bound and lower bound of quantile 1234from pyspark.sql.functions import *crime_cluster_df = crime_cluster_df.select([\"X\",\"Y\"])\\.where(col(\"X\").between(bounds['X']['lower'], bounds['X']['upper'])) \\.where(col(\"Y\").between(bounds['Y']['lower'], bounds['Y']['upper'])) Assemble columns into one feature column before trainingIn PySpark, we need to put all feature columns into one single feature column before we train the model. VectorAssembler provides a way to assemble those features into one column. 1234# ensemble multiple columns into one single feature column for training KMean Clusteringfrom pyspark.ml.feature import VectorAssemblervecAssembler = VectorAssembler(inputCols=[\"X\", \"Y\"], outputCol=\"features\")crime_cluster_df = vecAssembler.transform(crime_cluster_df.select([\"X\",\"Y\"])) KMean Clustering to learn dataIn Machine Learning of PySpark, we need to set the name of feature column to â€œfeaturesâ€, otherwise, set featuresCol=&quot;column-name&quot; to select which feature column to learn in dataframe 123456789101112# Training KMean clusteringfrom pyspark.ml.clustering import BisectingKMeansK=5bkm = BisectingKMeans(k=K, minDivisibleClusterSize=1.0)model = bkm.fit(crime_cluster_df)# predict at one single point# print(model.predict(crime_cluster_df.head().features))# predict clusters# Output the prediction to the column called \"Prediction\"model.setPredictionCol(\"Prediction\")transformed = model.transform(crime_cluster_df).select(\"X\",\"Y\", \"Prediction\") Result SummaryThis tutorial introduce: List of useful PySpark functions and their basic usage Use SF Crime dataset as a demo to see how to use PySpark to manipulate data and visualize them How to use machine learning model: KMean Clustering in PySpark to learn data. Note: the APIs of ML in PySpark are different from sklearn. Need to Pay attention to the difference. Reference[1] SparkReader,Writer[2] PySpark,SQL_module[3] PySpark,ML_module[4] PySpark,outlier_detection[5] logo","link":"/2020/10/12/PySpark-Note-1/"},{"title":"Accuracy Improvement-Ensemble Learning","text":"IntroductionIn our life, we know that the powerful of a single person is much weaker than a group of people. One simple example is tug-of-war. A group of people have stronger power than a single person and much easier to win the competition. Similarly, when making a decision about if a person should be punished, the judgement from a group of jurors is less biased than that from a single juror, since they consider different aspects of the case.In machine learning, ensemble method applies such idea to combine decisions from different models and improve the accuracy. Three common ensemble methods are: bagging, boosting and stacking. Bagging (bootstrap aggregation) Main Idea: Its goal is to reduce variance by using multiple classifiers, like decision tree. It uses boostrap method to sample data and train multiple classifiers and then average the prediction over a collection of classifiers (for continuous value prediction, regression), or return the prediction with maximum votes (for classification) Random forest is a bagging approach, which bags a set of decision trees together. Assumptions we have training set with size of D and a set of models with size of K Training: Similar to Bootstrap, at each iteration i, a training set Di of d tuples is sampled with replacement from training set. A classifier model Mi is learned for each training set Di Prediction: Each Classifier Mi returns prediction for input X. Discrete value output: The bagged classifier counts the votes and assigns the class with the most votes to X Continous value output: take the average value of each prediction for a given test sample. Advantages: Better than a single classifier from the classifier set. More robust in noisy data and hence smaller variance Disadvantages: 1.Its training depends on sampling techniques, which could affect the accuracy The prediction may be not precise, since it uses average value of classifiersâ€™ predictions. For example, if valid prediction values are 1,2,or 3, then the average of predictions from different model could lead to a floating point number. Features of Random Forest Comparable in accuracy to Adaboost, but more robust to errors and outliers. Insensitive to the number of attributes selected for consideration at each split, and faster than boosting Boosting Main Idea: Its goal is to improve accuracy, let models better fit training set. It uses weighted votes from a collection of classifiers Training: Each training sample/tuple is given a weight, eg $w_i$ for the $i^{th}$ tuple. Then we have training set {(X0,y0, w0), â€¦ ,(Xi,yi, wi)}where $X_i$ and $y_i$ are training sample and target We have k classifiers {M0, M1,â€¦Mk}. Each classifier is learned from the whole training set iteratively. That is, if we have k classifiers, then we need to iterate the training set at least k times (at $i^{th}$ iteration, we train the $i^{th}$ classifier), so that each classifier can learn the training set. After classifier $M_i$ is learned on training set, classifier $M_{i+1}$ pays more attention to the training samples that are misclassified by $M_i$ Prediction: The final Model combines the votes of each individual classifier. Either find the prediction with largest sum of weights (Classification), or find the average of all prediction values (Regression) The weight of each classifier's vote is a function of its accuracy Advantages Boosting can be extended to numeric prediction Better fit the training set since it adjusts the weights of training set and gives more attention to the misclassified sample. Disadvantages Easy to overfit. Need Additional techniques to avoid overfitting. (I will discuss the methods dealing with Overfitting ). Questions: How to pay more attention to misclassified samples? give Higher weights? But How to compute weights?Answer: This depends on the actual boosting algorithm, like GradientBoosting, AdaBoosting AdaBoosting Assumption: Assume we have training set with size of D and a set of classifier models with size of T __Error of model $M_i$__ Error($M_i$) = $\\sum_i^D (w_i \\times err(X_i))$ if using normalized weight (weight in range [0,1]), then Error($M_i$) = $\\frac{\\sum_i^D (w_i \\times err(X_i))}{(\\sum_j^D w_j)} $ Note: In classification, $err(X_i)= 1(C_i(X_i) !=Y_i)$, $C_i(X_I)$ means the prediction of model $M_i$ on sample $X_i$. If the prediction is correction $error(X_i) =0$, otherwise 1. Weight of model $M_i$â€™s voting: $\\alpha_i$ $\\alpha_i = log\\frac{1-error(M_i)}{error(M_i)} + log(K-1)$. Note: K = the number of classes in dataset. When K=1, log(K-1) term can be ignored Update of weight $w_i = w_i \\cdot exp(\\alpha_i \\cdot 1(M_j(X_i) != Y_i))$ The weight $w_i$ of the $i^{th}$ training tuple $X_i$ is updated by timing exponential value of weight of model only when this model $M_j$ misclassifies the $X_i$ ( That is $M_j(X_i) !=Y_i$ and hence $1(M_j(X_i) !=Y_i) =1 $). Prediction $C(X_i) = argmax_{k} \\sum_{j=1}^T \\alpha_{m}\\cdot 1(M_j(X_i)== Y_i)$ where $1(M_j(X_i)== Y_i)$ is equal to 1 if prediction is correct, otherwise, 0. The prediction of the whole model has the largest sum of weight of models, NOT the weight of training tuple! More detail for AdaBoosting, Read this paper Stacking Main Idea: It combines and trains a set of heterogeneous classifiers in parallel. It consists of 2-level models: level-0: base model Models fit on the training data and whose predictions are compiled. level-1: Meta-Model It learns how to best combine the predictions of the base models. Training: split the training data into K-folds one of base models is fitted on the K-1 parts and predictions are made for Kth part. Repeat step 2 for each fold Fit the base model on the whole train data set to calculate its performance on the test set. repeat step 2~4 for each base model Predictions from the train set are used as features for the second level model. Classification: Second level model is used to make a prediction on the test set. Advantage: It harness the capabilities of a range of well-performing models on a classification or regression task and make predictions that have better performance than any single model in the ensemble. Disadvantage: It could be computational expensive since it uses k-fold method and use multiple level models. Comparison among Ensembling, boosting and bagging Goal of bagging is to reduce variance and noise while boosting is to improve accuracy using weighted models. Stacking is to improve accuracy of model using hetergenerous models. Adaboost let classifiers pay more attention to the misclassified samples, but if those misclassified samples are outlier or noisy data, it will affect a lot and lead to larger variance. However, bagging and ensemble uses averaging and voting methods and each classifier has equal weight, which is less sensitive to the noise data and outlier. Reference[1] https://blog.csdn.net/weixin_37352167/article/details/85028835[2] https://machinelearningmastery.com/stacking-ensemble-machine-learning-with-python/[3] https://miro.medium.com/max/497/0*Bbf8eeslDtVKog7U.png","link":"/2020/07/23/Model-Acc-Improvement/"},{"title":"NLP Word Representations","text":"1. Representation:1.1 WordNeta thesaurus containing lists of synonyms and hpernyms, using â€œis-aâ€ to denote the relationship among words. Advantages: easy to understand the relationship. It is interpretable. Disadvantages: good as resource, but missing nuance in different context. Eg: â€œproficientâ€ doesnâ€™t always mean â€œgoodâ€ Hard to update with new meanings of words, since the meanings of words may change along time subjective and bias Require Human to label Canâ€™t compute accurate word similarity 1.2 One-hotRepresent word as discrete symbol, eg. 0 or 1Example: In sentence â€œI like dogâ€, the vector for â€œIâ€ =[1,0,0], the vector for â€œlikeâ€ =[0,1,0],the vector for â€œdogâ€ =[0,0,1] word one-hot vector â€œIâ€ 1 0 0 â€œlikeâ€ 0 1 0 â€œDogâ€ 0 0 1 Note: Usually, the number of of vocabulary is equal to the number of entry in the one-hot vector. This enables the (Manhatton) distance between any two words/labels is same and the feature of each word is independent with each other.The feature of a word contains no information about another word and hence donâ€™t affect other words. Moreover, this method also has physical meaning and easy to understand.For example:Assume in linear regression,we have $y =w_1x_1 + w_2x_2 + w_3x_3 $, in vector representation it is $Y = [w_1, w_2, w_3] \\cdot [x_1, x_2, x_3]^T = WX$Let vector X be a one-hot vector. That is, one of $x_1, x_2, x_3$ must be one. In this case, $WX$ becomes a lookup table to choose which weight $w_1, w_2, w_3$ should be learned. In this case, weight $w_1$ is affected by feature $x_1$ only, without being affected other features. This can lead to faster convergence of $w_1$ in learning . Advantage: able to represent words into number for computing Easy to understand, since it has physical meaning Features/ labels are independent from each other Disadvantage: Vector dimension equal to the number of words in vocabulary, it could be very big No natural notion of similarity, since word vectors are orthogonal. Hard to extend the representation of labels when more labels are added. Could be memory expensive when a large group of labels involved. Eg, represent vocabulary in a book as one-hot vector, the vectors could be very large and sparse. 1.3 Bag of Words (BOW)Similar to one-hot, it represents each word as orthogonal vector, but the number of vector is the frequency the word appears. In BOW, a text (such as a sentence or a document) is represented as the bag (multiset)/set of its words, disregarding grammar and even word order but keeping multiplicity. Advantage: Easy to realize and compute Easy to use for simple case (the order of words donâ€™t matter a lot) Disadvantage: Without considering similarity among different words it has the same drawbacks as one-hot vector 1.4 n-gram modelN-gram model is an extension of bag of word model. While bag-of-word model considers each word only, N-gram model considers a tuple of n consecutive words as an element in the collection of words. Example: Consider a sentence: â€œa boy is playing gramesâ€. When using 3-gram model, the collection of words becomes {(a boy is), (boy is playing),(is playing games)} Then if we have a 3-gramm vector for a document: [1, 0,0 ], it means the element (a boy is) appear once in the document. Advantage: More flexible and robust than bag-of-world model, since it could considers different structure of words. Some names like â€œdeep learningâ€, â€œmachine learningâ€ with more than one words can be detected easier. Disadvantage: The collection could be large when using different grams. Usually, bigram and trigram are used. 1.5 Word Vectors/ Word Embeddings/Word distributed representationsWord Vectors represent words by context. Context of a word is a set of words that appear nearby, or in a fixed window A word meaning is given by the words that frequently appear close-by. Each entry in a word vector for a word is the similarity between this center word and the words in context. Eg: In â€œI like dogâ€, vector for â€œlikeâ€ = [0.01,0.7 ,0.5], where 0.5 is the possibility â€œdogâ€ will occur, given center word â€œlikeâ€. More general, given the center word $w_{t}$, the possibility of context word $w_{t+1}$ will occur is $P(w_{t+1}|w_{t} )$. Then in word vector, our goal is to find the best condition distribution to represent the vector. There are many frameworks to find word vector, such as word2Vec, Glove, Fasttext. Advantage: Able to compute similarity between words No need to label by human Disadvantage: Dimension of vector is equal to the number of words in vocabulary. It could be very large Need to learn the similarity by word2vector framework. Hard to compute similarity when there is a large corpus of words 2. Word2Vector: Skip-gramA framework to learn and find dense word vectors, rather than sparse orthogonal vector like bag-of-word model. Here is details about word2vector The dense word vectors measure similarity between two words. If two words are similar, then they have similar word vectors. Goal: to learn the word vector that measure the similarity between context and center word, Or possibility that the next word will occur, given the center word. 2.1 Summary of Idea in Word2Vector: Collect a large corpus of text Represent each word in text as a vector (count vector or one-hot model) Go through each position t in text, find center word c and outside words o (context words) Find similarity of the word vectors for c and o (c and o are actually from the output of the neural network), compute possibility of context o, given center word vector c Keep adjusting word vectors / train the network to maximize possibility/likelihood function and find the optimal word vectors that contains similarity between c and o. Note: input to network is one-hot vector , output to network is similarity/possibility vector. The output is the vector we want 2.2 One-hot Vector In Skip gram, it first find the set of vocabularies and then converts each word into its one-hot vector. In one-hot vector, 1 represents the word Example:consider a sentence â€œI like dog and you like catâ€.Then there is a set of words [â€œIâ€,â€youâ€ ,â€likeâ€â€,â€dogâ€,â€catâ€,â€andâ€]. word one-hot vector â€œIâ€ [1,0,0,0,0,0] â€œlikeâ€ [0,1,0,0,0,0] â€œdogâ€ [0,0,1,0,0,0] â€œandâ€ [0,0,0,1,0,0] â€¦ â€¦ Then one-hot vector for â€œlikeâ€ = [0,0,1,0,0,0], where 1 at the corresponding position represents â€œlikeâ€ in the word set. Dimension of vector = |V| , where V is vocabulary set of the text. 2.3 Skip-gram neural network The neural network takes one-hot vector as input, with size |V|. Let denote one-hot vector as v for convenience There are only one hidden layer. There is no activation function in this layer and hence it is linear. The number of neurons N is defined by user. Softmax activation function for output with |V| neurons There is a input weight matrix W with dimension |V|-by-N between input layer and hidden layer (|V| rows and N columns) There is a input weight matrix W â€˜ with dimension N-by-|V| between hidden layer and output layer Since input is 0,1 vector, when it times input matrix W, it actually selects a row of the matrix.Hence, we can consider W as a look-up table and output from hidden layer c = Wv is the real â€œword vectorâ€. â€œWord vectorâ€ is acutually one-hot vector or bag-of-word vector times input weight matrix W The i^th entry in the output vector from softmax function is the possibility that if you pick up a word nearby the input word, that is the i^th word in the vocabulary. Note: when training neural network, its output is one-hot vector ( set the maximum softmax output value as 1, others as 0s), indicating the predicted nearby context words When evaluating network, using softmax output value, possibility as output, to compute the cost value __Since there are different actual context words $w_{t-1}, w_{t-2}, â€¦$, corresponding to the single input vector $w_{t}$.__If we consider P($w_{t-1},w_{t-2},w_{t-3}|w_t$) with window with size of 4 containing central word $w_t$ and context words $w_{t-1},w_{t-2},w_{t-3}$,then the output look something like this: 2.4 Evaluation of Skip-gramSince the input to the network is a single word, it is also regarded as center word $w_t$, at the t position in text. The words nearby it are called context, or outside words. The context word at t+k position, is denoted as $w_{t+k}$. Hence our goal, or objective is to estimate the distribution $P(w_{t+k}| w_{t})$.The distribution has the meaning that given center word $w_t$, the possibility that context word $w_{t+k}$ will appears. In order to estimate the distribution, we need to maximize the likelihood function, or its log value, called loss, or cost function, shown as below. Advantages It is unsupervised learning hence can work on any raw text given. It requires less memory comparing with other words to vector representations. It requires two weight matrix of dimension [N, |v|] each instead of [|v|, |v|]. And usually, N is around 300 while |v| is in millions. So, we can see the advantage of using this algorithm. Disadvantages Finding the best value for N and the context position is difficult. Softmax function is computationally expensive. The time complexity for training is high Models for Word2vector Skip-gramPredict context (outside) words (surrounding the center word) given centerword Continuous Bag of words ï¼ˆCBOWï¼‰Predict center word from (bag of) context words. It is an inverse version of skip-gram. Reference:[1] http://mccormickml.com/2016/04/19/word2vec-tutorial-the-skip-gram-model/[2] http://web.stanford.edu/class/cs224n/slides/cs224n-2020-lecture02-wordvecs2.pdf[3] https://towardsdatascience.com/skip-gram-nlp-context-words-prediction-algorithm-5bbf34f84e0c[4] https://zhuanlan.zhihu.com/p/50243702[5] http://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf","link":"/2020/07/07/NLP-Word-Representation/"},{"title":"Recommendation-System-2-WideDeep","text":"Background2016 å¹´Googleé€šè¿‡ç”¨wide&amp; Deep+ FTRL ä¼˜åŒ–å™¨å¯¹æ•°æ®ç¨€ç–æ€§sparsityå’Œç‰¹å¾ç»„åˆå­¦ä¹ çš„é—®è¿›è¡Œç ”ç©¶åŸæ–‡ï¼š In the experiments, we used Follow- the-regularized-leader (FTRL) algorithm with L1 regularization as the optimizer for the wide part of the model, and AdaGrad for the deep part. æ¥è‡ª https://zhuanlan.zhihu.com/p/142958834 Motivationç›®çš„ CTRé¢„ä¼°ä»»åŠ¡é‡Œé¢éœ€è¦ç²¾ç»†çš„ç‰¹å¾å·¥ç¨‹å¯¹ç‰¹å¾è¿›è¡Œç»„åˆä½¿æ¨¡å‹å¯¹å‡ºç°é¢‘ç‡é«˜çš„ç‰¹å¾è¿›è¡Œå­¦ä¹ ã€‚ä½†é—®é¢˜æ˜¯ç‰¹å¾å·¥ç¨‹éœ€è¦èŠ±è´¹æ—¶é—´é•¿è€Œä¸”éº»çƒ¦ å¯¹äºsparseçš„æ•°æ®è¿›è¡Œç‰¹å¾ç»„åˆè¿›è¡Œè®­ç»ƒå®¹æ˜“æ¨¡å‹è¿‡æ‹Ÿåˆï¼Œæ³›åŒ–æ€§å·®ï¼Œå› æ­¤éœ€è¦ä¸€ç§generalizationçš„æ–¹æ³•å¯¹æ•°æ®è¿›è¡Œå¤„ç† Wide&amp;Deepæ¨¡å‹å°±æ˜¯å›´ç»•è®°å¿†æ€§å’Œæ³›åŒ–æ€§è¿›è¡Œè®¨è®ºçš„ï¼Œæ¨¡å‹èƒ½å¤Ÿä»å†å²æ•°æ®ä¸­å­¦ä¹ åˆ°é«˜é¢‘å…±ç°çš„ç‰¹å¾ç»„åˆçš„èƒ½åŠ›ï¼Œç§°ä¸ºæ˜¯æ¨¡å‹çš„Memorizationã€‚èƒ½å¤Ÿåˆ©ç”¨ç‰¹å¾ä¹‹é—´çš„ä¼ é€’æ€§å»æ¢ç´¢å†å²æ•°æ®ä¸­ä»æœªå‡ºç°è¿‡çš„ç‰¹å¾ç»„åˆï¼Œç§°ä¸ºæ˜¯æ¨¡å‹çš„Generalizationã€‚Wide&amp;Deepå…¼é¡¾Memorizationä¸Generalizationå¹¶åœ¨Google Play storeçš„åœºæ™¯ä¸­æˆåŠŸè½åœ°ã€‚ ç‰¹ç‚¹ ç”¨äº†Embeddingçš„deep modelå¯¹å­¦ä¹ generalçš„featureä¸ºäº†è§£å†³sparse æ•°æ®çš„é—®é¢˜ï¼ŒGoogleæŠŠDNNï¼Œembeddingç»“åˆç”¨äºå¤„ç†sparseçš„æ•°æ®ã€‚é€šè¿‡dense embeddingçš„æ–¹æ³•æŠŠsparseçš„é«˜ç»´æ•°æ®è¿›è¡Œé™ç»´çš„åŒæ—¶ï¼Œä¹ŸæŠŠ0,1çš„sparseçš„æ•°æ®å˜æˆè¿ç»­çš„æ•°æ®ä½¿å¾—æ¢¯åº¦ä¸‹é™å­¦ä¹ çš„æ—¶å€™ä¸ä¼šå› ä¸ºæ¢¯åº¦æ¶ˆå¤±çš„é—®é¢˜è€Œå˜å¾—æ¨¡å‹éš¾ä»¥è®­ç»ƒã€‚è€Œè¿™ä¸ªæ¨¡å—ä¹Ÿæˆä¸ºdeep model ç”¨äº†wide modelå¯¹ç‰¹å¾è¿›è¡Œè‡ªåŠ¨ç»„åˆã€‚ä¸ºäº†è§£å†³ç‰¹å¾ç»„åˆçš„é—®é¢˜ï¼Œgoogleé€šè¿‡åˆ©ç”¨wide modelæ–¹æ³•ç›´æ¥æŠŠå…¶ä»–ç±»åˆ«çš„æ•°æ®è¿›è¡Œçº¿æ€§æŠ•å½±ä»è€Œè¾¾åˆ°ç‰¹å¾é€‰æ‹©çš„ä½œç”¨ã€‚å› ä¸ºçº¿æ€§æŠ•å½±çš„æ—¶å€™æ¯ä¸ªç‰¹å¾éƒ½æœ‰ä¸€ä¸ªweightè¿›è¡Œæƒè¡¡ã€‚è€Œæ¨¡å‹å­¦ä¹ çš„æ—¶å€™å°±æ˜¯æŠŠè¿™äº›weightè¿›è¡Œè°ƒæ•´æ¥é€‰æ‹©ã€‚è¿™æ ·å¯è§£é‡Šæ€§ä¹Ÿæ¯”è¾ƒå¼º è”åˆè®­ç»ƒW&amp;Dæ¨¡å‹æ˜¯å°†ä¸¤éƒ¨åˆ†è¾“å‡ºçš„ç»“æœç»“åˆèµ·æ¥è”åˆè®­ç»ƒï¼Œå°†deepå’Œwideéƒ¨åˆ†çš„è¾“å‡ºé‡æ–°ä½¿ç”¨ä¸€ä¸ªé€»è¾‘å›å½’æ¨¡å‹åšæœ€ç»ˆçš„é¢„æµ‹ï¼Œè¾“å‡ºæ¦‚ç‡å€¼ã€‚è”åˆè®­ç»ƒçš„æ•°å­¦å½¢å¼å¦‚ä¸‹ï¼šéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå› ä¸ºWideä¾§çš„æ•°æ®æ˜¯é«˜ç»´ç¨€ç–çš„ï¼Œæ‰€ä»¥ä½œè€…ä½¿ç”¨äº†FTRLç®—æ³•ä¼˜åŒ–ï¼Œè€ŒDeepä¾§ä½¿ç”¨çš„æ˜¯ Adagrad åŸç† æˆ‘ä»¬å¯ä»¥çœ‹åˆ° Wide&amp; Deep modelåŸºæœ¬å°±æ˜¯wide model å’Œdeep modelçš„è¾“å‡ºçš„ç›¸åŠ ï¼Œå†é€šè¿‡logistics æˆ–softmax(å¦‚æœæ˜¯å¤šåˆ†ç±»)ï¼Œè¾“å‡ºçš„ç»“æœæ˜¯CTR (click or not click)çš„æ¦‚ç‡ Wide modelwideéƒ¨åˆ†æ˜¯ä¸€ä¸ªå¹¿ä¹‰çš„çº¿æ€§æ¨¡å‹ï¼Œè¾“å…¥çš„ç‰¹å¾ä¸»è¦æœ‰ä¸¤éƒ¨åˆ†ç»„æˆï¼Œä¸€éƒ¨åˆ†æ˜¯åŸå§‹çš„éƒ¨åˆ†ç‰¹å¾ï¼Œå¦ä¸€éƒ¨åˆ†æ˜¯åŸå§‹ç‰¹å¾çš„äº¤å‰ç‰¹å¾(cross-product transformation)ï¼Œå¯¹äºäº¤äº’ç‰¹å¾å¯ä»¥å®šä¹‰ä¸º Deep modelDeepéƒ¨åˆ†æ˜¯ä¸€ä¸ªDNNæ¨¡å‹ï¼Œè¾“å…¥çš„ç‰¹å¾ä¸»è¦åˆ†ä¸ºä¸¤å¤§ç±»ï¼Œä¸€ç±»æ˜¯æ•°å€¼ç‰¹å¾(å¯ç›´æ¥è¾“å…¥DNN)ï¼Œä¸€ç±»æ˜¯ç±»åˆ«ç‰¹å¾(éœ€è¦ç»è¿‡Embeddingä¹‹åæ‰èƒ½è¾“å…¥åˆ°DNNä¸­)ï¼ŒDNNæ¨¡å‹éšç€å±‚æ•°çš„å¢åŠ ï¼Œä¸­é—´çš„ç‰¹å¾å°±è¶ŠæŠ½è±¡ï¼Œä¹Ÿå°±æé«˜äº†æ¨¡å‹çš„æ³›åŒ–èƒ½åŠ›ã€‚å¯¹äºDeepéƒ¨åˆ†çš„DNNæ¨¡å‹ä½œè€…ä½¿ç”¨äº†æ·±åº¦å­¦ä¹ å¸¸ç”¨çš„ä¼˜åŒ–å™¨AdaGradï¼Œè¿™ä¹Ÿæ˜¯ä¸ºäº†ä½¿å¾—æ¨¡å‹å¯ä»¥å¾—åˆ°æ›´ç²¾ç¡®çš„è§£ã€‚ W&amp;Dæ¨¡å‹æ˜¯å°†ä¸¤éƒ¨åˆ†è¾“å‡ºçš„ç»“æœç»“åˆèµ·æ¥è”åˆè®­ç»ƒï¼Œå°†deepå’Œwideéƒ¨åˆ†çš„è¾“å‡ºé‡æ–°ä½¿ç”¨ä¸€ä¸ªé€»è¾‘å›å½’æ¨¡å‹åšæœ€ç»ˆçš„é¢„æµ‹ï¼Œè¾“å‡ºæ¦‚ç‡å€¼ã€‚è”åˆè®­ç»ƒçš„æ•°å­¦å½¢å¼å¦‚ä¸‹ï¼šéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå› ä¸ºWideä¾§çš„æ•°æ®æ˜¯é«˜ç»´ç¨€ç–çš„ï¼Œæ‰€ä»¥ä½œè€…ä½¿ç”¨äº†FTRLç®—æ³•ä¼˜åŒ–ï¼Œè€ŒDeepä¾§ä½¿ç”¨çš„æ˜¯ Adagrad ä¼˜ç¼ºç‚¹ ä¼˜ç‚¹ é€šè¿‡ç»“åˆwideå’Œdeep modelåŒæ—¶è§£å†³sparse dataå’Œmemorizationï¼Œ generalizationçš„é—®é¢˜ ä¸ç”¨ç‰¹æ„äººå·¥é€‰æ‹©ç‰¹å¾è¿›è¡Œç»„åˆ æ•°æ®ç‰¹å¾å¯ä»¥é€šè¿‡embeddingæ–¹å¼é™ç»´é™ä½å‚æ•°çš„æ•°ç›® ç¼ºç‚¹ å¯èƒ½éœ€è¦è€ƒè™‘æŠŠå“ªäº›ç‰¹å¾æ”¾åˆ°deep modelå“ªäº›æ”¾åˆ°wide model éœ€è¦é€šè¿‡è”åˆè®­ç»ƒæ–¹å¼å¯¹ä¸åŒæ¨¡å‹ä¼˜åŒ–6. æ€è€ƒ åœ¨ä½ çš„åº”ç”¨åœºæ™¯ä¸­ï¼Œå“ªäº›ç‰¹å¾é€‚åˆæ”¾åœ¨Wideä¾§ï¼Œå“ªäº›ç‰¹å¾é€‚åˆæ”¾åœ¨Deepä¾§ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿä¸ªäººè®¤ä¸ºcategoricalçš„æ•°æ®å¦‚æœdistinctçš„valueå¾ˆå¤šçš„featureåº”è¯¥ç”¨äºdeep modelï¼Œæ¯”å¦‚è¯´åƒç”µå½±ç±»åˆ«idçš„ç‰¹å¾ï¼Œæˆ–è€…ç”¨æˆ·åœ°å€ï¼Œå¦‚æœç»†åˆ†çš„è¯ä¼šæœ‰ä¸Šç™¾ä¸ªvalueï¼Œè€Œæ¯ä¸ªvalueè¿™æ ·éœ€è¦one-hotæ¥è¡¨ç¤ºçš„è¯å°±ä¼šå˜å¾—å¾ˆå¤§è¿™æ ·éœ€è¦deep modelçš„embeddingè¿›è¡Œé™ç»´ã€‚ è€Œå¦‚æœvalueä¸ªæ•°ä¸å¤šçš„categorical featureï¼Œæ¯”å¦‚æ€§åˆ«ï¼Œåˆæˆ–è€…è¿ç»­æ•°æ®ï¼Œæ¯”å¦‚å¹´é¾„ï¼Œå¯ä»¥é€šè¿‡wideçš„ modelè¿›è¡Œå¤„ç†ã€‚ä¸è¿‡æ„Ÿè§‰ä¹Ÿå¯ä»¥æ”¾åˆ°deep modelé‡Œé¢ ä¸ºä»€ä¹ˆWideéƒ¨åˆ†è¦ç”¨L1 FTRLè®­ç»ƒï¼ŸWide model ç”¨L1 - FTRL çš„ä¼˜åŒ–å™¨ä¸»è¦åŸå› æ˜¯ L1-FTRL åœ¨ç»“åˆL1-FOBOS å’Œ L1-RDAçš„ä¼˜åŒ–æ–¹æ³•åå†æ¢¯åº¦ä¸‹é™æœ‰è¾ƒé«˜çš„ç²¾åº¦åŒæ—¶ï¼Œä¹Ÿèƒ½äº§ç”Ÿç¨€ç–æ€§è¿›è¡Œç‰¹å¾çš„ç­›é€‰ï¼Œè€Œè¿™ä¸ªåœ¨wide-modelé‡Œæœ‰åˆ©äºwide modeé€šè¿‡weightçš„ç¨€ç–æ€§è¿›è¡Œç‰¹å¾ç»„åˆå’Œé€‰æ‹©ã€‚æ¯”å¦‚è¯´é€šè¿‡L1-FTRL æˆ‘ä»¬å¯ä»¥æŠŠ y=w1x1 +w2x2 +w3x3 é‡Œé¢çš„w1ï¼Œ w2çš„weighté™åˆ°æ¥è¿‘0ä»è€Œè¾¾åˆ°æ’é™¤ç‰¹å¾x1å’Œx2 è€Œé€‰æ‹©x3çš„æ•ˆæœ ä¸ºä»€ä¹ˆDeepéƒ¨åˆ†ä¸ç‰¹åˆ«è€ƒè™‘ç¨€ç–æ€§çš„é—®é¢˜ï¼ŸDeep model ä¹‹æ‰€ä»¥ä¸ç”¨å¤ªè€ƒè™‘äº†ç¨€ç–æ€§æ˜¯å› ä¸ºembeddingå·²ç»æŠŠç¨€ç–çš„ç‰¹å¾è¿›è¡Œé™ç»´æˆdenseçš„vectorï¼Œè€Œå¯¹äºæœ¬æ¥å°±ä¸sparseçš„featureå¦‚å¹´é¾„ä¹Ÿå°±æ›´åŠ ä¸ç”¨è€ƒè™‘ç¨€ç–æ€§äº† Future work æœ‰æ²¡æœ‰å¯ä»¥ä¸ç”¨ä¸“é—¨åˆ†å¼€ä¸¤ç§è®­ç»ƒæ–¹æ³•ï¼Œæ›´åŠ generalçš„è®­ç»ƒæ–¹æ³•å¯¹ä¸åŒçš„æ¨¡å‹è¿›è¡Œè®­ç»ƒä½†ä¸ä¼šå½±å“æ•ˆæœï¼Ÿ èƒ½ä¸èƒ½ä¸ä¸“é—¨è€ƒè™‘ä»€ä¹ˆfeatureè¦æ”¾åˆ°deep modelä»€ä¹ˆfeatureæ”¾åˆ°wide modelè¾¾åˆ°æ›´å¥½çš„è‡ªåŠ¨åŒ–ç‰¹å¾é€‰æ‹©çš„æ•ˆæœï¼Ÿ Reference[1] https://github.com/datawhalechina/team-learning-rs/blob/master/DeepRecommendationModel/Wide%26Deep.md [2] https://zhuanlan.zhihu.com/p/142958834","link":"/2021/03/18/Recommendation-System-2-WideDeep/"},{"title":"Markdown Quick Tutorial","text":"Source File For this tutorial: Click Here Example 1: Markdown Code: 123456_Italic_ *Italic* __Bold__ **Bold**&lt;span style=\"color:blue\"&gt;Blue&lt;/span&gt;_&lt;span style=\"color:red\"&gt;Red and Italic&lt;/span&gt;____&lt;span style=\"color:red\"&gt;Red and Italic and Bold&lt;/span&gt;___**_&lt;span style=\"color:red\"&gt;Red and Italic and Bold&lt;/span&gt;_** Output: Italic ItalicBold BoldBlueRed and ItalicRed and Italic and BoldRed and Italic and Bold Example 2:Markdown Code: 123456789~~Strickout~~&lt;u&gt;Underline&lt;/u&gt;åˆ›å»ºè„šæ³¨æ ¼å¼ç±»ä¼¼è¿™æ · [^Footnote]ã€‚[^Footnote]: Here is footnoteoutput \"*\" \\* \\_ Output StrickoutUnderline åˆ›å»ºè„šæ³¨æ ¼å¼ç±»ä¼¼è¿™æ · [^Footnote]ã€‚ [^Footnote]: Here is footnote output â€œâ€œ \\ _ Example 3Markdown Code: 12345678910111213141516__Here is check list__- [ ] my- [ ] check- [x] list__Here is Emoji__:blush::smile::angry::cry::joy: &gt;Block&gt;1. Block 1&gt;2. Blokc 2 Output Here is check list my check list Here is Emoji:blush::smile::angry::cry::joy: Block Block 1 Blokc 2 Example 4Here is code function() 1Code Block 1int text= C Code Block Col1 Col2 Col3 a b c å·¦å¯¹é½(left) å±…ä¸­(center) å³å¯¹é½(right) é»˜è®¤å·¦å¯¹é½(default) a b c d list 1 list 2 list 3 list 1 list 2 list 3 Example 5Markdown Code: 1234567891011121314151617181920&lt;image src=\"https://gst-online.com/wp-content/uploads/2018/07/16679084-abstract-word-cloud-for-representation-with-related-tags-and-terms.jpg\"&gt;[Here is a link](https://google.com/)[1]: http://static.runoob.com/images/runoob-logo.png&lt;h1&gt;Embeded HTML&lt;/h1&gt;&lt;h2&gt;Hearder&lt;/h2&gt;&lt;h3&gt;Hearder&lt;/h3&gt;ä½¿ç”¨ &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; é‡å¯ç”µè„‘## math formulaï¼š Need to be loaded on browser$$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\\\end{vmatrix}${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}$$ Output Here is a link[1]: http://static.runoob.com/images/runoob-logo.png Embeded HTML Hearder Hearder ä½¿ç”¨ Ctrl+Alt+Del é‡å¯ç”µè„‘ math formulaï¼š Need to be loaded on browser$$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}$$ Hello","link":"/2020/07/08/Markdown-Tutorial/"},{"title":"NLP Improvement on Word2Vector","text":"IntroductionAlthough word2Vec for word embedding has been widely used, it has some obvious shortages that affect computation of word vector. This passage is to identify those shortages and introduce a solution called Negative Sampling to solve the problems. Review to Word2VecWord2Vec is a framework to convert vocabulary in texts into dense numeric vector representation such that our machine learning models can realize the vocabulary and human language and learn something.The main idea of word2Vec (skip-gram) is following: Start with random word vectors in neural network Iterate each world in word corpus Predict the context words (surrounding words) of a center word by computing posterior distribution: $P(w_{t+1}|w_t)$, where $w_t$ is the center word at position t and $w_{t+1}$ is the surrounding word. $$P(o|c) = \\frac{exp(\\textbf{u}_o^T\\textbf{v}c )}{\\sum{w\\in V} exp(\\textbf{u}_w^T\\textbf{v}_c)}$$ where $\\textbf{v}_c$ is the word vector of center word and $\\textbf{u}_o$ is the word vector of surrounding words (or weights). Update word vector using Gradient Descent based on cost function Note: $\\theta$ in loss function here is the weight matrix used in softmax. The weight matrix in the network is $\\textbf{u}_w$. Disadvantages of Word2VectorWe can notice that bigger vocabulary it is, larger the word vector becomes. Usually, there are thousands of different words in text, using gradient descent to update the whole weight matrix leads to expensive computation cost and each update become super slow. We need to repeat updating each weight using the following equation and the time complexity increases linearly as the amount of words increases. ImprovementStochastic Gradient Descent with sampled windowAssume we are using a window centered at center word and hence it has size of 2m+1. The the update is Repeatedly sample windows and iterate each window, rather than iterate all windows. Compute the gradient of the words that actually appear. The graident of words in dictionary that donâ€™t appear in text wonâ€™t be updated. Notes: the gradient of the words that donâ€™t appear in text, but in vector is all 0. In this case the vector would be very sparse (many zeros in vectors). It is a waste of time to compute those 0 update. We need a sampling technique to sample windows and words for updating part of weights. This leads to our next section Negative Sampling Negtive SamplingIn word2vec (skip-gram), the input to the neural network is one-hot word vector of the center word. In training step, output of neural network is a vector of possibility that each word can appear given the center word.In prediction step, the output is converted from possibility vector to one-hot vectors of the predcited context words that are most likely to appear given the center word. For example, if we have possibility output [0.1, 0.1, 0.5, 0.3] and expect predictions of 2 context words. Then we output one-hot vectors of the words with possibility of 0.5 and 0.3.The targets corresponding to the given center word are one-hot vector of context words surrounding this center word in the window. Negative wordsIn one-hot vector output from neural network, we call the word with value equal to 1 as postive word and those words with values equal to 0 as negative word. For example. Assume we have a word vector with dimension of 100 (100 words in dictionary). Then in a window such as â€œI like my dogâ€, I like my dog if â€œlikeâ€ is center word $w_t$, as the input to the neural network. Then â€œIâ€ , â€œmyâ€, â€œdogâ€ are context words, or positive words that are expected to output â€œ1â€ in the output one-hot vector of neural network(it is expected to output 3 one-hot vectors). Then other words that donâ€™t appear in this window / context and are expected to be 0 in one-hot vector are negative words. Selection of negative wordsHowever, there would be a large amount of negative words that donâ€™t appear in context. If we update weights of all negative words, the update could be very inefficient.In negative sampling, we sample negative words based on the possiblity that word may occur. The possibility is given by: $$P(w_i)= \\frac{f(w_i)}{\\sum_j^Nf(w_j)}$$ where $f(w_i)$ is the number of word $w_i$ appears in corpus and the denominator is the number of all words appear/ the amount of words in corpus. However, the author proposes this equation since it gives the best performance. $$P(w_i)= \\frac{f(w_i)^{3/4}}{\\sum_j^Nf(w_j)^{3/4}}$$ Based on the possibility of the occurence of words, we can sample a number of negative words that are most likely to appear and update the corresponding weights by backward update in neural network. The number of samples is set by user.For example, If we have a dictionary with size of 100 words (hence one-hot vector with size of 100) and each word has corresponding weights with size of 100. Then there are 100x100 weights to update when updating all weights in network. However, if we only sample 20 negative words to update, we need to update 20x100 weights only. This allows us to speed up training step. References[1] http://mccormickml.com/2017/01/11/word2vec-tutorial-part-2-negative-sampling/ [2] https://arxiv.org/pdf/1310.4546.pdf","link":"/2020/07/29/NLP-Word2Vec-Improvement/"},{"title":"Recommendation-System-5-DIN","text":"Introductionåœ¨è¿‡å»çš„DeepCrossing, Wide&amp;Deep, DeepFMï¼Œ NFMç­‰æ¨¡å‹é‡Œé¢ï¼Œè¿™äº›æ¨¡å‹éƒ½æ˜¯é€šè¿‡æŠŠsparse featureå˜æˆembeddingçš„vectorï¼Œç„¶åæŠŠdenseçš„vectorsè¿›è¡Œç‰¹å¾äº¤å‰(feature intersection) ä»è€Œå­¦ä¹ ä½é˜¶å’Œæ›´åŠ é«˜é˜¶çš„ç‰¹å¾ã€‚Embeding&amp;MLPæ¨¡å‹å¯¹äºè¿™ç§æ¨èä»»åŠ¡ä¸€èˆ¬æœ‰ç€å·®ä¸å¤šçš„å›ºå®šå¤„ç†å¥—è·¯ï¼Œå°±æ˜¯å¤§é‡ç¨€ç–ç‰¹å¾å…ˆç»è¿‡embeddingå±‚ï¼Œ è½¬æˆä½ç»´ç¨ å¯†çš„ï¼Œç„¶åè¿›è¡Œæ‹¼æ¥ï¼Œæœ€åå–‚å…¥åˆ°å¤šå±‚ç¥ç»ç½‘ç»œä¸­å»ã€‚ ç„¶è€Œï¼Œè¿™äº›æ¨¡å‹éƒ½æ˜¯åªè€ƒè™‘ç°æœ‰çš„ç‰¹å¾è¿›è¡Œäº¤å‰å­¦ä¹ ï¼Œè€Œæ²¡æœ‰è€ƒè™‘ç”¨æˆ·çš„å†å²ä¿¡æ¯å’Œè¿‡å»çš„è¡Œä¸ºä¿¡æ¯ï¼Œæ²¡æœ‰ä»æ—¶é—´çš„è§’åº¦è€ƒè™‘ç”¨æˆ·çš„è¡Œä¸ºå˜åŒ–ã€‚è€Œå¯¹äºå†å²è¡Œä¸ºä¿¡æ¯æŒ–æ˜çš„é—®é¢˜ï¼Œåˆæœ‰å¾ˆå¤šä¸åŒçš„æ¨¡å‹ï¼Œæ¯”å¦‚ç”¨äºæ¨èç³»ç»Ÿçš„GNNå›¾ç¥ç»ç½‘ç»œï¼Œ DIN ï¼ˆdeep interest networkï¼‰ç­‰ã€‚ è€Œè¿™æ¬¡è¦ä»‹ç»çš„æ˜¯Deep Interest Network(DIIN)æ¨¡å‹ï¼Œå®ƒæ˜¯2018å¹´é˜¿é‡Œå·´å·´æå‡ºæ¥çš„æ¨¡å‹ï¼Œ è¯¥æ¨¡å‹åŸºäºä¸šåŠ¡çš„è§‚å¯Ÿï¼Œä»å®é™…åº”ç”¨çš„è§’åº¦è¿›è¡Œæ”¹è¿›ï¼Œç›¸æ¯”äºä¹‹å‰å¾ˆå¤šâ€œå­¦æœ¯é£â€çš„æ·±åº¦æ¨¡å‹ï¼Œ è¯¥æ¨¡å‹æ›´åŠ å…·æœ‰ä¸šåŠ¡æ°”æ¯ã€‚ MotivationDIN æ¨¡å‹çš„åº”ç”¨åœºæ™¯æ˜¯é˜¿é‡Œå·´å·´çš„ç”µå•†å¹¿å‘Šæ¨èä¸šåŠ¡ï¼Œ è¿™æ ·çš„åœºæ™¯ä¸‹ä¸€èˆ¬ä¼šæœ‰å¤§é‡çš„ç”¨æˆ·å†å²è¡Œä¸ºä¿¡æ¯ï¼Œ è¿™ä¸ªå…¶å®æ˜¯å¾ˆå…³é”®çš„ã€‚å› è€ŒDINä¸ºäº†è§£å†³è¿™ä¸ªä¸šåŠ¡åœºæ™¯æœ‰ä¸€äº›ç‰¹ç‚¹ï¼š Assumption:DIN å‡è®¾äº†åº”ç”¨åœºæ™¯é‡Œé¢æœ‰å¤§é‡çš„ç”¨æˆ·çš„å†å²ä¿¡æ¯ï¼Œè€Œè¿™äº›ä¿¡æ¯èƒ½å¤Ÿæä¾›ç”¨æˆ·çš„å…´è¶£å’Œçˆ±å¥½ä»¥åŠè´­ä¹°/æµè§ˆç­‰è¡Œä¸ºçš„å˜åŒ–ã€‚è€ŒDINä¸»è¦æ˜¯å…³æ³¨å’Œåˆ©ç”¨è¿™äº›å†å²ä¿¡æ¯è¿›è¡Œä¿¡æ¯çš„æŒ–æ˜ Novelty:åŸºäºDINçš„assumptionä¸‹ï¼ŒDINæ¨¡å‹çš„åˆ›æ–°ç‚¹æˆ–è€…è§£å†³çš„é—®é¢˜å°±æ˜¯ä½¿ç”¨äº†æ³¨æ„åŠ›æœºåˆ¶æ¥å¯¹ç”¨æˆ·çš„å…´è¶£åŠ¨æ€æ¨¡æ‹Ÿï¼Œ è¿™æ ·å°±èƒ½çŒœæµ‹å‡ºç”¨æˆ·çš„å¤§è‡´å…´è¶£æ¥ï¼Œè¿™æ ·æˆ‘ä»¬çš„æ¨èæ‰èƒ½åšçš„æ›´åŠ åˆ°ä½ï¼Œæ‰€ä»¥è¿™ä¸ªæ¨¡å‹çš„ä½¿ç”¨åœºæ™¯æ˜¯éå¸¸æ³¨é‡ç”¨æˆ·çš„å†å²è¡Œä¸ºç‰¹å¾ï¼ˆå†å²è´­ä¹°è¿‡çš„å•†å“æˆ–è€…ç±»åˆ«ä¿¡æ¯ï¼‰ã€‚è€Œå’Œä¹‹å‰å­¦ä¹ çš„DeepFM, wide&amp;deepç­‰æ¨¡å‹ç›¸æ¯”ï¼Œä¹‹å‰çš„æ¨¡å‹éƒ½æ²¡æœ‰è€ƒè™‘å†å²ä¿¡æ¯çš„é—®é¢˜ã€‚ Deep Interest Network (DIN)ç”±äºDINè€ƒè™‘äº†ç”¨æˆ·çš„å†å²æµè§ˆè¡Œä¸ºç‰¹å¾ï¼Œåœ¨è¾“å…¥çš„ç‰¹å¾è¡¨è¾¾é‡Œé¢å’Œè¿‡å»çš„æ¨¡å‹æœ‰å‡ºå…¥ï¼Œæ‰€ä»¥è¿™ä¸ªéƒ¨åˆ†å…ˆè€ƒè™‘è¾“å…¥ç‰¹å¾çš„è¡¨è¾¾ä¹‹åè€ƒè™‘DINçš„ç½‘ç»œæ¶æ„ DIN çš„ç‰¹å¾è¡¨è¾¾ ï¼ˆfeature representationï¼‰åœ¨è¿‡å»çš„DeepFMå’ŒNeuralFMé‡Œé¢å®ƒä»¬çš„ç‰¹å¾äº¤å‰çš„æ–¹å¼éƒ½ä»¥ä¸‹çš„å½¢å¼ï¼Œè¦ä¹ˆç›´æ¥é€šè¿‡embeddingæŠ•æ˜ ç„¶åå°†ç‰¹å¾è¿›è¡Œç›´æ¥äº¤å‰ï¼Œè¦ä¹ˆç”¨ç¥ç»ç½‘ç»œæŠŠç‰¹å¾é€šè¿‡DNNçš„æ–¹å¼è¿›è¡Œé«˜é˜¶ç‰¹å¾å­¦ä¹  è€Œè¿™äº›è¾“å…¥çš„$x_i$çš„ç‰¹å¾æ˜¯sparseçš„one-hot vectoré‡Œé¢è¦ä¹ˆæ˜¯1 è¡¨æ˜æŸä¸ªç‰¹å¾æœ‰å‡ºç°ï¼Œè¦ä¹ˆ0 è¡¨ç¤ºæ²¡å‡ºç°ã€‚ Multi-one-hotä½†æ˜¯åœ¨è€ƒè™‘åˆ°ç”¨æˆ·å†å²è¡Œä¸ºé‡Œé¢ï¼Œç”¨ä¸€ä¸ªfeatureæ¥ä»£è¡¨ç”¨æˆ·çš„å†å²æµè§ˆçš„itemæ—¶ï¼Œå®ƒçš„å¯ä»¥åƒå˜ä¸‡åŒ–å¹¶ä¸”ä¹Ÿæœ‰å¾ˆå¤šæ•°é‡çš„é•¿åº¦ä¸ç¡®å®šã€‚ä¸¾ä¸ªä¾‹å­ï¼šè¾“å…¥çš„ç‰¹å¾æ˜¯ [age =18, gender = Female, product_cat = book, visited_cat_ids = {book, bag, computer, paper}ï¼Œvisited_shop_id={TV,movie} ], é‚£ä¹ˆè¿™é‡Œçš„ visited_cat_ids è¿™ä¸ªlistå°±æ˜¯è¿‡å»çœ‹è¿‡çš„itemçš„historyã€‚è€Œè¿™ä¸ªlistæ ¹æ®ç”¨æˆ·ä¸åŒçš„æµè§ˆå†å²ï¼Œå®ƒçš„é•¿åº¦å’Œitemçš„å€¼ä¹Ÿæ˜¯ä¸ä¸€æ ·çš„ã€‚å¦‚æœç›´æ¥æŠŠè¿™ä¸ªfeatureå˜æˆone-hotæ˜¯éš¾ä»¥è¡¨è¾¾çš„å› ä¸ºone-hoté‡Œé¢åªèƒ½æœ‰ä¸€ä¸ª1ä»£è¡¨æœ‰æµè§ˆæŸä¸€ä¸ªitemï¼Œä½†æ˜¯ä¸èƒ½ä»£è¡¨å¤šä¸ªã€‚ é¢å¯¹è¿™ä¸ªé—®é¢˜DINçš„å¤„ç†æ–¹æ³•æ˜¯å°†æ•°æ®é›†é‡Œé¢çš„æ‰€æœ‰çš„visitè¿‡çš„itemsè¿›è¡Œåˆå¹¶æˆä¸€ä¸ªé›†åˆï¼Œç„¶åå¯¹è¿™ä¸ªé›†åˆå˜æˆä¸€ä¸ªmulti-onehotçš„vectorç”¨æ¥è¡¨ç¤ºç”¨æˆ·å†å²æµè§ˆè¿‡çš„å¤šä¸ªitemã€‚ è€Œæ¯ä¸ªæµè§ˆè¿‡çš„itemå¯ä»¥é€šè¿‡embeddingæ–¹æ³•å˜æˆå¯¹åº”çš„dense vectorï¼Œè¿™æ ·å°±èƒ½å¾—åˆ°å¤šä¸ªembedding vectorã€‚è€Œembedding vectorçš„ä¸ªæ•°ä¹Ÿä¼šå› ä¸ºæ¯ä¸ªç”¨æˆ·æµè§ˆçš„å†å²çš„itemä¸ªæ•°ä¸åŒè€Œä¸åŒã€‚ å¯¹multi-onehot ä¸¾ä¸ªä¾‹å­å°±åƒä¹‹å‰çš„NFMçš„ç»“æ„ä¸€æ ·ï¼Œè¾“å…¥çš„sparse vectoré‡Œé¢æœ‰å¤šä¸ª1ï¼Œè€Œæ¯ä¸ª1ä»£è¡¨æµè§ˆè¿‡çš„itemï¼Œæ¯”å¦‚ä¸€ä¸ªmulti-onhotçš„vectoré‡Œé¢æœ‰10ä¸ªitemå› æ­¤vectorçš„é•¿åº¦ æ˜¯10ï¼Œè€Œ vectoræ¯ä¸ªscalar valueå¯¹åº”ä¸€ä¸ªitemï¼Œå¦‚æœè¿™ä¸ªvalue=1é‚£ä¹ˆè¿™ä¸ªitemå°±æ˜¯æµè§ˆè¿‡çš„ã€‚æ¯”å¦‚ visited_cat_ids = {book, bag, computer, paper}é‚£ä¹ˆå¯¹åº”book, bag, computer, paperçš„4ä¸ªitemå¯¹åº”ä½ç½®çš„scalar valueå°±æ˜¯1ï¼Œå…¶ä»–ä½ç½®çš„valueå°±æ˜¯0ã€‚ Pooling for embedding vectorsé‚£ä¹ˆé—®é¢˜åˆæ¥äº†ï¼Œæ¯ä¸ªç”¨æˆ·çš„embeddingçš„vectorçš„ä¸ªæ•°ä¸ä¸€æ ·ï¼Œä½†DNNçš„è¾“å…¥çš„shapeæ˜¯å›ºå®šçš„ï¼Œæ€ä¹ˆæ‰èƒ½æŠŠä»–ä»¬è¿™äº›ä¸åŒæ•°ç›®çš„embeddingçš„vectorså˜æˆç›¸åŒå¤§å°çš„ç‰¹å¾? æ–¹æ³•å°±æ˜¯poolingï¼ŒæŠŠå¤šå‡ºæ¥çš„vectorsé€šè¿‡poolingçš„æ–¹æ³•è¿›è¡Œconcate æ‹¼æ¥çš„æ–¹æ³•ï¼Œå½¢æˆä¸€ä¸ªå›ºå®šå¤§å°çš„DNNçš„è¾“å…¥è¡¨è¾¾å½¢å¼ï¼Œå¦‚æœæœ‰è¿ç»­çš„feature valueä¹ŸæŠŠå®ƒçš„embeddingæ‹¼æ¥ä¸Šå»ï¼Œå®ƒçš„å…¬å¼æ˜¯$$ e_i=pooling(e_{i1}, e_{i2}, â€¦e_{ik})$$ è¿™é‡Œçš„$i$è¡¨ç¤ºç¬¬$i$ä¸ªå†å²ç‰¹å¾ç»„(æ˜¯å†å²è¡Œä¸ºï¼Œæ¯”å¦‚å†å²çš„å•†å“idï¼Œå†å²çš„å•†å“ç±»åˆ«idç­‰ï¼Œ è¿™äº›ç‰¹å¾ç»„éƒ½æ˜¯é€šè¿‡multi-onehot æ¥è¡¨ç¤º)ï¼Œ è¿™é‡Œçš„$k$è¡¨ç¤ºå¯¹åº”å†å²ç‰¹ç§ç»„é‡Œé¢ç”¨æˆ·è´­ä¹°è¿‡çš„å•†å“æ•°é‡ï¼Œä¹Ÿå°±æ˜¯å†å²embeddingçš„æ•°é‡ã€‚ ç‰¹å¾è¡¨è¾¾çš„å°æ€»ç»“ Denseå‹ç‰¹å¾: ç”±äºæ˜¯æ•°å€¼å‹äº†ï¼Œè¿™é‡Œä¸ºæ¯ä¸ªè¿™æ ·çš„ç‰¹å¾å»ºç«‹Inputå±‚æ¥æ”¶è¿™ç§è¾“å…¥ï¼Œ ç„¶åæ‹¼æ¥èµ·æ¥å…ˆæ”¾ç€ï¼Œç­‰ç¦»æ•£çš„é‚£è¾¹å¤„ç†å¥½ä¹‹åï¼Œå’Œç¦»æ•£çš„æ‹¼æ¥èµ·æ¥è¿›DNN Sparseå‹ç‰¹å¾: ä¸ºç¦»æ•£å‹ç‰¹å¾å»ºç«‹Inputå±‚æ¥æ”¶è¾“å…¥ï¼Œç„¶åéœ€è¦å…ˆé€šè¿‡embeddingå±‚è½¬æˆä½ç»´ç¨ å¯†å‘é‡ï¼Œç„¶åæ‹¼æ¥èµ·æ¥æ”¾ç€ï¼Œç­‰å˜é•¿ç¦»æ•£é‚£è¾¹å¤„ç†å¥½ä¹‹åï¼Œ ä¸€å—æ‹¼èµ·æ¥è¿›DNNï¼Œ ä½†æ˜¯è¿™é‡Œé¢è¦æ³¨æ„æœ‰ä¸ªç‰¹å¾çš„embeddingå‘é‡è¿˜å¾—æ‹¿å‡ºæ¥ç”¨ï¼ˆå¹¿å‘Šå•†å“çš„embeddingï¼‰ï¼Œå°±æ˜¯å€™é€‰å•†å“çš„embeddingå‘é‡ï¼Œè¿™ä¸ªè¿˜å¾—å’Œåé¢çš„è®¡ç®—ç›¸å…³æ€§ï¼Œå¯¹å†å²è¡Œä¸ºåºåˆ—åŠ æƒã€‚ VarlenSparseå‹ç‰¹å¾: è¿™ä¸ªä¸€èˆ¬æŒ‡çš„ç”¨æˆ·çš„å†å²è¡Œä¸ºç‰¹å¾ï¼Œå˜é•¿æ•°æ®ï¼Œ é¦–å…ˆä¼šè¿›è¡Œpaddingæ“ä½œæˆç­‰é•¿ï¼Œ ç„¶åå»ºç«‹Inputå±‚æ¥æ”¶è¾“å…¥ï¼Œç„¶åé€šè¿‡embeddingå±‚å¾—åˆ°å„è‡ªå†å²è¡Œä¸ºçš„embeddingå‘é‡ï¼Œ æ‹¿ç€è¿™äº›å‘é‡ä¸ä¸Šé¢çš„å€™é€‰å•†å“embeddingå‘é‡è¿›å…¥+ AttentionPoolingLayerå»å¯¹è¿™äº›å†å²è¡Œä¸ºç‰¹å¾åŠ æƒåˆå¹¶ï¼Œæœ€åå¾—åˆ°è¾“å‡ºã€‚ DIN ç½‘ç»œç»“æ„DIN Base model: DIN çš„æ”¹è¿›ç»“æ„å¦‚ä¸‹ï¼š Embedding layerï¼šè¿™ä¸ªå±‚çš„ä½œç”¨æ˜¯æŠŠé«˜ç»´ç¨€ç–çš„è¾“å…¥è½¬æˆä½ç»´ç¨ å¯†å‘é‡ï¼Œ æ¯ä¸ªç¦»æ•£ç‰¹å¾ä¸‹é¢éƒ½ä¼šå¯¹åº”ç€ä¸€ä¸ªembeddingè¯å…¸ï¼Œ ç»´åº¦æ˜¯$D\\times K$ï¼Œ è¿™é‡Œçš„$D$è¡¨ç¤ºçš„æ˜¯éšå‘é‡çš„ç»´åº¦ï¼Œ è€Œ$K$è¡¨ç¤ºçš„æ˜¯å½“å‰ç¦»æ•£ç‰¹å¾çš„å”¯ä¸€å–å€¼ä¸ªæ•°ã€‚ å…¶ä»–ç¦»æ•£ç‰¹å¾ä¹Ÿæ˜¯åŒç†ï¼Œåªä¸è¿‡ä¸Šé¢é‚£ä¸ªmulti-hotç¼–ç çš„é‚£ä¸ªï¼Œä¼šå¾—åˆ°ä¸€ä¸ªembeddingå‘é‡çš„åˆ—è¡¨ï¼Œå› ä¸ºä»–å¼€å§‹çš„é‚£ä¸ªmulti-hotå‘é‡ä¸æ­¢æœ‰ä¸€ä¸ªæ˜¯1ï¼Œè¿™æ ·ä¹˜ä»¥embeddingçŸ©é˜µï¼Œå°±ä¼šå¾—åˆ°ä¸€ä¸ªåˆ—è¡¨äº†ã€‚é€šè¿‡è¿™ä¸ªå±‚ï¼Œä¸Šé¢çš„è¾“å…¥ç‰¹å¾éƒ½å¯ä»¥æ‹¿åˆ°ç›¸åº”çš„ç¨ å¯†embeddingå‘é‡äº†ã€‚ pooling layer and Concat layerï¼š poolingå±‚çš„ä½œç”¨æ˜¯å°†ç”¨æˆ·çš„å†å²è¡Œä¸ºembeddingè¿™ä¸ªæœ€ç»ˆå˜æˆä¸€ä¸ªå®šé•¿çš„å‘é‡ï¼Œå› ä¸ºæ¯ä¸ªç”¨æˆ·å†å²è´­ä¹°çš„å•†å“æ•°æ˜¯ä¸ä¸€æ ·çš„ï¼Œ ä¹Ÿå°±æ˜¯æ¯ä¸ªç”¨æˆ·multi-hotä¸­1çš„ä¸ªæ•°ä¸ä¸€è‡´ï¼Œè¿™æ ·ç»è¿‡embeddingå±‚ï¼Œå¾—åˆ°çš„ç”¨æˆ·å†å²è¡Œä¸ºembeddingçš„ä¸ªæ•°ä¸ä¸€æ ·å¤šï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„embeddingåˆ—è¡¨ä¸ä¸€æ ·é•¿ï¼Œ é‚£ä¹ˆè¿™æ ·çš„è¯ï¼Œæ¯ä¸ªç”¨æˆ·çš„å†å²è¡Œä¸ºç‰¹å¾æ‹¼èµ·æ¥å°±ä¸ä¸€æ ·é•¿äº†ã€‚ è€Œåé¢å¦‚æœåŠ å…¨è¿æ¥ç½‘ç»œçš„è¯ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œä»–éœ€è¦å®šé•¿çš„ç‰¹å¾è¾“å…¥ã€‚ æ‰€ä»¥å¾€å¾€ç”¨ä¸€ä¸ªpooling layerå…ˆæŠŠç”¨æˆ·å†å²è¡Œä¸ºembeddingå˜æˆå›ºå®šé•¿åº¦(ç»Ÿä¸€é•¿åº¦)ï¼Œå°±åƒä¹‹å‰æ‰€è¯´çš„poolingçš„å…¬å¼ä¸€æ ·ã€‚æˆ‘ä»¬å¯ä»¥è€ƒçš„ä¸Šé¢çš„å›¾ç‰‡é‡Œé¢Goods1çš„å„ä¸ªçºµå‘çš„embedding vectoråœ¨é€šè¿‡Concatä¹‹åå˜æˆå•ä¸ªæ¨ªå‘çš„vectorï¼Œè€Œæ¨ªå‘çš„vectoré‡Œé¢çš„é¢œè‰²å¯¹åº”ä¹‹å‰çš„embeddingçš„vectorï¼Œä½†æ˜¯é•¿åº¦å˜å°äº†ï¼Œè¿™ä¸ªæ˜¯å› ä¸ºç”¨äº†poolingçš„åŸå› ã€‚Concat layerå±‚çš„ä½œç”¨å°±æ˜¯æ‹¼æ¥äº†ï¼Œå°±æ˜¯æŠŠè¿™æ‰€æœ‰çš„ç‰¹å¾embeddingå‘é‡ï¼Œå¦‚æœå†æœ‰è¿ç»­ç‰¹å¾çš„è¯ä¹Ÿç®—ä¸Šï¼Œä»ç‰¹å¾ç»´åº¦æ‹¼æ¥æ•´åˆï¼Œä½œä¸ºMLPçš„è¾“å…¥ã€‚ MLPï¼šè¿™ä¸ªå°±æ˜¯æ™®é€šçš„å…¨è¿æ¥ï¼Œç”¨äº†å­¦ä¹ ç‰¹å¾ä¹‹é—´çš„å„ç§äº¤äº’ã€‚ Loss: ç”±äºè¿™é‡Œæ˜¯ç‚¹å‡»ç‡é¢„æµ‹ä»»åŠ¡ï¼Œ äºŒåˆ†ç±»çš„é—®é¢˜ï¼Œæ‰€ä»¥è¿™é‡Œçš„æŸå¤±å‡½æ•°ç”¨çš„è´Ÿçš„logå¯¹æ•°ä¼¼ç„¶ï¼š$$L=-\\frac{1}{N} \\sum_{(\\boldsymbol{x}, y) \\in S}(y \\log p(\\boldsymbol{x})+(1-y) \\log (1-p(\\boldsymbol{x})))$$ è¿™é‡Œæ”¹è¿›çš„åœ°æ–¹å·²ç»æ¡†å‡ºæ¥äº†ï¼Œè¿™é‡Œä¼šå‘ç°ç›¸æ¯”äºbase modelï¼Œ è¿™é‡ŒåŠ äº†ä¸€ä¸ªlocal activation unitï¼Œ è¿™é‡Œé¢æ˜¯ä¸€ä¸ªå‰é¦ˆç¥ç»ç½‘ç»œï¼Œè¾“å…¥æ˜¯ç”¨æˆ·å†å²è¡Œä¸ºå•†å“å’Œå½“å‰çš„å€™é€‰å•†å“ï¼Œ è¾“å‡ºæ˜¯å®ƒä¿©ä¹‹é—´çš„ç›¸å…³æ€§ï¼Œ è¿™ä¸ªç›¸å…³æ€§ç›¸å½“äºæ¯ä¸ªå†å²å•†å“çš„æƒé‡ï¼ŒæŠŠè¿™ä¸ªæƒé‡ä¸åŸæ¥çš„å†å²è¡Œä¸ºembeddingç›¸ä¹˜æ±‚å’Œå°±å¾—åˆ°äº†ç”¨æˆ·çš„å…´è¶£è¡¨ç¤º$v_{U}(A)$, è¿™ä¸ªä¸œè¥¿çš„è®¡ç®—å…¬å¼å¦‚ä¸‹ï¼š $$\\begin{array}{cc}v_U(A)=f(v_{A}, e_{1}, e_{2}, \\ldots, e_{H})\\\\=\\sum_{j=1}^{H} a(e_{j}, v_{A}) e_{j} \\\\=\\sum_{j=1}^{H} w_{j} e_{j}\\\\\\end{array}$$ è¿™é‡Œçš„${v_{A}, e_{1},e_{2}, \\ldots, e_{H}}$æ˜¯ç”¨æˆ·$U$çš„å†å²è¡Œä¸ºç‰¹å¾embeddingï¼Œ $v_{A}$è¡¨ç¤ºçš„æ˜¯å€™é€‰å¹¿å‘Š$A$çš„embeddingå‘é‡ï¼Œ $a(e_j, v_A)=w_j$è¡¨ç¤ºçš„æƒé‡æˆ–è€…å†å²è¡Œä¸ºå•†å“ä¸å½“å‰å¹¿å‘Š$A$çš„ç›¸å…³æ€§ç¨‹åº¦ã€‚$a(\\cdot)$è¡¨ç¤ºçš„ä¸Šé¢é‚£ä¸ªå‰é¦ˆç¥ç»ç½‘ç»œï¼Œä¹Ÿå°±æ˜¯é‚£ä¸ªæ‰€è°“çš„æ³¨æ„åŠ›æœºåˆ¶ï¼Œ å½“ç„¶ï¼Œçœ‹å›¾é‡Œçš„è¯ï¼Œè¾“å…¥é™¤äº†å†å²è¡Œä¸ºå‘é‡å’Œå€™é€‰å¹¿å‘Šå‘é‡å¤–ï¼Œè¿˜åŠ äº†ä¸€ä¸ªå®ƒä¿©çš„å¤–ç§¯æ“ä½œï¼Œä½œè€…è¯´è¿™é‡Œæ˜¯æœ‰åˆ©äºæ¨¡å‹ç›¸å…³æ€§å»ºæ¨¡çš„æ˜¾æ€§çŸ¥è¯†ã€‚ è¿™é‡Œæœ‰ä¸€ç‚¹éœ€è¦ç‰¹åˆ«æ³¨æ„ï¼Œå°±æ˜¯è¿™é‡Œçš„æƒé‡åŠ å’Œä¸æ˜¯1ï¼Œ å‡†ç¡®çš„è¯´è¿™é‡Œä¸æ˜¯æƒé‡ï¼Œ è€Œæ˜¯ç›´æ¥ç®—çš„ç›¸å…³æ€§çš„é‚£ç§åˆ†æ•°ä½œä¸ºäº†æƒé‡ï¼Œä¹Ÿå°±æ˜¯å¹³æ—¶çš„é‚£ç§scores(softmaxä¹‹å‰çš„é‚£ä¸ªå€¼)ï¼Œè¿™ä¸ªæ˜¯ä¸ºäº†ä¿ç•™ç”¨æˆ·çš„å…´è¶£å¼ºåº¦ã€‚ Propertiesä¼˜ç‚¹ è€ƒè™‘äº†ç”¨æˆ·çš„å†å²æµè§ˆä¿¡æ¯ï¼Œæ›´åŠ è´´è¿‘çœŸå®çš„ä¸šåŠ¡åœºæ™¯ ä¹Ÿç”¨embedding å’Œç‰¹å¾äº¤å‰çš„æ–¹å¼è¿›è¡Œç‰¹å¾çš„å­¦ä¹ å’ŒæŒ–æ˜ä»¥åŠé™ç»´ç¼ºç‚¹ è€ƒè™‘ç”¨æˆ·æµè§ˆä¿¡æ¯æ—¶æ²¡æœ‰è€ƒè™‘å†å²çš„å…ˆåé¡ºåºï¼Œåªæ˜¯æŠŠå†å²çš„ä¿¡æ¯å’Œå¹¿å‘Šçš„ä¿¡æ¯ç‰¹å¾äº¤å‰ï¼Œæ²¡æœ‰è€ƒè™‘å†å²æµè§ˆçš„itemçš„å…ˆåå…³è”ï¼Œæ¯”å¦‚ä¸€ä¸ªç‰©å“è¢«æµè§ˆåç”¨æˆ·å®¹æ˜“æµè§ˆä¸‹ä¸€ä¸ªç›¸å…³çš„ç‰©å“ ç”¨æˆ·æœ€æ–°æµè§ˆçš„å•†å“å¾ˆæœ‰å¯èƒ½ä¸åœ¨ç”¨æˆ·è¿‡å»çš„æµè§ˆçš„å†å²é‡Œé¢ï¼Œè¿™æ ·çš„è¯multi-onehot vectorçš„é•¿åº¦å°±ä¼šå˜åŒ–ï¼Œ embeddingä¹Ÿè¦é‡æ–°è®­ç»ƒï¼Œå¹¶ä¸”éšç€æµè§ˆçš„å•†å“å¢å¤šï¼Œonehotçš„é•¿åº¦è¶Šå¤§ï¼Œembeddingè®­ç»ƒä¹Ÿä¼šè¶Šå›°éš¾ï¼Œåœ¨éšç€æ—¶é—´å˜åŒ–è€Œç‰¹å¾ä¹Ÿä¼šå˜åŒ–è¿™ä¹Ÿæ˜¯ä¸ªé—®é¢˜ã€‚æ‰€ä»¥embeddingè¦å®šæœŸæ›´æ–°ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œç”¨æˆ·æµè§ˆçš„å†å²æœ‰å¾ˆå¤šï¼Œé‚£æ ·embeddingçš„ä¸ªæ•°å°±éœ€è¦å¾ˆå¤šã€‚ä½†æ˜¯å¯¹äºä¸€äº›æµè§ˆçš„å†å²é‡Œé¢ï¼Œå¾ˆæœ‰å¯èƒ½ä¼šå­˜åœ¨å¤§é‡çš„ç”¨æˆ·æµè§ˆäº†ä½†æ˜¯ä¸æ„Ÿå…´è¶£çš„å†…å®¹ï¼Œæ˜¯å¦èƒ½å¤ŸæŠŠè¿™äº›å†…å®¹è¿›è¡Œè¿‡æ»¤(æ¯”å¦‚æ›´åŠ æµè§ˆçš„æ—¶é—´æ¥åˆ¤æ–­æ˜¯å¦åº”è¯¥æŠŠitemåŠ å…¥å†å²çš„listé‡Œé¢)ä»è€Œé™ä½onehot çš„å¤§å°ä»è€Œæ¥åŠ é€Ÿæ¨¡å‹çš„è®­ç»ƒï¼Ÿ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# DINç½‘ç»œæ­å»ºdef DIN(feature_columns, behavior_feature_list, behavior_seq_feature_list): \"\"\" è¿™é‡Œæ­å»ºDINç½‘ç»œï¼Œæœ‰äº†ä¸Šé¢çš„å„ä¸ªæ¨¡å—ï¼Œè¿™é‡Œç›´æ¥æ‹¼èµ·æ¥ :param feature_columns: A list. é‡Œé¢çš„æ¯ä¸ªå…ƒç´ æ˜¯namedtuple(å…ƒç»„çš„ä¸€ç§æ‰©å±•ç±»å‹ï¼ŒåŒæ—¶æ”¯æŒåºå·å’Œå±æ€§åè®¿é—®ç»„ä»¶)ç±»å‹ï¼Œè¡¨ç¤ºçš„æ˜¯æ•°æ®çš„ç‰¹å¾å°è£…ç‰ˆ :param behavior_feature_list: A list. ç”¨æˆ·çš„å€™é€‰è¡Œä¸ºåˆ—è¡¨ :param behavior_seq_feature_list: A list. ç”¨æˆ·çš„å†å²è¡Œä¸ºåˆ—è¡¨ \"\"\" # æ„å»ºInputå±‚å¹¶å°†Inputå±‚è½¬æˆåˆ—è¡¨ä½œä¸ºæ¨¡å‹çš„è¾“å…¥ input_layer_dict = build_input_layers(feature_columns) input_layers = list(input_layer_dict.values()) # ç­›é€‰å‡ºç‰¹å¾ä¸­çš„sparseå’ŒDenseç‰¹å¾ï¼Œ åé¢è¦å•ç‹¬å¤„ç† sparse_feature_columns = list(filter(lambda x: isinstance(x, SparseFeat), feature_columns)) dense_feature_columns = list(filter(lambda x: isinstance(x, DenseFeat), feature_columns)) # è·å–Dense Input dnn_dense_input = [] for fc in dense_feature_columns: dnn_dense_input.append(input_layer_dict[fc.name]) # å°†æ‰€æœ‰çš„denseç‰¹å¾æ‹¼æ¥ dnn_dense_input = concat_input_list(dnn_dense_input) # (None, dense_fea_nums) # æ„å»ºembeddingå­—å…¸ embedding_layer_dict = build_embedding_layers(feature_columns, input_layer_dict) # ç¦»æ•£çš„è¿™äº›ç‰¹ç‰¹å¾embeddingä¹‹åï¼Œç„¶åæ‹¼æ¥ï¼Œç„¶åç›´æ¥ä½œä¸ºå…¨è¿æ¥å±‚Denseçš„è¾“å…¥ï¼Œæ‰€ä»¥éœ€è¦è¿›è¡ŒFlatten dnn_sparse_embed_input = concat_embedding_list(sparse_feature_columns, input_layer_dict, embedding_layer_dict, flatten=True) # å°†æ‰€æœ‰çš„sparseç‰¹å¾embeddingç‰¹å¾æ‹¼æ¥ dnn_sparse_input = concat_input_list(dnn_sparse_embed_input) # (None, sparse_fea_nums*embed_dim) # è·å–å½“å‰è¡Œä¸ºç‰¹å¾çš„embeddingï¼Œ è¿™é‡Œæœ‰å¯èƒ½æœ‰å¤šä¸ªè¡Œä¸ºäº§ç”Ÿäº†è¡Œä¸ºåˆ—è¡¨ï¼Œæ‰€ä»¥éœ€è¦åˆ—è¡¨å°†å…¶æ”¾åœ¨ä¸€èµ· query_embed_list = embedding_lookup(behavior_feature_list, input_layer_dict, embedding_layer_dict) # è·å–å†å²è¡Œä¸ºçš„embeddingï¼Œ è¿™é‡Œæœ‰å¯èƒ½æœ‰å¤šä¸ªè¡Œä¸ºäº§ç”Ÿäº†è¡Œä¸ºåˆ—è¡¨ï¼Œæ‰€ä»¥éœ€è¦åˆ—è¡¨å°†å…¶æ”¾åœ¨ä¸€èµ· keys_embed_list = embedding_lookup(behavior_seq_feature_list, input_layer_dict, embedding_layer_dict) # ä½¿ç”¨æ³¨æ„åŠ›æœºåˆ¶å°†å†å²è¡Œä¸ºçš„åºåˆ—æ± åŒ–ï¼Œå¾—åˆ°ç”¨æˆ·çš„å…´è¶£ dnn_seq_input_list = [] for i in range(len(keys_embed_list)): seq_embed = AttentionPoolingLayer()([query_embed_list[i], keys_embed_list[i]]) # (None, embed_dim) dnn_seq_input_list.append(seq_embed) # å°†å¤šä¸ªè¡Œä¸ºåºåˆ—çš„embeddingè¿›è¡Œæ‹¼æ¥ dnn_seq_input = concat_input_list(dnn_seq_input_list) # (None, hist_len*embed_dim) # å°†denseç‰¹å¾ï¼Œsparseç‰¹å¾ï¼Œ å³é€šè¿‡æ³¨æ„åŠ›æœºåˆ¶åŠ æƒçš„åºåˆ—ç‰¹å¾æ‹¼æ¥èµ·æ¥ dnn_input = Concatenate(axis=1)([dnn_dense_input, dnn_sparse_input, dnn_seq_input]) # (None, dense_fea_num+sparse_fea_nums*embed_dim+hist_len*embed_dim) # è·å–æœ€ç»ˆçš„DNNçš„é¢„æµ‹å€¼ dnn_logits = get_dnn_logits(dnn_input, activation='prelu') model = Model(inputs=input_layers, outputs=dnn_logits) return model Reference[1] paper: https://arxiv.org/pdf/1706.06978.pdf[2] datawhale: https://github.com/wenkangwei/team-learning-rs/blob/master/DeepRecommendationModel/DIN.md[3] https://cloud.tencent.com/developer/article/1164761[4] DeepCTR github https://github.com/wenkangwei/DeepCTR","link":"/2021/03/27/Recommendation-System-5-DIN/"},{"title":"Web Scrapping and Regular Expression - 1","text":"IntroductionThis Quick tutorial is to use an web scrapping example to introduce how to use BeautifulSoup and Regular expression to mine the web data quickly and easily. For details, Please refer to the BeautifulSoup document. BeautifulSoupAPI Requests Import requests package 1import requests requests.get():using get(url) function from requests package, it allows us to send a request to the url webstite.It returns the response from that website, but this response is not HTML file, but a response packet from server response.content:By calling content after we get the response packet from get(), we can extract the HTML page from the packet and analyze it. BeautifulSoup soup = BeautifulSoup(html â€¦) 12from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'html.parser') This creates beautifulsoup object and parse the HTML text with a html parser to store html content to the beautifulsoup object. .tag_nameAfter obtaining a beautiful soup object of a html file, we can use soup.tag_name to get name of current tag.Example: 12345678910111213 body = soup.b print(body.name) ~~~ This extracts the tag *\\&lt;b\\&gt;* &lt;br&gt;+ *t.get_text() / t.text* After extracting a tag, we can use .text or .get_text() function to extract all texts value under current tag ~~~Python soup = BeautifulSoup(\"&lt;html&gt;&lt;h1&gt;Head 1&lt;/h1&gt; &lt;h2&gt;Head 2&lt;/h2&gt;&lt;html&gt;\") soup.get_text() #or soup.text It returns â€œHead 1 Head 2â€ directly t.attrs[â€œhrefâ€] or t[â€œhrefâ€]:In HTML, every tag could have its attributes inside the tag. We can simply use tag.[â€œattribute-nameâ€] or tag.attr[â€œattribute-nameâ€] to extract the attributesThis example extracts the href link from tag &lt;a href=â€¦&gt;&lt;/a&gt;Example: 1234567html = \"https://www.baidu.com\"soup = BeautifulSoup(html, \"html.parser\")# find a tag call \"a\", &lt;a href= ....&gt;tag= soup.find(\"a\")print(tag[\"href\"])#orprint(tag.attrs[\"href\"]) t.contents and t.children:A tagâ€™s children are available in a list called .contents .contents:it stores all children into a list .children:it is a list_generator type object, we can not get child directly. We should use iteration method to get child from childrens123456789head_tag# &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;head_tag.contents#[&lt;title&gt;The Dormouse's story&lt;/title&gt;]title_tag = head_tag.contents[0]title_tag# &lt;title&gt;The Dormouse's story&lt;/title&gt;title_tag.contents# [u'The Dormouse's story'] .string:If current tag doesnâ€™t have children tags, but just have a string, then we can call .stringIf current tag doesnâ€™t have text, but have children tags, we can not call .string (it returns nothing)Example: 123456head_tag# &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;head_tag.string# Nothinghead_tag.title.string#The Dormouse's story find(â€¦):It returns the first tag or string that satisfies the requirements in inputExample: 12tag = BeautifulSoup(\"&lt;html&gt; &lt;a&gt;text&lt;/a&gt; &lt;a&gt;text2&lt;/a&gt;&lt;html&gt;\")tag.find('a', string=\"text\") It returns the first tag with type of &lt;a&gt; which contains string â€œtextâ€.soup.find() find_all()Similar to find(), but return a list of all tags that satisfy requirements find().find_next()Find the first tag and then find the next tag that satisfies the requirements inside current tag 12soup = BeautifulSoup(\"&lt;html&gt;&lt;h1&gt;Head 1 &lt;a href=www.baidu.com&gt;&lt;/h1&gt; &lt;h2&gt;Head 2&lt;/h2&gt;&lt;html&gt;\")soup.find('h1').find_next(attrs={'href':\"www.baidu.com\"}) it returns: &lt;a href=â€www.baidu.com&quot;\\&gt;\\&lt;/a&gt; Example: Capture roster of football team in ESPN website 1234567import requestsfrom bs4 import BeautifulSoupteam_url = 'https://www.espn.com/college-football/team/roster/_/id/228/clemson-tigers'response = requests.get(team_url)soup = BeautifulSoup(response.content, \"html.parser\")tags= soup.find_all('h1') It finds all h1 tags in the HTML page and return them in a list Regular Expressionregular expression is a way to find any string pattern that match the expression we design. It helps us find the string pattern easier. API Import Regular expression package 1import re *Causes the resulting RE to match 0 or more repetitions.Example: ab*: match when 0 or more b follows a +Causes the resulting RE to match 1 or more repetitions.Example: ab+: match when 1 or more b follows a ?Causes the resulting RE to match 0 or 1 repetitions (â€¦)Matches whatever regular expression is inside the parentheses, and indicates the start and end of a group [â€¦]Used to indicate a set of characters[a-z]: characters from a to z[a-zA-Z]: characters from a to z and from A to Z[a-zA-Z0-9]: characters from a to z and from A to Z and from 0 to 9 A|BMatch either A and B pattern (?=â€¦):Matches if â€¦ matches next, but doesnâ€™t consume any of the string (?!â€¦):Matches if â€¦ doesnâ€™t match next. (?&lt;=â€¦), (?&gt;â€¦)Matches if the current position in the string is preceded (the first one) or after (second one) by a match for â€¦ that ends at the current position re.search(â€œ(text)â€, input):Search a â€œtextâ€ pattern from input. The first input is regular expressionIt return a re object *re.compile(â€œ([a-z]text)â€):compile the regular expression object. This regular expression object can use match(), search() without inputing regular expression parameters re.group(0):It extracts matched string from re object and return the first pattern. Example: 123456import res = \"Hello World. Hello Everyone\"# match a set of character a-z or A-Z that repeat 0 or more before pattern \"one\".obj = re.search(\"([a-zA-Z]*one)\",s)if obj: print(obj.group(0))This example return pattern â€œEveryoneâ€ Example to Find Specific pattern from HTML fileSearch for all strings that contain pattern â€œSCâ€ and end with â€œSCâ€ 123456789import requestsfrom bs4 import BeautifulSoupimport reteam_url = 'https://www.espn.com/college-football/team/roster/_/id/228/clemson-tigers'response = requests.get(team_url)soup = BeautifulSoup(response.content, \"html.parser\")tags= soup.find_all(string= re.compile(\"[a-zA-Z ]*SC\"))tags Further workWe can mine more information from any websites. However, we also need to know the architecture and tag names or even some functions in webpage in the website we want to mine. To get to know how to know what functions or tags we have in the BeautifulSoup object, we can use a package called inspect in python to explore the structure of beautiful soup object Reference[1] BeautifulSoup[2] Regular Expression[3] Inspect package in Python","link":"/2020/09/20/Web-Scrapping/"},{"title":"Recommendation-System-3-DeepFM","text":"Backgroundåœ¨æ¨èç³»ç»Ÿé‡Œé¢å­¦ä¹ ä½é˜¶å’Œé«˜é˜¶çš„featureï¼Œå°†feature è¿›è¡Œäº¤å‰ç»„åˆæŒ–æ˜æ•°æ®çš„ä¿¡æ¯ä¸€ç›´éœ€è¦èŠ±è´¹å¤§é‡çš„æ—¶é—´ç²¾åŠ›è¿›è¡Œfeature engineeringã€‚ç»„åˆç‰¹å¾å¤§ç‰›ä»¬ç ”ç©¶è¿‡ç»„åˆäºŒé˜¶ç‰¹å¾ï¼Œä¸‰é˜¶ç”šè‡³æ›´é«˜é˜¶ï¼Œä½†æ˜¯é¢ä¸´ä¸€ä¸ªé—®é¢˜å°±æ˜¯éšç€é˜¶æ•°çš„æå‡ï¼Œå¤æ‚åº¦å°±æˆå‡ ä½•å€çš„å‡é«˜ã€‚è¿™æ ·å³ä½¿æ¨¡å‹çš„è¡¨ç°æ›´å¥½äº†ï¼Œä½†æ˜¯æ¨èç³»ç»Ÿåœ¨å®æ—¶æ€§çš„è¦æ±‚ä¹Ÿä¸èƒ½æ»¡è¶³äº†ã€‚æ‰€ä»¥å¾ˆå¤šæ¨¡å‹çš„å‡ºç°éƒ½æ˜¯ä¸ºäº†è§£å†³å¦å¤–ä¸€ä¸ªæ›´åŠ æ·±å…¥çš„é—®é¢˜ï¼šå¦‚ä½•æ›´é«˜æ•ˆçš„å­¦ä¹ ç‰¹å¾ç»„åˆï¼Ÿ ä¸ºäº†è¿›è¡Œé€šè¿‡ç‰¹å¾äº¤å‰æ›´åŠ é«˜æ•ˆå­¦ä¹ é«˜é˜¶å’Œä½é˜¶çš„ç‰¹å¾ï¼Œå¤§ç‰›ä»¬æ›¾ç»å¯¹ç ”ç©¶è¿‡FM(factorization machine), FFM (field-aware factorization machine) å¯¹ç‰¹å¾è¿›è¡Œäº¤å‰å’Œç ”ç©¶æ›´åŠ é«˜é˜¶çš„ç‰¹å¾(æ³¨æ„FMçš„ç‰¹å¾äº¤å‰ç›¸å¯¹äºç›´æ¥åœ¨logistics regressionå¯¹ç‰¹å¾è¿›è¡Œç›¸ä¹˜äº¤å‰è€Œå·²ï¼Œé€šè¿‡ç”¨embeddingçš„æ€æƒ³å…ˆæŠŠsparse feature $x_j$ è¿›è¡Œembeddingè½¬æ¢æˆdenseçš„vector ç„¶åå†å¯¹ä¸åŒçš„ç‰¹å¾äº¤å‰ï¼Œ è¿™æ ·çš„å¥½å¤„åœ¨é¿å…äº†$x_ix_j$ç‰¹å¾äº¤å‰æ—¶åªè¦æœ‰ä¸€ä¸ªç‰¹å¾æ˜¯0å°±ä¼šå˜æˆ0è¿™æ ·æ›´åŠ å®¹æ˜“ç¨€ç–çš„ç¼ºé™·).ç„¶è€ŒFMï¼Œ FFMçš„æ–¹æ³•æŠŠç‰¹å¾è¿›è¡Œäº¤å‰çš„é—®é¢˜åœ¨äºéšç€äº¤å‰çš„orderè¶Šé«˜ï¼Œè®¡ç®—å¤æ‚åº¦è¶Šå¤§ã€‚ å¦å¤–ä¸€ç§æ–¹æ³•æ˜¯åˆ©ç”¨DNNå¯¹æ›´åŠ é«˜é˜¶çš„éçº¿æ€§ç‰¹å¾è¿›è¡Œå­¦ä¹ ã€‚ä½†æ˜¯è¿™ç§æ–¹æ³•ä¼šå¯¼è‡´modelçš„å‚æ•°å› ä¸ºsparseçš„featureç»´åº¦å¤ªé«˜è€Œå¯¼è‡´å‚æ•°è¿‡å¤šçš„éš¾ä»¥è®­ç»ƒçš„é—®é¢˜ã€‚ ä¸ºäº†è§£å†³è¿™å‡ ä¸ªé—®é¢˜ï¼Œç ”ç©¶äººå‘˜æ›¾ç»æŠŠFMï¼Œ DNNå’Œembeddingè¿›è¡Œç»“åˆã€‚å…ˆé€šè¿‡embeddingæŠŠsparse featureè¿›è¡Œé™ç»´å­¦ä¹ åˆ°denseçš„vectoråŒæ—¶ä¹Ÿæ³›åŒ–äº†featureï¼Œä¹‹åå†é€šè¿‡ç±»ä¼¼FMçš„feature intersection ç‰¹å¾äº¤å‰çš„å½¢å¼(æ¯”å¦‚inner productå’Œouter product)å°†feature è¿›è¡Œç»„åˆå¹¶å¾—åˆ°é«˜é˜¶çš„featureï¼Œæœ€åå†ç”¨DNNè¿›è¡Œç‰¹å¾å­¦ä¹ ï¼Œè€Œè¿™ä¹Ÿå¼•å‘äº†PNNçš„æ€æƒ³ã€‚ä¸‹å›¾ä¸ºPNNçš„ç»“æ„ã€‚ ä¸è¿‡PNNçš„é—®é¢˜åœ¨äºå®ƒé€šè¿‡ä¸²è¡Œçš„å½¢å¼æŠŠfeatureå˜æˆé«˜é˜¶featureä¹‹åï¼Œä½é˜¶çš„featureä¸èƒ½å¾ˆå¥½è¡¨è¾¾(å› ä¸ºæ‰€æœ‰è¾“å…¥çš„featureéƒ½è¢«æŠ•å½±è½¬æ¢åä¸¢å¤±äº†åŸæ¥ä½é˜¶ç‰¹å¾çš„ä¿¡æ¯)ã€‚ ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œåæ¥ç ”ç©¶äººå‘˜æŠŠGoogleçš„wide&amp;deepçš„modelçš„å¹¶è¡Œç»“æ„(wide model+ deep model)å’Œ ç±»ä¼¼FMçš„feature crossingçš„æ–¹å¼è¿›è¡Œç»“åˆï¼ŒæŠŠé«˜é˜¶ç‰¹å¾å’Œä½é˜¶ç‰¹å¾åŒæ—¶å¹¶è¡Œåˆ†å¼€å­¦ä¹ è€Œè¿™ä¸ªä¹Ÿå°±æ˜¯DeepFMçš„æ€æƒ³ Motivationåœ¨DeepFM (deep factorization machine) é‡Œé¢ï¼Œå®ƒé€šè¿‡æŠŠFactorization Machineï¼Œ Embeddingï¼ŒWide&amp;Deep model çš„æ€æƒ³è¿›è¡Œç»“åˆä»è€Œè¾¾åˆ°ä»¥ä¸‹çš„æ•ˆæœï¼š No Feature Engineeringå’Œwide&amp;deep ç›¸æ¯”ï¼Œ DeepFM ä¸ç”¨åšfeature engineeringå¯¹featureè¿›è¡Œç»„åˆï¼ŒDeepFMå¯ä»¥ç›´æ¥é€šè¿‡FMæ–¹å¼æŠŠæ•°æ®ç‰¹å¾è‡ªåŠ¨ç»„åˆ Learn low-order Feature Intersection and high-order Feature Intersectionç›¸å¯¹äºPNNï¼Œ DeepFMé€šè¿‡åˆ©ç”¨å¹¶è¡Œçš„æ–¹å¼å¯¹é«˜é˜¶å’Œä½é˜¶ç‰¹å¾è¿›è¡Œç»„åˆï¼Œè€Œä¸ä¼šå½±å“ä½é˜¶ç‰¹å¾çš„è¡¨è¾¾å’Œå­¦ä¹  Share the same input and embedding vectorå¯¹äºä¸åŒçš„ç”¨æˆ·çš„æ•°æ®è¾“å…¥ï¼ŒDeepFMç”¨ç›¸åŒçš„embedding vectorsè¿›è¡Œè½¬æ¢ï¼Œç”¨æˆ·çš„sparseçš„æ•°æ®ç›¸å¯¹äºæ˜¯å¯¹embeddingçš„vectorè¿›è¡Œé€‰æ‹©ï¼Œè¿™æ ·å¯ä»¥æœ‰æ•ˆé™ä½æ¨¡å‹çš„ç©ºé—´å¤æ‚åº¦ How DeepFM workæ¨¡å‹çš„ç»“æ„ä¸åŸç† å‰é¢çš„Fieldå’ŒEmbeddingå¤„ç†æ˜¯å’Œå‰é¢çš„æ–¹æ³•æ˜¯ç›¸åŒçš„ï¼Œå¦‚ä¸Šå›¾ä¸­çš„ç»¿è‰²éƒ¨åˆ†ï¼›DeepFMå°†Wideéƒ¨åˆ†æ›¿æ¢ä¸ºäº†FM layerå¦‚ä¸Šå›¾ä¸­çš„è“è‰²éƒ¨åˆ† è¿™å¹…å›¾å…¶å®æœ‰å¾ˆå¤šçš„ç‚¹éœ€è¦æ³¨æ„ï¼Œå¾ˆå¤šäººéƒ½ä¸€çœ¼ç•¥è¿‡äº†ï¼Œè¿™é‡Œæˆ‘ä¸ªäººè®¤ä¸ºåœ¨DeepFMæ¨¡å‹ä¸­æœ‰ä¸‰ç‚¹éœ€è¦æ³¨æ„ï¼š Deepæ¨¡å‹éƒ¨åˆ† FMæ¨¡å‹éƒ¨åˆ† Sparse Featureä¸­é»„è‰²å’Œç°è‰²èŠ‚ç‚¹ä»£è¡¨ä»€ä¹ˆæ„æ€ FM modelè¯¦ç»†å†…å®¹å‚è€ƒFMæ¨¡å‹éƒ¨åˆ†çš„å†…å®¹ï¼Œä¸‹å›¾æ˜¯FMçš„ä¸€ä¸ªç»“æ„å›¾ï¼Œä»å›¾ä¸­å¤§è‡´å¯ä»¥çœ‹å‡ºFM Layeræ˜¯ç”±ä¸€é˜¶ç‰¹å¾å’ŒäºŒé˜¶ç‰¹å¾Concatenateåˆ°ä¸€èµ·åœ¨ç»è¿‡ä¸€ä¸ªSigmoidå¾—åˆ°logitsï¼ˆç»“åˆFMçš„å…¬å¼ä¸€èµ·çœ‹ï¼‰ï¼Œæ‰€ä»¥åœ¨å®ç°çš„æ—¶å€™éœ€è¦å•ç‹¬è€ƒè™‘linearéƒ¨åˆ†å’ŒFMäº¤å‰ç‰¹å¾éƒ¨åˆ†ã€‚ $$y_{FM}(x) = w_0+\\sum_{i=1}^N w_ix_i + \\sum_{i=1}^N \\sum_{j=i+1}^N v_i^T v_j x_ix_j$$ Deep modelDeepæ¶æ„å›¾ Deep Moduleæ˜¯ä¸ºäº†å­¦ä¹ é«˜é˜¶çš„ç‰¹å¾ç»„åˆï¼Œåœ¨ä¸Šå›¾ä¸­ä½¿ç”¨ç”¨å…¨è¿æ¥çš„æ–¹å¼å°†Dense Embeddingè¾“å…¥åˆ°Hidden Layerï¼Œè¿™é‡Œé¢Dense Embeddingså°±æ˜¯ä¸ºäº†è§£å†³DNNä¸­çš„å‚æ•°çˆ†ç‚¸é—®é¢˜ï¼Œè¿™ä¹Ÿæ˜¯æ¨èæ¨¡å‹ä¸­å¸¸ç”¨çš„å¤„ç†æ–¹æ³•ã€‚ Embeddingå±‚çš„è¾“å‡ºæ˜¯å°†æ‰€æœ‰idç±»ç‰¹å¾å¯¹åº”çš„embeddingå‘é‡concatåˆ°åˆ°ä¸€èµ·è¾“å…¥åˆ°DNNä¸­ã€‚å…¶ä¸­$v_i$è¡¨ç¤ºç¬¬iä¸ªfieldçš„embeddingï¼Œmæ˜¯fieldçš„æ•°é‡ã€‚$$z_1=[v_1, v_2, â€¦, v_m]$$ä¸Šä¸€å±‚çš„è¾“å‡ºä½œä¸ºä¸‹ä¸€å±‚çš„è¾“å…¥ï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š$$z_L=\\sigma(W_{L-1} z_{L-1}+b_{L-1})$$å…¶ä¸­$\\sigma$è¡¨ç¤ºæ¿€æ´»å‡½æ•°ï¼Œ$z, W, b $åˆ†åˆ«è¡¨ç¤ºè¯¥å±‚çš„è¾“å…¥ã€æƒé‡å’Œåç½®ã€‚ æœ€åè¿›å…¥DNNéƒ¨åˆ†è¾“å‡ºä½¿ç”¨sigmodæ¿€æ´»å‡½æ•°è¿›è¡Œæ¿€æ´»ï¼š$$y_{DNN}=\\sigma(W^{L}a^L+b^L)$$ Propertiesä¼˜ç‚¹ ç»“åˆäº†Wide&amp;Deep, FMçš„ç‰¹ç‚¹ï¼Œåœ¨é€šè¿‡ç‰¹å¾è¿›è¡Œäº¤å‰(feature intersection)æ¥å¾—åˆ°æ›´é«˜é˜¶çš„ç‰¹å¾å¹¶åŒæ—¶å­¦ä¹ é«˜é˜¶ç‰¹å¾å’Œä½é˜¶ç‰¹å¾ ä¸ç”¨è¿›è¡Œç‰¹åˆ«ç²¾ç»†çš„feature engineering ï¼ˆwide&amp;Deep åœ¨wideçš„æ¨¡å‹é‡Œé¢è¿˜æ˜¯éœ€è¦äººå·¥ç‰¹å¾ç»„åˆï¼Œæ¯”è¾ƒwide modelé‡Œé¢feature intersectionä¸å¤Ÿï¼‰ é€šè¿‡embeddingå’Œfield inputçš„æ€æƒ³å°†sparseçš„ç‰¹å¾è¿›è¡Œé™ç»´åŒæ—¶å¯ä»¥shareç›¸åŒçš„embedding vectorï¼Œé™ä½æ¨¡å‹çš„å¤æ‚åº¦ Comparison of deep models for CTR prediction model No Feature Pre-training High-order Low-order No Features Engineering FNN Ã— âˆš Ã— âˆš PNN âˆš âˆš Ã— âˆš Wide &amp; Deep âˆš âˆš âˆš Ã— DeepFM âˆš âˆš âˆš âˆš ç¼ºç‚¹ å¯¹äº FMéƒ¨åˆ†çš„è®­ç»ƒä¼šç›¸å¯¹è¾ƒæ…¢ FMçš„å…¬å¼æ˜¯ä¸€ä¸ªé€šç”¨çš„æ‹Ÿåˆæ–¹ç¨‹ï¼Œå¯ä»¥é‡‡ç”¨ä¸åŒçš„æŸå¤±å‡½æ•°ç”¨äºè§£å†³regressionã€classificationç­‰é—®é¢˜ï¼Œæ¯”å¦‚å¯ä»¥é‡‡ç”¨MSEï¼ˆMean Square Errorï¼‰loss functionæ¥æ±‚è§£å›å½’é—®é¢˜ï¼Œä¹Ÿå¯ä»¥é‡‡ç”¨Hinge/Cross-Entropy lossæ¥æ±‚è§£åˆ†ç±»é—®é¢˜ã€‚å½“ç„¶ï¼Œåœ¨è¿›è¡ŒäºŒå…ƒåˆ†ç±»æ—¶ï¼ŒFMçš„è¾“å‡ºéœ€è¦ä½¿ç”¨sigmoidå‡½æ•°è¿›è¡Œå˜æ¢ï¼Œè¯¥åŸç†ä¸LRæ˜¯ä¸€æ ·çš„ã€‚ç›´è§‚ä¸Šçœ‹ï¼ŒFMçš„å¤æ‚åº¦æ˜¯ $O(kn^2)$ ã€‚ä½†æ˜¯FMçš„äºŒæ¬¡é¡¹å¯ä»¥åŒ–ç®€ï¼Œå…¶å¤æ‚åº¦å¯ä»¥ä¼˜åŒ–åˆ° $O(kn)$ ã€‚ç”±æ­¤å¯è§ï¼ŒFMå¯ä»¥åœ¨çº¿æ€§æ—¶é—´å¯¹æ–°æ ·æœ¬ä½œå‡ºé¢„æµ‹ã€‚ è¯æ˜æ¨ç†è§ linkï¼š $\\begin{array}{cc}\\sum_{i=1}^{n-1}{\\sum_{j=i+1}^{n}{&lt;v_i,v_j&gt;x_ix_j}}\\\\= \\frac{1}{2}\\sum_{i=1}^n\\sum_{j=1}^n &lt;v_i,v_j&gt;x_ix_j -\\frac{1}{2}\\sum_{i=1}^n &lt;v_i,v_i&gt;x_ix_i\\\\= \\frac{1}{2}\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{f=1}^k v_{if}v_{jf}x_ix_j - \\frac{1}{2}\\sum_{i=1}^n\\sum_{f=1}^k v_{if}v_{if}x_ix_i\\\\= \\frac{1}{2}\\sum_{f=1}^k [(\\sum_{i=1}^nv_{if}x_i)(\\sum_{j=1}^nv_{jf}x_j) - \\sum_{i=1}^nv_{if}^2x_{i}^2]\\\\\\end{array}$ç”±äºç¬¬ä¸€ä¸ªsumçš„loopæ—¶é—´æ˜¯O(k), è€Œè®¡ç®—$(\\sum_{j=1}^nv_{jf}x_j)$åªéœ€è¦1æ¬¡å°±å¯ä»¥å¾—åˆ°ä¸­æ‹¬å·é‡Œé¢çš„termæ‰€ä»¥æ˜¯O(n)æœ€åç›¸ä¹˜èµ·æ¥æ—¶é—´å¤æ‚åº¦å˜æˆO(kn) å…¶ä¸­ æ²¡æœ‰è€ƒè™‘åˆ°ç”¨æˆ·çš„å…´è¶£å’Œè¿‡å»æµè§ˆçš„å†å²çš„é—®é¢˜ï¼Œåªæ˜¯å•çº¯åœ¨å¯¹featureè¿›è¡Œäº¤å‰ï¼Œæ²¡æœ‰è€ƒè™‘ç”¨æˆ·åœ¨æ—¶é—´ä¸Šçš„è¡Œä¸ºå˜åŒ–ï¼Œä¹Ÿä¸èƒ½è¿›è¡Œä¸ªæ€§åŒ–æ¨è FMçš„éƒ¨åˆ†å¯èƒ½éœ€è¦FTRLä¼˜åŒ–å™¨è¿›è¡Œæ›´æ–° QuestionsCode12345678910111213141516171819202122232425262728293031323334def DeepFM(linear_feature_columns, dnn_feature_columns): # æ„å»ºè¾“å…¥å±‚ï¼Œå³æ‰€æœ‰ç‰¹å¾å¯¹åº”çš„Input()å±‚ï¼Œè¿™é‡Œä½¿ç”¨å­—å…¸çš„å½¢å¼è¿”å›ï¼Œæ–¹ä¾¿åç»­æ„å»ºæ¨¡å‹ dense_input_dict, sparse_input_dict = build_input_layers(linear_feature_columns + dnn_feature_columns) # å°†linearéƒ¨åˆ†çš„ç‰¹å¾ä¸­sparseç‰¹å¾ç­›é€‰å‡ºæ¥ï¼Œåé¢ç”¨æ¥åš1ç»´çš„embedding linear_sparse_feature_columns = list(filter(lambda x: isinstance(x, SparseFeat), linear_feature_columns)) # æ„å»ºæ¨¡å‹çš„è¾“å…¥å±‚ï¼Œæ¨¡å‹çš„è¾“å…¥å±‚ä¸èƒ½æ˜¯å­—å…¸çš„å½¢å¼ï¼Œåº”è¯¥å°†å­—å…¸çš„å½¢å¼è½¬æ¢æˆåˆ—è¡¨çš„å½¢å¼ # æ³¨æ„ï¼šè¿™é‡Œå®é™…çš„è¾“å…¥ä¸Input()å±‚çš„å¯¹åº”ï¼Œæ˜¯é€šè¿‡æ¨¡å‹è¾“å…¥æ—¶å€™çš„å­—å…¸æ•°æ®çš„keyä¸å¯¹åº”nameçš„Inputå±‚ input_layers = list(dense_input_dict.values()) + list(sparse_input_dict.values()) # linear_logitsç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼Œåˆ†åˆ«æ˜¯denseç‰¹å¾çš„logitså’Œsparseç‰¹å¾çš„logits linear_logits = get_linear_logits(dense_input_dict, sparse_input_dict, linear_sparse_feature_columns) # æ„å»ºç»´åº¦ä¸ºkçš„embeddingå±‚ï¼Œè¿™é‡Œä½¿ç”¨å­—å…¸çš„å½¢å¼è¿”å›ï¼Œæ–¹ä¾¿åé¢æ­å»ºæ¨¡å‹ # embeddingå±‚ç”¨æˆ·æ„å»ºFMäº¤å‰éƒ¨åˆ†å’ŒDNNçš„è¾“å…¥éƒ¨åˆ† embedding_layers = build_embedding_layers(dnn_feature_columns, sparse_input_dict, is_linear=False) # å°†è¾“å…¥åˆ°dnnä¸­çš„æ‰€æœ‰sparseç‰¹å¾ç­›é€‰å‡ºæ¥ dnn_sparse_feature_columns = list(filter(lambda x: isinstance(x, SparseFeat), dnn_feature_columns)) fm_logits = get_fm_logits(sparse_input_dict, dnn_sparse_feature_columns, embedding_layers) # åªè€ƒè™‘äºŒé˜¶é¡¹ # å°†æ‰€æœ‰çš„Embeddingéƒ½æ‹¼èµ·æ¥ï¼Œä¸€èµ·è¾“å…¥åˆ°dnnä¸­ dnn_logits = get_dnn_logits(sparse_input_dict, dnn_sparse_feature_columns, embedding_layers) # å°†linear,FM,dnnçš„logitsç›¸åŠ ä½œä¸ºæœ€ç»ˆçš„logits output_logits = Add()([linear_logits, fm_logits, dnn_logits]) # è¿™é‡Œçš„æ¿€æ´»å‡½æ•°ä½¿ç”¨sigmoid output_layers = Activation(\"sigmoid\")(output_logits) model = Model(input_layers, output_layers) return model Reference[1] Datawhale: https://github.com/datawhalechina/team-learning-rs/blob/master/DeepRecommendationModel/DeepFM.md[2] zhihu: https://zhuanlan.zhihu.com/p/50692817[3] CSDN: https://blog.csdn.net/ISMedal/article/details/100578354[4] https://blog.csdn.net/a819825294/article/details/51218296[5] DeepFM Paper: https://arxiv.org/pdf/1703.04247.pdf","link":"/2021/03/21/Recommendation-System-3-DeepFM/"},{"title":"Ensemble Learning - Blending","text":"IntroductionBlendingæ˜¯åŸºäºStackingçš„é›†æˆå­¦ä¹ ã€‚ åœ¨Stackingé›†æˆå­¦ä¹ çš„æ–¹æ³•é‡Œé¢ï¼Œ å®ƒåˆ†ä¸ºä¸¤å±‚ï¼Œç¬¬ä¸€å±‚é‡Œé¢å¤šä¸ªæ¨¡å‹(å¯ä»¥ç›¸åŒæ¶æ„ä¹Ÿå¯ä»¥ä¸ä¸€æ ·æ¶æ„)ç›´æ¥ä»åŸæ¥çš„è®­ç»ƒé›†è¿›è¡Œå­¦ä¹ å¹¶é¢„æµ‹è¾“å‡ºã€‚ä¹‹åæŠŠç¬¬ä¸€å±‚å¤šä¸ªæ¨¡å‹çš„è¾“å‡ºä½œä¸ºç¬¬äºŒå±‚æ¨¡å‹çš„è¾“å…¥å¯¹ç¬¬äºŒå±‚æ¨¡å‹è¿›è¡Œè®­ç»ƒã€‚ Stackingçš„æ€è·¯å°±å¥½æ¯”ä¸Šè¯¾æ—¶æˆ‘ä¸Šè¯¾è¿Ÿåˆ°ï¼Œæˆ‘éœ€è¦ä»å…¶ä»–åŒå­¦çš„ç¬”è®°é‡Œé¢è¿›è¡Œå­¦ä¹ å½’çº³ã€‚è¿™æ ·å­å…¶ä»–åŒå­¦å°±ç›¸å½“äºç¬¬ä¸€å±‚çš„æ¨¡å‹ï¼Œç›´æ¥ä»è€å¸ˆ(æ•°æ®)å­¦ä¹ ã€‚è€Œæˆ‘å°±ç›¸å½“äºç¬¬äºŒå±‚æ¨¡å‹ï¼Œä»ç¬¬ä¸€å±‚æ¨¡å‹çš„è¾“å‡ºè¿›è¡Œå­¦ä¹ ã€‚ è€Œåœ¨Stackingé‡Œé¢ï¼Œ åœ¨ç¬¬ä¸€å±‚çš„æ¨¡å‹æ˜¯é€šè¿‡K-fold Cross validation å½¢å¼è¿›è¡Œè®­ç»ƒå’Œé¢„æµ‹ã€‚ è€ŒBlendingçš„æ€è·¯ç›¸å¯¹äºæŠŠK-fold Cross validationæ¢æˆHold-Outã€‚ä»¥ä¸‹æ˜¯Stacking æ­¥éª¤: (å›¾ç‰‡æ¥æº: https://zhuanlan.zhihu.com/p/91659366) åœ¨Stackingé‡Œé¢ï¼Œ å®ƒå…ˆå¯¹training dataè¿›è¡Œåˆ†å‰²æˆKä»½ç„¶åç”¨K-fold Cross Validation è¿›è¡Œæ¨¡å‹çš„è®­ç»ƒå’Œå¯¹validation setè¿›è¡Œé¢„æµ‹ã€‚ ç¬¬ä¸€å±‚æ¨¡å‹å¯¹alidation setçš„é¢„æµ‹ç”¨ä½œç¬¬äºŒå±‚æ¨¡å‹çš„è®­ç»ƒé›†ã€‚è€Œåœ¨æµ‹è¯•é›†é‡Œé¢ï¼Œç¬¬ä¸€å±‚æ‰€æœ‰çš„æ¨¡å‹å¯¹test setçš„é¢„æµ‹å¯ä»¥é€šè¿‡æ±‚å‡å€¼çš„æ–¹å¼å¾—åˆ°ç¬¬äºŒå±‚æ¨¡å‹çš„test setã€‚ ç¬¬äºŒå±‚æ¨¡å‹çš„è¾“å‡ºå°±æ˜¯æ•´ä¸ªstacking æ¨¡å‹çš„è¾“å‡ºã€‚Stacking ç”±äºç”¨äº† K-Fold CV è¿›è¡Œç¬¬ä¸€å±‚æ¨¡å‹è®­ç»ƒï¼Œç¬¬ä¸€å±‚æ¨¡å‹è¾“å‡ºçš„ç‰¹å¾æ›´åŠ robustå¯¹æ•°æ®çš„åˆ©ç”¨ç‡ä¹Ÿæ¯”è¾ƒå……åˆ†ï¼Œä½†æ˜¯å°±æ˜¯è®­ç»ƒæ…¢ã€‚ Blending æ­¥éª¤ å°†æ•°æ®åˆ’åˆ†ä¸ºè®­ç»ƒé›†å’Œæµ‹è¯•é›†(test_set)ï¼Œå…¶ä¸­è®­ç»ƒé›†éœ€è¦å†æ¬¡åˆ’åˆ†ä¸ºè®­ç»ƒé›†(train_set)å’ŒéªŒè¯é›†(val_set)ï¼› åˆ›å»ºç¬¬ä¸€å±‚çš„å¤šä¸ªæ¨¡å‹ï¼Œè¿™äº›æ¨¡å‹å¯ä»¥ä½¿åŒè´¨çš„ä¹Ÿå¯ä»¥æ˜¯å¼‚è´¨çš„ï¼› ä½¿ç”¨train_setè®­ç»ƒæ­¥éª¤2ä¸­çš„å¤šä¸ªæ¨¡å‹ï¼Œç„¶åç”¨è®­ç»ƒå¥½çš„æ¨¡å‹é¢„æµ‹val_setå’Œtest_setå¾—åˆ°val_predict,test_predict1ï¼› åˆ›å»ºç¬¬äºŒå±‚çš„æ¨¡å‹,ä½¿ç”¨val_predictä½œä¸ºè®­ç»ƒé›†è®­ç»ƒç¬¬äºŒå±‚çš„æ¨¡å‹ï¼› ä½¿ç”¨ç¬¬äºŒå±‚è®­ç»ƒå¥½çš„æ¨¡å‹å¯¹ç¬¬äºŒå±‚æµ‹è¯•é›†test_predict1è¿›è¡Œé¢„æµ‹ï¼Œè¯¥ç»“æœä¸ºæ•´ä¸ªæµ‹è¯•é›†çš„ç»“æœã€‚ Blendingå›¾è§£ Propertiesä¼˜ç‚¹ ç›¸å¯¹äºStacking, blending ç”¨holdoutæ›´åŠ ç®€å• ä¸éœ€è¦å¤ªå¤šç†è®ºåˆ†æç¼ºç‚¹ åªç”¨äº†holdoutçš„æ•°æ®é›†é¢„æµ‹ä½œä¸ºç¬¬äºŒå±‚çš„è®­ç»ƒé›†ï¼Œæµªè´¹æ•°æ® å› ä¸ºholdoutæ•°æ®ç”¨çš„å°‘ï¼Œè¾“å…¥ç¬¬äºŒå±‚çš„æ•°æ®å¾ˆæœ‰å¯èƒ½å¯¼è‡´æ¨¡å‹overfitting ç›¸å¯¹äºStacking, å› ä¸ºç”¨äº†Holdoutè€Œä¸æ˜¯K-fold CV,ä¸å¤Ÿrobust Source CodeGithub é“¾æ¥ï¼šhttps://github.com/wenkangwei/Datawhale-Team-Learning/blob/main/Ensemble-Learning/Blending.ipynb Reference[1] https://zhuanlan.zhihu.com/p/91659366[2] https://github.com/datawhalechina/team-learning-data-mining/tree/master/EnsembleLearning","link":"/2021/05/11/ensemble-learning-blending/"},{"title":"Statistic-P-value","text":"IntroductionThis article introduces how to compute the P-value using different distributions / statistic methods, including Z-distribution, t-distribution, F-test ,Chi-Square $X^2$ Distribution.In all distributions, we first determine the random variable value in possibility density function (CDF) and then use the corresponding distribution look-up table to check the P-value (Possibility) of that distribution. Finally compare P-value with the significant level, $\\alpha$ to check should we reject Null hypothesis H0 or not. NotationsBefore talking about different testing for P-value, letâ€™s denote some notations: x: sampled data , a small group of observations P: population size. Population is the total set of observations that can be made n: sample size $\\mu_0$: population mean $\\sigma_0$: population variance $\\muâ€™$: sample mean $\\sigmaâ€™$: sample variance Z-test / Z-statistic (standard normal distribution) AssumptionZ-test assumes distributions of both population and sample are Normal distributionNull Hypothesis in z-test is that two groups have no difference Computation of Z-Score of continuous random variable $$ z-score = \\frac{\\muâ€™ - \\mu_0 }{\\sigma_0/ \\sqrt{n}}$$ if we donâ€™t know population standard variance, but know population mean only, we can use sample variance deviation to estimate the population variance deviation. Then it becomes $$ z-score = \\frac{\\muâ€™ - \\mu_0 }{\\sigmaâ€™/ \\sqrt{n}}$$ if compare two groups: $$ z-score = \\frac{\\mu_1 - \\mu_2 }{\\sqrt{(\\sigma_1^2/n_1)+(\\sigma_2^2/n_2)}}$$ Computation of Z-Score of binary random variable Denote $p_0$ as the Population possibility of obtaining current case X, $pâ€™$ as the Sample possibility of current case X $$ z score = \\frac{pâ€™ - p_0 }{ (p_0(1-p_0))/ \\sqrt{n}}$$ When to use when we know the population is normal distribution when the sample size is small, usually smaller than 30. When we know some distribution settings, like $\\mu_0$ = 0, $\\sigma_0$=1 in standard normal distribution ExampleTo test if two groups have no difference, we can let sample mean, variance of group A as $\\mu_A$ $\\sigma_A$, sample mean of group B as $\\mu_B$, $\\sigma_B$. Then let $\\muâ€™ = \\mu_A - \\mu_B$ if we assume population mean of group difference is $\\mu_0$ = 0, then we can model the group difference like this $$z-score = \\frac{(\\mu_A - \\mu_B) - 0 }{\\sigma_0/ \\sqrt{n}}$$ Or $$z-score = \\frac{(\\mu_A - \\mu_B) - 0 }{\\sqrt{(\\sigma_1^2/n_1)}}$$ t-test / t-statistic (similar to normal distribution) Assumptiont-test also assumes Normal distribution as the population distribution and sample distribution. Different from z-test, t-test doesnâ€™t assume we know the parameters (mean, variance) of normal distribution.. Null Hypothesis in t-test is that two groups have no difference Note that as degree of freedom in t-distribution increases, it is more similar to normal distribution. Computation of t-Score for continuous random variable $$ t-score = \\frac{\\mu_1 - \\mu_2}{\\sqrt{(\\sigma_1^2/n_1)+(\\sigma_2^2/n_2)}}$$ since both t-test and z-test assume normal distribution, they have the same formula Find P-value of t-score After we determine the t-score in CDF, we can find the corresponding P-value in t-distribution using this table When to use t-test is used when population parameters (population mean and population variance) are not known when sample size is very large, usually &gt;30. (So usually in model evaluation, we use t-test with large dataset) when we assume data is normal distribution Note that since in t-test we donâ€™t know the population distribution parameters, so the variances in t-test are sample variance. But in Z-test, we know the population distribution parameters, we usually use population variance and population mean instead In my word, z-test assumes we know normal distribution parameters, so we can use those parameters for testing and use less samples. But t-test doesnâ€™t assume we know anything about distribution, so it uses samples parameters (sample mean and variance) to estimate the normal distribution for testing. Chi-Square-test / $X^2$-statistic AssumptionIn Chi-Square test, it is to test the independence/correlation between categorical variablesNote that Chi-Square test is a one(right)-tail test and the we can not use it for two-tail test. It meausres the correlation of two categorical variable. Null Hypothesis in Chi-Square test is that two groups are independent from each other Computation of Pearsonâ€™s Chi-Square valueConsider we have two binary categorical variable with total sample size of n. The table is shown as follow, we want to test their correlation. Then the Pearsonâ€™s Chi-Square Correlation is computed by where i, j mean the $i^{th}$ row and $j^{th}$ column. n is the total sample amount$$E_{i,j} = \\frac{X_iX_j}{n}$$ Find P-value from Chi-Square CDF function based on the Chi Square-value we find We can find the Chi-square distribution in this linkand the distribution table from here When to use when we are testing categorical variable and we need one-tail test only when we are testing independence between two variables Example: Measuring the independence between gender and salary, independence between smoking and cancer. F-test / F-statistic AssumptionF-score is to measure the ratio between explained variance over the unexplained variance Computation of F-Score for P-ValueTo understand the F-score, let consider a real linear regression model: $$ y = \\beta_0 + \\beta_1X_1 + \\beta_2X_2 + \\epsilon$$ and an estimated linear regression$$ yâ€™ = \\beta_0 + \\beta_1X_1 + \\beta_2X_2$$where $\\epsilon$ is the unexplainable, irreducible error Then the Residual Sum Square Error (RSS) between two linear models among n samples is $$ RSS = \\sum_i^n(y_i - yâ€™_i)^2$$ RSS Error is to measure the variability between two model. In F-statistic, we want to check if there is relationship between feature $X_i$ and target. If there is no relationship, then weight $\\beta_i$ = 0.(i&gt;0). Then Null hypothesis in F-statistic is that $\\beta_1 = \\beta_2=..=\\beta_p=0$ consider there is no relationship between features and targetThen alternative hypothesis is that $\\beta_i \\neq 0$ for some i&gt;0. In this case, for null hypothesis, we have a Restricted Linear Model$$ \\bar{y} = \\beta_0$$ and a Full Linear model $$ y_iâ€™ = \\beta_0 + \\beta_1X_{1i}$$ where $X_{1i}$, $\\bar{y_i}$ means the the $1^{st}$ feature in the $i^{th}$ sample and the prediction of the $i^{th}$ sample. Denote the degree of freedom of restrict model as $df_r$, and the degree of freedom of Full model as $df_F$. There are n sample data points and p+1 weight cofficients $\\beta_i$ ($\\beta_0$ to $\\beta_p$ )to pick. Then degree of freedom = n -p.Hence in this case, we care about choosing $\\beta_1$ or not. We have $df_r$ = n-1 and $df_F$ = n-2 Total Sum Square Error (TSS) of Restrict Linear model:$$TSS = \\sum_i^n(y_i - \\bar{y})^2$$ Residual Sum Square Error (RSS) of Full Linear model:$$RSS = \\sum_i^n(y_i - yâ€™_i)^2$$ The formula to compute F-score is $$F-score = \\frac{ (TSS-RSS)/(df_r - df_F)}{RSS/df_F} = \\frac{ (TSS-RSS)/1}{RSS/(n-2)}$$ More general, If there are p+1 weight coefficient in Full model, then we have$$F-score = \\frac{ (TSS-RSS)/p}{RSS/(n-p-1)}$$ where $TSS- RSS$ is the variability explained by model and $RSS$ measure the variability left unexplained after the regression (which is also the irreducible error mentioned before) If F-value &gt; 0 and &lt;= 1, we donâ€™t reject H0. If F-value &gt;1, then we reject H0 and choose H1.If F-value &lt;0, then F-test fails, it doesnâ€™t mean anything.Note that F-test is also a One-tail hypothesis test. When to use when we are measuring if some features matters in prediction / there is correlation between features and target F-test can be adjusted by the number of predictors, but individual t-test doesnâ€™t Note that when the number of predictors p &gt; the number of samples n, F-test will fail since value $RSS/(n-p-1)$ becomes negative and this F-value is out of the range of random variable value in F-distribution ExampleThere are some examples from this link: https://online.stat.psu.edu/stat501/lesson/6/6.2 $R^2$ test Assumption$R^2$ measures the proportion of variability of prediction y that can be explained by feature X Computation of $R^2$-Score for P-Value$$ R^2 - value = \\frac{TSS- RSS}{RSS}$$ where RSS and TSS are computed as same as those in F-test $$TSS = \\sum_i^n(y_i - \\bar{y})^2$$ where $\\bar{y} =\\beta_0$ = mean of $y_i$since when we estimate $\\bar{y} =\\beta_0$ using samples to minimize the sum square loss, let gradient of $\\sum_i^n(y_i-\\bar{y})^2$ = 0, we have $-2\\sum_i^n(y_i-\\bar{y}) =0$ and $\\bar{y} = (\\sum_i^ny_i)/n$ Residual Sum Square Error (RSS) of Full Linear model:$$RSS = \\sum_i^n(y_i - yâ€™_i)^2$$ Random Variable $R^2$ has range [0,1]. If $R^2$ fall outside this range, then the test fails. If $R^2$ value is close to 1, then reject H0 and consider H1 and there is relationship between features and y. if $R^2$ value is close to 0, then model is wrong and donâ€™t fit well, then can not reject H0. When to use when we want to measures the proportion of variability of prediction y that can be explained by feature X Reference[1] https://towardsdatascience.com/statistical-tests-when-to-use-which-704557554740 [2] https://www.jmp.com/en_us/statistics-knowledge-portal/t-test/t-distribution.html [3] https://www.jmp.com/en_us/statistics-knowledge-portal/t-test/t-distribution.html [4] https://www2.palomar.edu/users/rmorrissette/Lectures/Stats/ttests/ttests.htm [5] https://online.stat.psu.edu/stat501/lesson/6/6.2 [6] https://stats.stackexchange.com/questions/130069/what-is-the-distribution-of-r2-in-linear-regression-under-the-null-hypothesis [7] https://www.statisticshowto.com/wp-content/uploads/2014/01/p-value1.jpg","link":"/2020/11/22/Statistic-P-value/"},{"title":"ensemble-learning-project-HappinessPrediction","text":"èƒŒæ™¯ä»‹ç»: å¹¸ç¦æ„Ÿé¢„æµ‹å¹¸ç¦æ„Ÿæ˜¯ä¸€ä¸ªå¤è€è€Œæ·±åˆ»çš„è¯é¢˜ï¼Œæ˜¯äººç±»ä¸–ä»£è¿½æ±‚çš„æ–¹å‘ã€‚ä¸å¹¸ç¦æ„Ÿç›¸å…³çš„å› ç´ æˆåƒä¸Šä¸‡ã€å› äººè€Œå¼‚ï¼Œå¤§å¦‚å›½è®¡æ°‘ç”Ÿï¼Œå°å¦‚è·¯è¾¹çƒ¤çº¢è–¯ï¼Œéƒ½ä¼šå¯¹å¹¸ç¦æ„Ÿäº§ç”Ÿå½±å“ã€‚è¿™äº›é”™ç»¼å¤æ‚çš„å› ç´ ä¸­ï¼Œæˆ‘ä»¬èƒ½æ‰¾åˆ°å…¶ä¸­çš„å…±æ€§ï¼Œä¸€çª¥å¹¸ç¦æ„Ÿçš„è¦ä¹‰å—ï¼Ÿ å¦å¤–ï¼Œåœ¨ç¤¾ä¼šç§‘å­¦é¢†åŸŸï¼Œå¹¸ç¦æ„Ÿçš„ç ”ç©¶å æœ‰é‡è¦çš„ä½ç½®ã€‚è¿™ä¸ªæ¶‰åŠäº†å“²å­¦ã€å¿ƒç†å­¦ã€ç¤¾ä¼šå­¦ã€ç»æµå­¦ç­‰å¤šæ–¹å­¦ç§‘çš„è¯é¢˜å¤æ‚è€Œæœ‰è¶£ï¼›åŒæ—¶ä¸å¤§å®¶ç”Ÿæ´»æ¯æ¯ç›¸å…³ï¼Œæ¯ä¸ªäººå¯¹å¹¸ç¦æ„Ÿéƒ½æœ‰è‡ªå·±çš„è¡¡é‡æ ‡å‡†ã€‚å¦‚æœèƒ½å‘ç°å½±å“å¹¸ç¦æ„Ÿçš„å…±æ€§ï¼Œç”Ÿæ´»ä¸­æ˜¯ä¸æ˜¯å°†å¤šä¸€äº›ä¹è¶£ï¼›å¦‚æœèƒ½æ‰¾åˆ°å½±å“å¹¸ç¦æ„Ÿçš„æ”¿ç­–å› ç´ ï¼Œä¾¿èƒ½ä¼˜åŒ–èµ„æºé…ç½®æ¥æå‡å›½æ°‘çš„å¹¸ç¦æ„Ÿã€‚ç›®å‰ç¤¾ä¼šç§‘å­¦ç ”ç©¶æ³¨é‡å˜é‡çš„å¯è§£é‡Šæ€§å’Œæœªæ¥æ”¿ç­–çš„è½åœ°ï¼Œä¸»è¦é‡‡ç”¨äº†çº¿æ€§å›å½’å’Œé€»è¾‘å›å½’çš„æ–¹æ³•ï¼Œåœ¨æ”¶å…¥ã€å¥åº·ã€èŒä¸šã€ç¤¾äº¤å…³ç³»ã€ä¼‘é—²æ–¹å¼ç­‰ç»æµäººå£å› ç´ ï¼›ä»¥åŠæ”¿åºœå…¬å…±æœåŠ¡ã€å®è§‚ç»æµç¯å¢ƒã€ç¨è´Ÿç­‰å®è§‚å› ç´ ä¸Šæœ‰äº†ä¸€ç³»åˆ—çš„æ¨æµ‹å’Œå‘ç°ã€‚ è¯¥æ¡ˆä¾‹ä¸ºå¹¸ç¦æ„Ÿé¢„æµ‹è¿™ä¸€ç»å…¸è¯¾é¢˜ï¼Œå¸Œæœ›åœ¨ç°æœ‰ç¤¾ä¼šç§‘å­¦ç ”ç©¶å¤–æœ‰å…¶ä»–ç»´åº¦çš„ç®—æ³•å°è¯•ï¼Œç»“åˆå¤šå­¦ç§‘å„è‡ªä¼˜åŠ¿ï¼ŒæŒ–æ˜æ½œåœ¨çš„å½±å“å› ç´ ï¼Œå‘ç°æ›´å¤šå¯è§£é‡Šã€å¯ç†è§£çš„ç›¸å…³å…³ç³»ã€‚å…·ä½“æ¥è¯´ï¼Œè¯¥æ¡ˆä¾‹å°±æ˜¯ä¸€ä¸ªæ•°æ®æŒ–æ˜ç±»å‹çš„æ¯”èµ›â€”â€”å¹¸ç¦æ„Ÿé¢„æµ‹çš„baselineã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨åŒ…æ‹¬ä¸ªä½“å˜é‡ï¼ˆæ€§åˆ«ã€å¹´é¾„ã€åœ°åŸŸã€èŒä¸šã€å¥åº·ã€å©šå§»ä¸æ”¿æ²»é¢è²Œç­‰ç­‰ï¼‰ã€å®¶åº­å˜é‡ï¼ˆçˆ¶æ¯ã€é…å¶ã€å­å¥³ã€å®¶åº­èµ„æœ¬ç­‰ç­‰ï¼‰ã€ç¤¾ä¼šæ€åº¦ï¼ˆå…¬å¹³ã€ä¿¡ç”¨ã€å…¬å…±æœåŠ¡ç­‰ç­‰ï¼‰ç­‰139ç»´åº¦çš„ä¿¡æ¯æ¥é¢„æµ‹å…¶å¯¹å¹¸ç¦æ„Ÿçš„å½±å“ã€‚æˆ‘ä»¬çš„æ•°æ®æ¥æºäºå›½å®¶å®˜æ–¹çš„ã€Šä¸­å›½ç»¼åˆç¤¾ä¼šè°ƒæŸ¥ï¼ˆCGSSï¼‰ã€‹æ–‡ä»¶ä¸­çš„è°ƒæŸ¥ç»“æœä¸­çš„æ•°æ®ï¼Œæ•°æ®æ¥æºå¯é å¯ä¾èµ–:) æ•°æ®ä¿¡æ¯èµ›é¢˜è¦æ±‚ä½¿ç”¨ä»¥ä¸Š 139 ç»´çš„ç‰¹å¾ï¼Œä½¿ç”¨ 8000 ä½™ç»„æ•°æ®è¿›è¡Œå¯¹äºä¸ªäººå¹¸ç¦æ„Ÿçš„é¢„æµ‹ï¼ˆé¢„æµ‹å€¼ä¸º1ï¼Œ2ï¼Œ3ï¼Œ4ï¼Œ5ï¼Œå…¶ä¸­1ä»£è¡¨å¹¸ç¦æ„Ÿæœ€ä½ï¼Œ5ä»£è¡¨å¹¸ç¦æ„Ÿæœ€é«˜ï¼‰ã€‚å› ä¸ºè€ƒè™‘åˆ°å˜é‡ä¸ªæ•°è¾ƒå¤šï¼Œéƒ¨åˆ†å˜é‡é—´å…³ç³»å¤æ‚ï¼Œæ•°æ®åˆ†ä¸ºå®Œæ•´ç‰ˆå’Œç²¾ç®€ç‰ˆä¸¤ç±»ã€‚å¯ä»ç²¾ç®€ç‰ˆå…¥æ‰‹ç†Ÿæ‚‰èµ›é¢˜åï¼Œä½¿ç”¨å®Œæ•´ç‰ˆæŒ–æ˜æ›´å¤šä¿¡æ¯ã€‚åœ¨è¿™é‡Œæˆ‘ç›´æ¥ä½¿ç”¨äº†å®Œæ•´ç‰ˆçš„æ•°æ®ã€‚èµ›é¢˜ä¹Ÿç»™å‡ºäº†indexæ–‡ä»¶ä¸­åŒ…å«æ¯ä¸ªå˜é‡å¯¹åº”çš„é—®å·é¢˜ç›®ï¼Œä»¥åŠå˜é‡å–å€¼çš„å«ä¹‰ï¼›surveyæ–‡ä»¶ä¸­ä¸ºåŸç‰ˆé—®å·ï¼Œä½œä¸ºè¡¥å……ä»¥æ–¹ä¾¿ç†è§£é—®é¢˜èƒŒæ™¯ã€‚ è¯„ä»·æŒ‡æ ‡MSE Loss: $$Score = \\sum_i^n (y_i - y_i^*)^2$$ $y_i$ æ˜¯target, $y_i^*$æ˜¯prediction CodingGithub æºç ä»¥åŠè¿è¡Œç»“æœï¼š https://github.com/wenkangwei/Datawhale-Team-Learning/blob/main/Ensemble-Learning/Project_1_%E5%B9%B8%E7%A6%8F%E6%84%9F%E9%A2%84%E6%B5%8B.ipynb 1. æ•°æ®åŠ è½½å’Œåˆ†æ123456789101112131415161718192021222324252627282930313233343536373839404142434445# utilitiesimport osimport timeimport pandas as pdimport numpy as npimport seaborn as sns# modelsfrom sklearn.linear_model import LogisticRegressionfrom sklearn.svm import SVC, LinearSVCfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.naive_bayes import GaussianNBfrom sklearn.linear_model import Perceptronfrom sklearn.linear_model import SGDClassifierfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.ensemble import RandomForestRegressor as rfrfrom sklearn.ensemble import ExtraTreesRegressor as etrfrom sklearn.linear_model import BayesianRidge as brfrom sklearn.ensemble import GradientBoostingRegressor as gbrfrom sklearn.linear_model import Ridgefrom sklearn.linear_model import Lassofrom sklearn.linear_model import LinearRegression as lrfrom sklearn.linear_model import ElasticNet as enfrom sklearn.kernel_ridge import KernelRidge as krimport lightgbm as lgbimport xgboost as xgb# metricsfrom sklearn import metricsfrom datetime import datetimeimport matplotlib.pyplot as pltfrom sklearn.metrics import roc_auc_score, roc_curve, mean_squared_error,mean_absolute_error, f1_scorefrom sklearn.model_selection import KFold, StratifiedKFold,GroupKFold, RepeatedKFoldfrom sklearn.model_selection import train_test_splitfrom sklearn.model_selection import GridSearchCVfrom sklearn import preprocessingimport loggingimport warningswarnings.filterwarnings('ignore') #æ¶ˆé™¤warning 12! git clone https://github.com/datawhalechina/team-learning-data-mining.git! cp /content/team-learning-data-mining/EnsembleLearning/CH6-é›†æˆå­¦ä¹ ä¹‹æ¡ˆä¾‹åˆ†äº«/é›†æˆå­¦ä¹ æ¡ˆä¾‹åˆ†æ1/* . 12345678910train = pd.read_csv(\"train.csv\", parse_dates=['survey_time'],encoding='latin-1')test = pd.read_csv(\"test.csv\", parse_dates=['survey_time'],encoding='latin-1') #latin-1å‘ä¸‹å…¼å®¹ASCIItrain = train[train[\"happiness\"]!=-8].reset_index(drop=True)train_data_copy = train.copy() #åˆ å»\"happiness\" ä¸º-8çš„è¡Œtarget_col = \"happiness\" #ç›®æ ‡åˆ—target = train_data_copy[target_col]del train_data_copy[target_col] #å»é™¤ç›®æ ‡åˆ—data = pd.concat([train_data_copy,test],axis=0,ignore_index=True)train.happiness.describe() #æ•°æ®çš„åŸºæœ¬ä¿¡æ¯ 1data.head() 1data.count() 1data.count() çœ‹ä¸€ä¸‹æ¯ä¸ªçœä»½çš„å¹¸ç¦æŒ‡æ•° 12# çœ‹ä¸€ä¸‹æ¯ä¸ªçœä»½çš„å¹¸ç¦æŒ‡æ•°train.happiness.groupby(by=train.province).mean().plot.bar() çœ‹ä¸€ä¸‹æ”¶å…¥ä¸å¹¸ç¦æ„Ÿçš„å…³ç³» 12ax = train.income.groupby(by=train.happiness).mean().plot.bar(x='income',y='happiness')ax.set_ylabel('mean income') çœ‹ä¸€ä¸‹æŠ‘éƒç¨‹åº¦ä¸å¹¸ç¦æ„Ÿçš„å…³ç³» 12ax2 = train.happiness.groupby(by=train.depression).median() .plot.bar()ax2.set_ylabel('mean happiness') çœ‹ä¸€ä¸‹æ”¿æ²»ä¸å¹¸ç¦æ„Ÿçš„å…³ç³» 1ax1 = sns.countplot(x= train.political,hue=train.happiness) çœ‹ä¸€ä¸‹æ”¾æ¾ä¸å¹¸ç¦æ„Ÿçš„å…³ç³» 123ax1 = sns.countplot(x= train.relax,hue=train.happiness)# ax1 = train.happiness.groupby(by=train.relax).mean().plot.bar()ax1.set_ylabel('happiness count') çœ‹ä¸€ä¸‹æ•™è‚²ç¨‹åº¦ä¸å¹¸ç¦æ„Ÿçš„å…³ç³» 123# ax1 = sns.countplot(x= train.relax,hue=train.happiness)ax1 = sns.countplot(x= train.edu_status,hue=train.happiness)# train.happiness.groupby(by=train.edu_status).sum().plot.bar() æ ¹æ®ä¸Šé¢çš„å¯è§†åŒ–ç»“æœ(è¯¦æƒ…å’Œå›¾è¯·çœ‹æˆ‘çš„githubçš„æºç ç»“æœ)ï¼Œç®€å•åˆ†æäº†å‡ ä¸ªä¸ªfeatureï¼Œä¸€ä¸‹å‡ ç‚¹ å‘ç°æ”¶å…¥è¶Šé«˜è¶Šå¼€å¿ƒ è¶Šå¼€å¿ƒæ—¶å©šå§»å…³ç³»å¥½åƒæœ‰ç‚¹ä¸å¥½ï¼Œåå€’å¤§å¤šæ•°äººè¶Šå¼€å¿ƒå‹åŠ›è¶Šå¤§ï¼Œæœ‰ç‚¹æ„æ€ï¼Œå¯èƒ½æ˜¯å› ä¸ºå¸¦æ¥å¼€å¿ƒçš„æ¥æºå¾€å¾€ä¼šä¼´éšæ›´å¤§çš„å‹åŠ›ã€‚ è¶Šæ˜¯å’Œæ”¿æ²»ç›¸å…³è¶Šæ˜¯ä¸å¼€å¿ƒï¼Œå‡ºæ¥æ··ä¸å®¹æ˜“å•Š é€‚åº¦æ”¾æ¾ä¼šé€‚åº¦å¼€å¿ƒï¼Œè¿‡åº¦æ”¾æ¾(5)ä¼šä¸å¤ªå¼€å¿ƒï¼Œå¯èƒ½è¿‡åº¦æ”¾çºµæ²¡æ„æ€äº†å§ å¤§å¤šæ•°è°ƒæŸ¥çš„äººçš„æ•™è‚²ç¨‹åº¦ä¹Ÿæ˜¯æŒºé«˜çš„è€Œä¸”è¿˜æŒºå¼€å¿ƒã€‚ä½†æ˜¯æ•™è‚²ç¨‹åº¦å¾ˆä½å°±ä¸å¤ªå¼€å¿ƒäº† 2. æ•°æ®æ¸…æ´—å’Œæ‰©å¢12345678910111213141516171819#make feature +5#csvä¸­æœ‰å¤æ•°å€¼ï¼š-1ã€-2ã€-3ã€-8ï¼Œå°†ä»–ä»¬è§†ä¸ºæœ‰é—®é¢˜çš„ç‰¹å¾ï¼Œä½†æ˜¯ä¸åˆ å»def getres1(row): return len([x for x in row.values if type(x)==int and x&lt;0])def getres2(row): return len([x for x in row.values if type(x)==int and x==-8])def getres3(row): return len([x for x in row.values if type(x)==int and x==-1])def getres4(row): return len([x for x in row.values if type(x)==int and x==-2])def getres5(row): return len([x for x in row.values if type(x)==int and x==-3])#æ£€æŸ¥æ•°æ®data['neg1'] = data[data.columns].apply(lambda row:getres1(row),axis=1)data.loc[data['neg1']&gt;20,'neg1'] = 20 #å¹³æ»‘å¤„ç†,æœ€å¤šå‡ºç°20æ¬¡data['neg2'] = data[data.columns].apply(lambda row:getres2(row),axis=1)data['neg3'] = data[data.columns].apply(lambda row:getres3(row),axis=1)data['neg4'] = data[data.columns].apply(lambda row:getres4(row),axis=1)data['neg5'] = data[data.columns].apply(lambda row:getres5(row),axis=1) 1234567891011121314work_cols = [i for i in data.columns if 'work' in i.split('_')[0]] # columns start with work_s_cols = [i for i in data.columns if 's' == i.split('_')[0]] # columns start with s_edu_cols = [i for i in data.columns if 'edu' == i.split('_')[0]] # columns start with s_for col in work_cols: data[col]= data[col].fillna(0)for col in s_cols: data[col]= data[col].fillna(0)for col in ['edu_yr', 'edu_status','minor_child','marital_now','marital_1st','social_neighbor','social_friend']: data[col]= data[col].fillna(0)data['hukou_loc']=data['hukou_loc'].fillna(1) #æœ€å°‘ä¸º1ï¼Œè¡¨ç¤ºæˆ·å£data['family_income']=data['family_income'].fillna(66365) #åˆ é™¤é—®é¢˜å€¼åçš„å¹³å‡å€¼ å¯¹ç‰¹æ®Šæ•°æ®è¿›è¡Œç‰¹æ®Šå¤„ç†é€šè¿‡ç”Ÿæ—¥å’Œè°ƒæŸ¥æ—¶é—´è®¡ç®—å¹´é¾„æŠŠå¹´é¾„åˆ†åŒº 12345678910#144+1 =145#ç»§ç»­è¿›è¡Œç‰¹æ®Šçš„åˆ—è¿›è¡Œæ•°æ®å¤„ç†#è¯»happiness_index.xlsxdata['survey_time'] = pd.to_datetime(data['survey_time'], format='%Y-%m-%d',errors='coerce')#é˜²æ­¢æ—¶é—´æ ¼å¼ä¸åŒçš„æŠ¥é”™errors='coerceâ€˜data['survey_time'] = data['survey_time'].dt.year #ä»…ä»…æ˜¯yearï¼Œæ–¹ä¾¿è®¡ç®—å¹´é¾„data['age'] = data['survey_time']-data['birth']# print(data['age'],data['survey_time'],data['birth'])#å¹´é¾„åˆ†å±‚ 145+1=146bins = [0,17,26,34,50,63,100]data['age_bin'] = pd.cut(data['age'], bins, labels=[0,1,2,3,4,5]) 1234567891011121314151617181920212223242526272829303132#å¯¹â€˜å®—æ•™â€™å¤„ç†data.loc[data['religion']&lt;0,'religion'] = 1 #1ä¸ºä¸ä¿¡ä»°å®—æ•™data.loc[data['religion_freq']&lt;0,'religion_freq'] = 1 #1ä¸ºä»æ¥æ²¡æœ‰å‚åŠ è¿‡#å¯¹â€˜æ•™è‚²ç¨‹åº¦â€™å¤„ç†data.loc[data['edu']&lt;0,'edu'] = 4 #åˆä¸­data.loc[data['edu_status']&lt;0,'edu_status'] = 0data.loc[data['edu_yr']&lt;0,'edu_yr'] = 0#å¯¹â€˜ä¸ªäººæ”¶å…¥â€™å¤„ç†data.loc[data['income']&lt;0,'income'] = 0 #è®¤ä¸ºæ— æ”¶å…¥#å¯¹â€˜æ”¿æ²»é¢è²Œâ€™å¤„ç†data.loc[data['political']&lt;0,'political'] = 1 #è®¤ä¸ºæ˜¯ç¾¤ä¼—#å¯¹ä½“é‡å¤„ç†data.loc[(data['weight_jin']&lt;=80)&amp;(data['height_cm']&gt;=160),'weight_jin']= data['weight_jin']*2data.loc[data['weight_jin']&lt;=60,'weight_jin']= data['weight_jin']*2 #ä¸ªäººçš„æƒ³æ³•ï¼Œå“ˆå“ˆå“ˆï¼Œæ²¡æœ‰60æ–¤çš„æˆå¹´äººå§#å¯¹èº«é«˜å¤„ç†data.loc[data['height_cm']&lt;150,'height_cm'] = 150 #æˆå¹´äººçš„å®é™…æƒ…å†µ#å¯¹â€˜å¥åº·â€™å¤„ç†data.loc[data['health']&lt;0,'health'] = 4 #è®¤ä¸ºæ˜¯æ¯”è¾ƒå¥åº·data.loc[data['health_problem']&lt;0,'health_problem'] = 4#å¯¹â€˜æ²®ä¸§â€™å¤„ç†data.loc[data['depression']&lt;0,'depression'] = 4 #ä¸€èˆ¬äººéƒ½æ˜¯å¾ˆå°‘å§#å¯¹â€˜åª’ä½“â€™å¤„ç†data.loc[data['media_1']&lt;0,'media_1'] = 1 #éƒ½æ˜¯ä»ä¸data.loc[data['media_2']&lt;0,'media_2'] = 1data.loc[data['media_3']&lt;0,'media_3'] = 1data.loc[data['media_4']&lt;0,'media_4'] = 1data.loc[data['media_5']&lt;0,'media_5'] = 1data.loc[data['media_6']&lt;0,'media_6'] = 1#å¯¹â€˜ç©ºé—²æ´»åŠ¨â€™å¤„ç†data.loc[data['leisure_1']&lt;0,'leisure_1'] = 1 #éƒ½æ˜¯æ ¹æ®è‡ªå·±çš„æƒ³æ³•data.loc[data['leisure_2']&lt;0,'leisure_2'] = 5data.loc[data['leisure_3']&lt;0,'leisure_3'] = 3 è¿˜æœ‰ä¸€äº›æ•°æ®å¤„ç†å’Œç‰¹å¾ç»„åˆçš„éƒ¨åˆ†è¿™é‡Œä¸ä¸€ä¸€æ˜¾ç¤ºï¼Œè¯¦æƒ…çœ‹æˆ‘çš„github æºç  3. æ¨¡å‹è®­ç»ƒå’Œé¢„æµ‹LightBGM1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#lightGBMå†³ç­–æ ‘lgb_263_param = {'num_leaves': 7,'min_data_in_leaf': 20, #å¶å­å¯èƒ½å…·æœ‰çš„æœ€å°è®°å½•æ•°'objective':'regression','max_depth': -1,'learning_rate': 0.003,\"boosting\": \"gbdt\", #ç”¨gbdtç®—æ³•\"feature_fraction\": 0.18, #ä¾‹å¦‚ 0.18æ—¶ï¼Œæ„å‘³ç€åœ¨æ¯æ¬¡è¿­ä»£ä¸­éšæœºé€‰æ‹©18ï¼…çš„å‚æ•°æ¥å»ºæ ‘\"bagging_freq\": 1,\"bagging_fraction\": 0.55, #æ¯æ¬¡è¿­ä»£æ—¶ç”¨çš„æ•°æ®æ¯”ä¾‹\"bagging_seed\": 14,\"metric\": 'mse',\"lambda_l1\": 0.1005,\"lambda_l2\": 0.1996,\"verbosity\": -1}RANDOM_STATE = 4folds = StratifiedKFold(n_splits=5, shuffle=True, random_state=RANDOM_STATE)oof_lgb_263 = np.zeros(len(X_train_263)) # å‚¨å­˜ LGBMçš„CVé¢„æµ‹è¾“å‡ºpredictions_lgb_263 = np.zeros(len(X_test_263)) # å‚¨å­˜LGBçš„test setçš„è¾“å‡ºç”¨äºåé¢çš„ Ensemble learning Stacking çš„ç¯èŠ‚for i, (trn_idx, val_idx) in enumerate(folds.split(X_train_263,y_train)): trn_data = lgb.Dataset(X_train_263[trn_idx],y_train[trn_idx]) val_data = lgb.Dataset(X_train_263[val_idx], y_train[val_idx])#train:val=4:1 num_round = 10000 lgb_263 = lgb.train(lgb_263_param, trn_data, num_round, valid_sets = [trn_data, val_data], verbose_eval=500, early_stopping_rounds = 800) oof_lgb_263[val_idx] = lgb_263.predict(X_train_263[val_idx], num_iteration=lgb_263.best_iteration) # make prediction on test set with mean values predictions_lgb_263 += lgb_263.predict(X_test_263, num_iteration=lgb_263.best_iteration) / folds.n_splitsprint(\"CV score: {:&lt;8.8f}\".format(mean_squared_error(oof_lgb_263, target)))#---------------ç‰¹å¾é‡è¦æ€§pd.set_option('display.max_columns', None)#æ˜¾ç¤ºæ‰€æœ‰è¡Œpd.set_option('display.max_rows', None)#è®¾ç½®valueçš„æ˜¾ç¤ºé•¿åº¦ä¸º100ï¼Œé»˜è®¤ä¸º50pd.set_option('max_colwidth',100)df = pd.DataFrame(data[use_feature].columns.tolist(), columns=['feature'])# åˆ©ç”¨LGBMçš„treeçš„feature importance å¯¹ç‰¹å¾è¿›è¡Œåˆ†ædf['importance']=list(lgb_263.feature_importance())df = df.sort_values(by='importance',ascending=False)plt.figure(figsize=(14,28))sns.barplot(x=\"importance\", y=\"feature\", data=df.head(50))plt.title('Features importance (averaged/folds)')plt.tight_layout() XGBoosting123456789101112131415161718192021222324252627282930313233##### xgb_263#xgboostxgb_263_params = {'eta': 0.02, #lr 'max_depth': 6, 'min_child_weight':3,#æœ€å°å¶å­èŠ‚ç‚¹æ ·æœ¬æƒé‡å’Œ 'gamma':0, #æŒ‡å®šèŠ‚ç‚¹åˆ†è£‚æ‰€éœ€çš„æœ€å°æŸå¤±å‡½æ•°ä¸‹é™å€¼ã€‚ 'subsample': 0.7, #æ§åˆ¶å¯¹äºæ¯æ£µæ ‘ï¼Œéšæœºé‡‡æ ·çš„æ¯”ä¾‹ 'colsample_bytree': 0.3, #ç”¨æ¥æ§åˆ¶æ¯æ£µéšæœºé‡‡æ ·çš„åˆ—æ•°çš„å æ¯” (æ¯ä¸€åˆ—æ˜¯ä¸€ä¸ªç‰¹å¾)ã€‚ 'lambda':2, 'objective': 'reg:linear', 'eval_metric': 'rmse', 'silent': True, 'nthread': -1}folds = KFold(n_splits=5, shuffle=True, random_state=2019)# å­˜æ”¾ XGBoost çš„é¢„æµ‹è¾“å‡ºç»“æœoof_xgb_263 = np.zeros(len(X_train_263))predictions_xgb_263 = np.zeros(len(X_test_263))for fold_, (trn_idx, val_idx) in enumerate(folds.split(X_train_263, y_train)): print(\"fold nÂ°{}\".format(fold_+1)) trn_data = xgb.DMatrix(X_train_263[trn_idx], y_train[trn_idx]) val_data = xgb.DMatrix(X_train_263[val_idx], y_train[val_idx]) watchlist = [(trn_data, 'train'), (val_data, 'valid_data')] xgb_263 = xgb.train(dtrain=trn_data, num_boost_round=3000, evals=watchlist, early_stopping_rounds=600, verbose_eval=500, params=xgb_263_params) oof_xgb_263[val_idx] = xgb_263.predict(xgb.DMatrix(X_train_263[val_idx]), ntree_limit=xgb_263.best_ntree_limit) predictions_xgb_263 += xgb_263.predict(xgb.DMatrix(X_test_263), ntree_limit=xgb_263.best_ntree_limit) / folds.n_splitsprint(\"CV score: {:&lt;8.8f}\".format(mean_squared_error(oof_xgb_263, target))) RandomForest12345678910111213141516171819#RandomForestRegressoréšæœºæ£®æ—folds = KFold(n_splits=5, shuffle=True, random_state=2019)oof_rfr_263 = np.zeros(len(X_train_263))predictions_rfr_263 = np.zeros(len(X_test_263))for fold_, (trn_idx, val_idx) in enumerate(folds.split(X_train_263, y_train)): print(\"fold nÂ°{}\".format(fold_+1)) tr_x = X_train_263[trn_idx] tr_y = y_train[trn_idx] # using parallel job for training rfr_263 = rfr(n_estimators=1600,max_depth=9, min_samples_leaf=9, min_weight_fraction_leaf=0.0, max_features=0.25,verbose=1,n_jobs=-1) #verbose = 0 ä¸ºä¸åœ¨æ ‡å‡†è¾“å‡ºæµè¾“å‡ºæ—¥å¿—ä¿¡æ¯ #verbose = 1 ä¸ºè¾“å‡ºè¿›åº¦æ¡è®°å½• #verbose = 2 ä¸ºæ¯ä¸ªepochè¾“å‡ºä¸€è¡Œè®°å½• rfr_263.fit(tr_x,tr_y) oof_rfr_263[val_idx] = rfr_263.predict(X_train_263[val_idx]) predictions_rfr_263 += rfr_263.predict(X_test_263) / folds.n_splitsprint(\"CV score: {:&lt;8.8f}\".format(mean_squared_error(oof_rfr_263, target))) StackingæŠŠä¸Šé¢çš„æ¨¡å‹çš„è¾“å‡ºé€šè¿‡stackingçš„æ–¹å¼å¯¹stage2 æ¨¡å‹è¿›è¡Œè®­ç»ƒ 1234567891011121314151617181920# stacking predictions from LGBM, XGBoost and RandomForest# We need to transpose the results so that each row of matrix = predictions from different models# on the same sampletrain_stack2 = np.vstack([oof_lgb_263,oof_xgb_263,oof_rfr_263]).transpose()# transpose()å‡½æ•°çš„ä½œç”¨å°±æ˜¯è°ƒæ¢x,y,zçš„ä½ç½®,ä¹Ÿå°±æ˜¯æ•°ç»„çš„ç´¢å¼•å€¼test_stack2 = np.vstack([predictions_lgb_263, predictions_xgb_263,predictions_rfr_263,]).transpose()#äº¤å‰éªŒè¯:5æŠ˜ï¼Œé‡å¤2æ¬¡folds_stack = RepeatedKFold(n_splits=5, n_repeats=2, random_state=7)oof_stack2 = np.zeros(train_stack2.shape[0])predictions_lr2 = np.zeros(test_stack2.shape[0])for fold_, (trn_idx, val_idx) in enumerate(folds_stack.split(train_stack2,target)): print(\"fold {}\".format(fold_)) trn_data, trn_y = train_stack2[trn_idx], target.iloc[trn_idx].values val_data, val_y = train_stack2[val_idx], target.iloc[val_idx].values #using ElasticNet as stage 2 model for prediction lr2 = en() lr2.fit(trn_data, trn_y) oof_stack2[val_idx] = lr2.predict(val_data) predictions_lr2 += lr2.predict(test_stack2) / 10mean_squared_error(target.values, oof_stack2) Reference[1] Datawhale https://github.com/datawhalechina/team-learning-data-mining/tree/master/EnsembleLearning [2] https://datawhale.feishu.cn/docs/doccnHM5ebRKr7u6mrhwcn3l5hc#","link":"/2021/05/18/ensemble-learning-project-HappinessPrediction/"},{"title":"Recommendation-System-4-NFM","text":"BackgroundNeuralFM (Neural Factorization Machines)æ˜¯2017å¹´ç”±æ–°åŠ å¡å›½ç«‹å¤§å­¦çš„ä½•å‘å—æ•™æˆç­‰äººåœ¨SIGIRä¼šè®®ä¸Šæå‡ºçš„ä¸€ä¸ªæ¨¡å‹ï¼Œè¿™ä¸ªæ¨¡å‹å¯ä»¥çœ‹æˆæ˜¯ç›´æ¥æŠŠFMï¼ŒNeural network å’Œembeddingçš„ç®€å•ç²—æš´çš„ç»“åˆ ï¼ˆåŸæ¥è®ºæ–‡è¿™ä¹ˆå¥½å‘çš„å—ï¼Ÿï¼‰ Motivationè¿™ä¸ªæ¨¡å‹è€ƒè™‘çš„é—®é¢˜æ˜¯ FM æ¨¡å‹åªè€ƒè™‘äº†ä¸€é˜¶å’ŒäºŒé˜¶çš„ç‰¹å¾ï¼Œç„¶è€Œå¯¹æ›´åŠ é«˜é˜¶çš„ç‰¹å¾æ²¡æœ‰å­¦ä¹ åˆ°ï¼Œè¿™æ ·æ— æ³•å¯¹ç”Ÿæ´»ä¸­æ›´åŠ å¤æ‚å’Œæœ‰è§„å¾‹çš„æ•°æ®è¿›è¡ŒæŒ–æ˜å’Œå­¦ä¹ ã€‚FMçš„å…¬å¼å¦‚ä¸‹ï¼Œ å®ƒåªè€ƒè™‘åˆ°ä¸€é˜¶å’ŒäºŒé˜¶çš„ç‰¹å¾ç»„åˆã€‚ç¬¬äºŒä¸ªtermæ˜¯inner productã€‚$$y_{N F M}(x)=w_{0}+\\sum_{i=1}^{n} w_{i} x_{i}+ \\sum_{i=1}^{n}\\sum_{j=i+1}^{n} &lt;v_iv_j , x_{i}x_{j}&gt;$$ ä¸ºäº†è§£å†³è¿™ä¸ªå±€é™æ€§é—®é¢˜ï¼Œä½•å‘å—æ•™æˆé€šè¿‡ç®€å•ç²—æš´çš„æ–¹æ³•ç›´æ¥æŠŠFMçš„äºŒé˜¶ç‰¹å¾çš„ç»„åˆçš„éƒ¨åˆ†æ¢æˆç¥ç»ç½‘ç»œï¼Œå¹¶å°†sparseçš„featureåœ¨ç½‘ç»œä¸­å…ˆè¿›è¡Œembeddingé™ç»´å†äº¤å‰ç»“åˆä»è€Œå¾—åˆ°å­¦ä¹ æ›´åŠ é«˜é˜¶éçº¿æ€§ç‰¹å¾çš„æ•ˆæœï¼Œ æ›´æ–°åçš„å…¬å¼å¦‚ä¸‹ï¼š $$y_{N F M}(x)=w_{0}+\\sum_{i=1}^{n} w_{i} x_{i}+f(x)$$ å…¶ä¸­f(x) æ˜¯DNNçš„éƒ¨åˆ†. NeuralFM åŸç†Neural FM çš„æ¨¡å‹ç»“æ„å¦‚ä¸‹ï¼šæ©™è‰²æ¡†æ¡†ä»£è¡¨FMé‡Œé¢linear feature çš„ä¸€é˜¶ç‰¹å¾ç»„åˆï¼Œè€Œå¯¹äºsparseçš„ç‰¹å¾å…ˆé€šè¿‡embeddingç”Ÿæˆdense vectorç„¶åæŠŠdense vectorç”¨äºä¸€é˜¶çš„ç‰¹å¾ç»„åˆ(æ©™è‰²æ¡†æ¡†)ä»¥åŠbi-interactoin pooling layer çš„é«˜é˜¶ç‰¹å¾äº¤å‰è¿›è¡Œé«˜é˜¶ç‰¹å¾çš„å­¦ä¹ ï¼ˆç»¿è‰²æ¡†æ¡†ï¼‰ NeuralFM çš„$f(x)$ éƒ¨åˆ†çš„ç»“æ„å¦‚ä¸‹ï¼šNeuralFMçš„DNNéƒ¨åˆ†ç”± Sparse input, Embedding layer, B-intersection Layer, Hidden layers (Deep model), prediction outputç»„æˆ Input Layerè¾“å…¥å±‚çš„ç‰¹å¾é‡Œé¢ æ¯ä¸€ä¸ªcellç›¸å½“äºä¸€ä¸ª sparse featureï¼Œ æ¯ä¸ªfeatureä¸€èˆ¬æ˜¯å…ˆone-hot, ç„¶åä¼šé€šè¿‡embeddingï¼Œç”Ÿæˆçº¬åº¦ä½çš„dense vectorï¼Œå‡è®¾$v_i \\in R^{k}$ä¸ºç¬¬$i$ä¸ªç‰¹å¾çš„embeddingå‘é‡ï¼Œ é‚£ä¹ˆ$V_{x}={x_{1} v_{1}, \\ldots, x_{n} v_{n}}$è¡¨ç¤ºçš„ä¸‹ä¸€å±‚çš„è¾“å…¥ç‰¹å¾ã€‚è¿™é‡Œå¸¦ä¸Šäº†$x_i$æ˜¯å› ä¸ºå¾ˆå¤š$x_i$è½¬æˆäº†One-hotä¹‹åï¼Œå‡ºç°å¾ˆå¤šä¸º0çš„ï¼Œ è¿™é‡Œçš„$x_iv_i$ æ˜¯ä¸€ä¸ªembeddingçš„vector è€Œ $x_i$ä¸ç­‰äº0çš„é‚£äº›ç‰¹å¾å‘é‡ï¼Œç›¸å½“äº$x_i$ é€šè¿‡lookup table æ–¹å¼é€‰æ‹© embedding vector $v_i$. Bi-Interaction Pooling layeråœ¨Embeddingå±‚å’Œç¥ç»ç½‘ç»œä¹‹é—´åŠ å…¥äº†ç‰¹å¾äº¤å‰æ± åŒ–å±‚æ˜¯æœ¬ç½‘ç»œçš„æ ¸å¿ƒåˆ›æ–°äº†ï¼Œæ­£æ˜¯å› ä¸ºè¿™ä¸ªç»“æ„ï¼Œå®ç°äº†FMä¸DNNçš„æ— ç¼è¿æ¥ï¼Œ ç»„æˆäº†ä¸€ä¸ªå¤§çš„ç½‘ç»œï¼Œä¸”èƒ½å¤Ÿæ­£å¸¸çš„åå‘ä¼ æ’­ã€‚å‡è®¾$V_{x}$æ˜¯æ‰€æœ‰ç‰¹å¾embeddingçš„é›†åˆï¼Œ é‚£ä¹ˆåœ¨ç‰¹å¾äº¤å‰æ± åŒ–å±‚çš„æ“ä½œï¼š $$f_{B I}(V_{x})=\\sum_{i=1}^{n} \\sum_{j=i+1}^{n} x_{i} v_{i} \\odot x_{j} v_{j}$$ $\\odot$è¡¨ç¤ºä¸¤ä¸ªå‘é‡çš„å…ƒç´ ç§¯æ“ä½œ(element-wise multiplication, è¿™ä¸ªä¸æ¸…æ¥šå¯ä»¥googleä¸€ä¸‹)ï¼Œå³ä¸¤ä¸ªå‘é‡å¯¹åº”ç»´åº¦ç›¸ä¹˜å¾—åˆ°çš„å…ƒç´ ç§¯å‘é‡ï¼ˆå¯ä¸æ˜¯ç‚¹ä¹˜) ä¸ªäººè®¤ä¸ºåœ¨ $x_{i} v_{i} \\odot x_{j} v_{j}$ é‡Œé¢å®ƒçš„ç»“æ„æ˜¯å’Œ$v_i,v_j$ç›¸åŒå¤§å°çš„ç‰¹å¾dense vectorã€‚$f_{B I}(V_{x})$æ˜¯å¤šä¸ªdense vectorçš„ç®€å•ç›´æ¥äº¤å‰element-wiseç›¸ä¹˜åç›¸åŠ çš„ç»“æœã€‚è¿™ä¸ªæ–¹æ³•å…¶å®ä¹Ÿæ˜¯æŒºç›´æ¥Bi-Interactionå±‚ä¸éœ€è¦é¢å¤–çš„æ¨¡å‹å­¦ä¹ å‚æ•°ï¼Œæ›´é‡è¦çš„æ˜¯å®ƒåœ¨ä¸€ä¸ªçº¿æ€§çš„æ—¶é—´å†…å®Œæˆè®¡ç®—ï¼Œå’ŒFMä¸€è‡´çš„ï¼Œå³æ—¶é—´å¤æ‚åº¦ä¸º$O(k N_{x})$ï¼Œ$N_x$ä¸ºembeddingå‘é‡çš„æ•°é‡ã€‚å‚è€ƒFMï¼Œå¯ä»¥å°†ä¸Šå¼è½¬åŒ–ä¸ºè¯æ˜æ¨ç†è§ linkï¼š $$f_{B I}(V_{x})=\\frac{1}{2}[(\\sum_{i=1}^{n} x_{i} v_{i})^{2}-\\sum_{i=1}^{n}(x_{i} v_{i})^{2}]$$ Hidden Layerè¿™ä¸€å±‚å°±æ˜¯å…¨è¿æ¥çš„ç¥ç»ç½‘ç»œï¼Œ DNNåœ¨è¿›è¡Œç‰¹å¾çš„é«˜å±‚éçº¿æ€§äº¤äº’ä¸Šæœ‰ç€å¤©ç„¶çš„å­¦ä¹ ä¼˜åŠ¿ï¼Œå…¬å¼å¦‚ä¸‹ï¼š $$\\begin{array}{cc}a_1 = \\sigma(W_1f_{BI}(V_x) +b_1) \\\\a_2 = \\sigma(W_2a_1 +b_2) \\\\â€¦ \\\\a_{i+1} = \\sigma(W_ia_i +b_i) \\\\\\end{array}$$ è¿™é‡Œçš„$\\sigma_i$æ˜¯ç¬¬$i$å±‚çš„æ¿€æ´»å‡½æ•°ï¼Œhidden layeré‡Œé¢ä¸€èˆ¬æ˜¯ReLuå‡½æ•°è€Œä¸æ˜¯logistics æ¥é˜²æ­¢æ¢¯åº¦æ¶ˆå¤±é—®é¢˜ï¼Œ $f_{BI}(V_x)$æ˜¯äº¤å‰åçš„embeddingçš„dense vectorã€‚ Prediction Layerè¿™ä¸ªå°±æ˜¯æœ€åä¸€å±‚çš„ç»“æœç›´æ¥è¿‡ä¸€ä¸ªéšè—å±‚ï¼Œä½†å¦‚æœè¿™é‡Œæ˜¯å›å½’é—®é¢˜ï¼Œæ²¡æœ‰åŠ sigmoidæ¿€æ´»ï¼Œå¦‚æœæ˜¯åˆ†ç±»é—®é¢˜ï¼Œéœ€è¦åŠ ä¸Šlogistic æˆ–softmaxçš„ activation functionï¼š $$f({x})={h}^{T} {z}_{L}$$ åœ¨NeuralFMçš„DNNè¿™ä¸€éƒ¨åˆ†ï¼Œä¸ºäº†å‡å°‘DNNçš„å¾ˆå¤šè´Ÿæ‹…ï¼Œä¸€èˆ¬åªéœ€è¦å¾ˆå°‘çš„éšè—å±‚å°±å¯ä»¥å­¦ä¹ åˆ°é«˜é˜¶ç‰¹å¾ä¿¡æ¯ã€‚å½“ç„¶å¯ä»¥åƒå…¶ä»–æ·±åº¦æ¨¡å‹ä¸€æ ·é€šè¿‡æ·»åŠ Dropout, Batch normalization, ResBlock ç­‰æ–¹æ³•è¿›è¡Œè¿›è¡Œæ›´åŠ æ·±åº¦çš„featureçš„å­¦ä¹ å·²ç»æŠ‘åˆ¶è¿‡æ‹Ÿåˆï¼Œæ¢¯åº¦æ¶ˆå¤±ç­‰é—®é¢˜ã€‚ Propertiesä¼˜ç‚¹ NFM é€šè¿‡ç®€å•ç²—æš´ç›´æ¥çš„æ–¹å¼æŠŠFMçš„äºŒé˜¶ç‰¹å¾ç»„åˆéƒ¨åˆ†æ¢æˆDNNçš„æ–¹å¼å­¦ä¹ åˆ°æ›´åŠ é«˜é˜¶éçº¿æ€§çš„ç‰¹å¾ï¼Œå¾ˆå®¹æ˜“ç†è§£ è®¡ç®—ç®€å•ç›´æ¥linear logit + embedding çš„DNNçš„éƒ¨åˆ†å°±å®Œäº‹äº†ï¼Œè€Œä¸”ç”±äºDNNä¸€èˆ¬æ¥è¯´æ¯”è¾ƒæµ…å°±èƒ½å­¦ä¹ é«˜é˜¶çš„ç‰¹å¾ï¼Œè®­ç»ƒä¹Ÿä¸éš¾ èƒ½å¤Ÿå­¦ä¹ ä½é˜¶ç‰¹å¾å’Œé«˜é˜¶ç‰¹å¾ èƒ½å¤Ÿé€šè¿‡embeddingæœ‰æ•ˆè§£å†³sparse featureå¸¦æ¥çš„è®­ç»ƒçœ‹ä½ çš„é—®é¢˜ï¼Œä¸ç”¨åƒwide&amp;deepé‚£æ ·éœ€è¦é¢å¤–çš„FTRLçš„optimizationçš„æ–¹æ³•è¿›è¡Œä¼˜åŒ– ç¼ºç‚¹ å’ŒDeepFMç›¸æ¯”ï¼ŒNeuralFM æœ‰ç‚¹åƒæŠŠDeepFMé‡Œé¢çš„FMmodelå’ŒDeep model ä¸²èµ·æ¥çš„æ„Ÿè§‰ã€‚ç›¸å¯¹äºDeepFM, NFMæ²¡æœ‰æŠŠä½é˜¶ç‰¹å¾ç›´æ¥äº¤å‰ï¼Œåªæ˜¯è¦ä¹ˆæŠŠä½é˜¶ç‰¹å¾ç›´æ¥çº¿æ€§ç›¸åŠ ï¼Œè¦ä¹ˆæŠŠä»–ä»¬é€šè¿‡embeddingè¿›è¡ŒæŠ•å½±åˆ°é«˜é˜¶generalçš„ç‰¹å¾å†ç›´æ¥ç›¸åŠ ï¼Œæ‰€ä»¥æ„Ÿè§‰å¯¹ä½é˜¶ç‰¹å¾äº¤å‰ç»„åˆæ–¹é¢ä¸å¤ªå¥½ã€‚ Code123456789101112131415161718192021222324252627282930313233343536def NFM(linear_feature_columns, dnn_feature_columns): \"\"\" æ­å»ºNFMæ¨¡å‹ï¼Œä¸Šé¢å·²ç»æŠŠæ‰€æœ‰ç»„å—éƒ½å†™å¥½äº†ï¼Œè¿™é‡Œæ‹¼èµ·æ¥å°±å¥½ :param linear_feature_columns: A list. é‡Œé¢çš„æ¯ä¸ªå…ƒç´ æ˜¯namedtuple(å…ƒç»„çš„ä¸€ç§æ‰©å±•ç±»å‹ï¼ŒåŒæ—¶æ”¯æŒåºå·å’Œå±æ€§åè®¿é—®ç»„ä»¶)ç±»å‹ï¼Œè¡¨ç¤ºçš„æ˜¯linearæ•°æ®çš„ç‰¹å¾å°è£…ç‰ˆ :param dnn_feature_columns: A list. é‡Œé¢çš„æ¯ä¸ªå…ƒç´ æ˜¯namedtuple(å…ƒç»„çš„ä¸€ç§æ‰©å±•ç±»å‹ï¼ŒåŒæ—¶æ”¯æŒåºå·å’Œå±æ€§åè®¿é—®ç»„ä»¶)ç±»å‹ï¼Œè¡¨ç¤ºçš„æ˜¯DNNæ•°æ®çš„ç‰¹å¾å°è£…ç‰ˆ \"\"\" # æ„å»ºè¾“å…¥å±‚ï¼Œå³æ‰€æœ‰ç‰¹å¾å¯¹åº”çš„Input()å±‚ï¼Œ è¿™é‡Œä½¿ç”¨å­—å…¸çš„å½¢å¼è¿”å›ï¼Œ æ–¹ä¾¿åç»­æ„å»ºæ¨¡å‹ # æ„å»ºæ¨¡å‹çš„è¾“å…¥å±‚ï¼Œæ¨¡å‹çš„è¾“å…¥å±‚ä¸èƒ½æ˜¯å­—å…¸çš„å½¢å¼ï¼Œåº”è¯¥å°†å­—å…¸çš„å½¢å¼è½¬æ¢æˆåˆ—è¡¨çš„å½¢å¼ # æ³¨æ„ï¼šè¿™é‡Œå®é™…çš„è¾“å…¥ä¸Input()å±‚çš„å¯¹åº”ï¼Œæ˜¯é€šè¿‡æ¨¡å‹è¾“å…¥æ—¶å€™çš„å­—å…¸æ•°æ®çš„keyä¸å¯¹åº”nameçš„Inputå±‚ dense_input_dict, sparse_input_dict = build_input_layers(linear_feature_columns+dnn_feature_columns) input_layers = list(dense_input_dict.values()) + list(sparse_input_dict.values()) # çº¿æ€§éƒ¨åˆ†çš„è®¡ç®— w1x1 + w2x2 + ..wnxn + béƒ¨åˆ†ï¼Œdenseç‰¹å¾å’Œsparseä¸¤éƒ¨åˆ†çš„è®¡ç®—ç»“æœç»„æˆï¼Œå…·ä½“çœ‹ä¸Šé¢ç»†èŠ‚ linear_logits = get_linear_logits(dense_input_dict, sparse_input_dict, linear_feature_columns) # DNNéƒ¨åˆ†çš„è®¡ç®— # é¦–å…ˆï¼Œåœ¨è¿™é‡Œæ„å»ºDNNéƒ¨åˆ†çš„embeddingå±‚ï¼Œä¹‹æ‰€ä»¥å†™åœ¨è¿™é‡Œï¼Œæ˜¯ä¸ºäº†çµæ´»çš„è¿ç§»åˆ°å…¶ä»–ç½‘ç»œä¸Šï¼Œè¿™é‡Œç”¨å­—å…¸çš„å½¢å¼è¿”å› # embeddingå±‚ç”¨äºæ„å»ºFMäº¤å‰éƒ¨åˆ†ä»¥åŠDNNçš„è¾“å…¥éƒ¨åˆ† embedding_layers = build_embedding_layers(dnn_feature_columns, sparse_input_dict, is_linear=False) # è¿‡ç‰¹å¾äº¤å‰æ± åŒ–å±‚ pooling_output = get_bi_interaction_pooling_output(sparse_input_dict, dnn_feature_columns, embedding_layers) # åŠ ä¸ªBatchNormalization pooling_output = BatchNormalization()(pooling_output) # dnnéƒ¨åˆ†çš„è®¡ç®— dnn_logits = get_dnn_logits(pooling_output) # çº¿æ€§éƒ¨åˆ†å’Œdnnéƒ¨åˆ†çš„ç»“æœç›¸åŠ ï¼Œæœ€åå†è¿‡ä¸ªsigmoid output_logits = Add()([linear_logits, dnn_logits]) output_layers = Activation(\"sigmoid\")(output_logits) model = Model(inputs=input_layers, outputs=output_layers) return model Reference[1] datawhale: https://github.com/datawhalechina/team-learning-rs/blob/master/DeepRecommendationModel/NFM.md [2] FM https://www.jianshu.com/p/152ae633fb00 [3] åŸpaper https://arxiv.org/pdf/1708.05027.pdf","link":"/2021/03/24/Recommendation-System-4-NFM/"},{"title":"Data Structure 2 -sorting","text":"Bubble sort (å†’æ³¡æ’åºæ³•)Main ideaBubble sort compares the array elements $(n-1) + (n-2)+â€¦+1 = \\frac{n(n-1)}{2}$ times. At $k^{th}$ iteration, iterate (n-k) elements and swap two elements if previous one is larger than the next one in ascending sorting.It guarantees that in each iteration, there must be at least one element sorted into the correct positionsExample:in an array [5 1 4 2 8] with length = 5Begin:$1^{st}$ iteration: iteration starts from arr[0] to arr[4] and swap two element if arr[i] &gt; arr[i+1].[5 1 4 2 8] $\\to$ [1 5 4 2 8] $\\to$ [1 4 5 2 8] $\\to$ [1 4 2 5 8] $\\to$ [1 4 2 5 8] $2^{nd}$ iteration: iteration starts from arr[0] to arr[3] and swap two element if arr[i] &gt; arr[i+1]. Process is similar to the first iteration.The result is [1 4 2 5 8] $\\to$ [1 2 4 5 8] $3^{rd}$ iteration: iteration starts from arr[0] to arr[2].$4^{rd}$ iteration: iteration starts from arr[0] to arr[1].End Process Pesudo Code 1234Loop through n-1 iteration: at the k^th iteration, loop through arr[0] to arr[n-1 - k] element: if arr[i]&gt; arr[i+1] swap arr[i], arr[i+1] Python Code 1234567def bubble_sort(array): n = len(array) for i in range(n-1): for j in range(n-1-i): if array[j] &gt; array[j+1]: array[j], array[j+1] = array[j+1], array[j] return array Complexity Memory Complexity: O(1), since there is no memory used in algorithm Time Complexity: O(n^2), since there are two inner loops in function and need $\\frac{n(n-1)}{2}$ comparison. Selection Sort (é€‰æ‹©æ’åºæ³•)Main IdeaSelection sort is to find the maximum value of current array and put it to the end of array and then exclude this sorted element to get the sub-array and repeat these two steps to sort the array. If find minimum value, need to put it to the beginning. Process Pesudo Code 1234Loop through n-1 iterations at k^th iteration find max of array[0:n-1-k] put max into array[n-1-k] Python Code 123456789def selection_sort(array): n = len(array) for i in range(n): max_v = 0 for j in range(n-i): if array[max_v] &lt; array[j]: max_v = j array[n-i-1] , array[max_v] =array[max_v], array[n-i-1] return array Complexity Memory Complexity: O(1) since in this code, we donâ€™t use additional memory Time Complexity:: O(n^2), since selection sort use two loops to sort. One inner loop is used to find max value and the other loop is to sort the max values. Insertion sort (æ’å…¥æ’åºæ³•)Main IdeaMain idea of Insertion Sort is to compare the current element with elements before this element and then insert this element to the correct position by moving some elements backward. Start from arr[1], i=1. Iterate elements arr[i] with index i from 1 to N-1 For each element arr[i], compare arr[i] with the element arr[k] right before arr[i]. If we found element arr[k] &gt; arr[i], swap arr[i] and arr[k]. Repeat Step 2 until the element arr[k] before arr[i] is less than or equal to arr[i]Example:Given an array arr = [4,3,2,10,12,1,5,6] with array length N= 8, initial index =0, we want to sort it in ascending order.iteration 1: [4,3,2,10,12,1,5,6] $\\to$ [3,4,2,10,12,1,5,6]iteration 2: [3,4,2,10,12,1,5,6] $\\to$ [3,2,4,10,12,1,5,6] $\\to$ [2,3,4,10,12,1,5,6]â€¦ Process Pseudo code12345678Let i = 1Loop until i ==N-1 j= i-1 // swap arr[i] and arr[j] if arr[j]&gt;arr[i] while arr[i]&lt; arr[j] and j&gt;0: swap(arr[i], arr[j]) j-- i++ Python Code1234567def insertion_sort(array): for i in range(1,len(array)): j = i-1 while j&gt;=0 and array[j] &gt;array[j+1]: array[j],array[j+1] = array[j+1], array[j] j -= 1 return array Complexity Memory Complexity: O(1) Speed Complexity: worst case: O(n^2) Extension Binary Search + Insertion sort. Reference Quick sort (å¿«é€Ÿæ’åºæ³•)Main IdeaIn quick sort, the main idea is that we first choose a pivot/key element used for comparison. Usually we choose the last element in the partition/array as the pivot (we can also choose middle element or the first element as well) Move the elements smaller than pivot to the left to form a subarray/partition P1 containing all elements smaller than pivot. Move the elements larger than pivot to the right to form a subarraysubarray/partition P2 containing all elements larger than pivot Move pivot to the position between P1 and P2 such that elements ahead pivot are smaller than pivot, elements after pivot are after than pivotNote: This structure is actually as same as binary search tree, in which elements on the left side of the parent node is smaller than parent as elements on the right side of the parent node is greater than parent Repeat steps 1~4 for each partition recursively until subarray can not be partitioned (only one element) Process In Partition step set the last element arr[len(arr)-1] to be pivot set pointer pointing to values smaller than pivot: left_pt =0 and pointer pointing to values greater than pivot: right_pt = len(arr)-2 Loop until reaching terminal state: left_pt&gt; right_pt left_pt++ until it finds arr[left_pt]&gt;pivot right_ptâ€“ until it finds arr[right_pt]&lt; pivot swap arr[left_pt] and arr[right_pt] after reaching terminal, swap pivot and arr[left_pt] such that pivot is at the correct position. Pseudo Code 12345678910111213141516171819202122partition(array, low, high): // check if input range is valid if begin-end &lt; 1: return end pivot = array[high] left_pt = low right_pt = high-1 //move left_pt to right, right_pt to left until left_pt&gt;right_pt //when left_pt&gt;right_pt, we know array[left_pt] &gt;= array[right_pt] //then we need to swap pivot with either array[left_pt] or array[right_pt] to set the boundary Loop if left_pt&lt;= right_pt: Loop if left_pt&lt; len(array) and array[left_pt] &lt;= pivot: left_pt++ Loop if right_pt&gt; 0 and array[right_pt]&gt;= pivot: right_pt-- if left_pt&lt; right_pt: swap array[left_pt] and array[right_pt] if array[left_pt] &gt; pivot swap array[left_pt], pivot return left_pt Note: array may have multiple values as same as pivot. In order to iterate each element in position 0~n-1, need to use &lt;= pivot, and &gt;= pivot to avoid trapping at some positions that doesnâ€™t satisfy terminal conditioneg. arr[left_pt] a[1] arr[right_pt] arr[pivot] 2 1 2 2 In this case, if we use â€œ&lt; pivotâ€ and â€œ&gt;pivotâ€ rather than â€œ&gt;=â€,â€&lt;=â€, then left_pt and right_pt wonâ€™t check â€œ1â€ in the array. __Need to compare array[left_pt] and pivot__, since when the input array has only 2 element, then left_pt = right_pt, it directly skips the loop and swap data without comparing the values, this could be wrong. Pseudo Code 12QuickSort( array): return quicksort(array, 0, len(array)-1) 1234567891011quicksort(array, begin,end) //Check if array is empty or length &gt;1 if end-begin&lt;1: return array // find the correct position of pivot mid = Partition(array, 0, len(array)-1) // sort the subarray with elements smaller than pivot array = quicksort(array, 0, mid-1) // sort the subarray with elements greater than pivot array = quicksort(array, mid+1,len(array)-1) return array Python Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution(object): def quickSort(self, array): \"\"\" input: int[] array return: int[] \"\"\" # write your solution here if array == None or len(array)==0: return array begin = 0 end = len(array)-1 return self.quick_sort(array, begin,end) def quick_sort(self, array, begin, end): # Check base case if begin &gt;=end: return array #pre-order operation # partition l_begin, l_end, r_begin, r_end = self.partition(array, begin, end) # recursively go to left and right sub-array array = self.quick_sort(array, l_begin, l_end) array = self.quick_sort(array, r_begin, r_end) return array def partition(self, array, begin, end): # check base case if begin &gt;= end: return begin, begin, begin,begin # choose pivot import random # randomly choose a pivot in array # then move the pivot to the end of the array, pivot=end pivot = random.randint(begin, end) array[pivot], array[end] = array[end], array[pivot] pivot = end stored_index = begin for i in range(begin, end+1): if array[i] &lt; array[pivot]: array[i], array[stored_index] = array[stored_index], array[i] stored_index += 1 array[pivot] , array[stored_index] = array[stored_index], array[pivot] l_begin = begin l_end = stored_index-1 r_begin = stored_index +1 r_end = end return l_begin, l_end, r_begin, r_end Complexity Memory Complexity: O(1) if we donâ€™t consider the memory in stack. Otherwise, O(logn) Time Complexity: best case/average caseï¼›O(nlogn) worst case: O(n^2), since it is possible that every time we select the pivot of sub-array is the largest element of this sub-array, which lead to the case that the recursion tree becomes linked list.When the Recursion tree becomes linked list, time complexity becomes O(nh) = O(nn) rather than O(nh) = O(nlogn), where h is the height of tree. To solve this problem, we can use random selection method to select the pivot, rather than always pick the last element as pivot Note when it always picks the greatest/ smallest value as pivot or the array is already sorted, it comes to the worst case O(n^2) since the recursion tree becomes a list-like data structure with depth of recursion tree = O(n) and take O(n) to iterate every node and O(n) to sort at each node. Then it comes to O(n*n) time complexity Quick Sort use Pre-Order, Top-down, in-place operation to first partition array and then do recursion Merge Sort use Post-Order, Bottom-up, not in-place method to return array and then merge returned array Merge sort ï¼ˆå½’å¹¶æ’åºï¼‰Main Ideaï¼šMerge sort is one of the divide and conquer algorithm like quicksort. Its main ideas is that Find the middle of the array Divide the array into two sub-array based on middle Repeat step 1~2 recursively until only 1 element in the array Merge left array and right array and return merged array recusively Example: In the array below, we recurively divide the array into left sub-array 2 and right sub-array 12, then sort the left array first by dividing it until step 4,5. We then merge two elements in step 6. After that, we go back to step 2 to sort the right sub-array. We do the same thing for the whole array. Process Pesudo Code 123456789101112131415161718192021222324252627282930MergeSort( array) check if array is valid array, if not ,return compute left , right boundary merge_subarray(array, left, right)merge_subarray(array, lef, right): check if left &lt; right. If not, return array[left] compute middle = (left+right)//2 // sort left array left_array = merge_subarray(array, left, middle) // sort right array right_array = merge_subarray(array, middle+1, right) // merge and sort left and right arrays sorted_array = merge(left_array, right_array) return sorted_arraymerge(left_array, right_array): use linear method to merge the left array and right array. // Note that since left_array and right array have //been sorted, merging two sorted array actually //lead to linear time complexity O(n) only create new array A left_index = 0 right_index = 0 while left_index &gt;0 and right_index&gt;0: add the min(left_array[left_index], right_array[right_index]) index += 1 Add the remaining elements in array to A return A Python code 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution(object): def merge_sort(self, array, left, right): if len(array)&lt;2 or left&gt;=right: return [array[left]] middle = left+ (right-left)//2 left_array = self.merge_sort(array, left, middle) right_array = self.merge_sort(array, middle+1, right) sorted_array = self.merge(left_array, right_array) return sorted_array def merge(self, left_array, right_array): if left_array == None or len(left_array) &lt;1: return right_array elif right_array == None or len(right_array) &lt;1: return left_array l_index = 0 r_index = 0 merged_array = [] while l_index &lt; len(left_array) and r_index&lt;len(right_array): if left_array[l_index] &lt; right_array[r_index]: merged_array.append(left_array[l_index]) l_index += 1 else: merged_array.append(right_array[r_index]) r_index += 1 if l_index &lt; len(left_array): merged_array.extend(left_array[l_index:]) elif r_index &lt; len(right_array): merged_array.extend(right_array[r_index:]) return merged_array def mergeSort(self, array): \"\"\" input: int[] array return: int[] \"\"\" # write your solution here if array == None or len(array) &lt;2: return array return self.merge_sort(array, 0, len(array)-1) Complexity Memory Complexity: if consider the memory used in stack during recursion, it is O(logn) Time Complexity: O(nlogn). In each layer of recursion tree, it takes O(n) to merge and sort two sub-arrays at a level of the tree. Since merge sort uses division method, that is, Assume that are n elements to sort and take k steps (depth of the recursion tree) to sort. There are $2^0+2^1+â€¦+2^k = n$ elements. When only consider the largest term, we have $2^k = n$, and $k = O(log_2n) or O(logn)$. Since each level of recursion tree take O(n) to sort array, then have $O(nlogn)$ Compared with quick sort Both merge sort and quick sort use divide and conquer method (åˆ†æ²»ç®—æ³•) to divide array and then solve each subset recursively. Hence both of them involve logn time complexity As for memory complexity, merge sort has O(nlogn) while quicksort has memory complexity O(logn). Quicksort is better than mergesort As for time complexity, merge sort has average/worst case time complexity: O(nlogn) while quick sort has O(nlogn) in average case and O(n^2) in worst case. Quick sort is less stable than merge sort. Quicksort and merge sort are much more useful than linear sorting(insertion, bubble, selection) due to its O(nlogn) time complexity without increasing memory complexity Notes: Usually, Recursion method is less optimal than iteration method (using while loop), since recursion method requires stack memory to store and return solved subset back to last sub-problem. Hence memory complexity of recursion is usually O(n) unless there are no memory used in recursion function and reduce n to 1 Recursion method is easy to implement, but usually costs more memory. Selection sort can be viewed as a version of bubble sort with more explicit physic meaning, since it explicitly finds the min/max value and put them to the beginning/end of subarray. Insertion sort compares current element with previous elements while bubble/selection sort compare current element with the next elements In-place algorithm: an algorithm which transforms input using no auxiliary data structure. However a small amount of extra storage space is allowed for auxiliary variables. The input is usually overwritten by the output as the algorithm executes. Source codeFor C++ source code, Please read my github repository here Reference[1] https://www.geeksforgeeks.org/bubble-sort/[2] https://www.geeksforgeeks.org/insertion-sort/?ref=lbp[3] https://www.geeksforgeeks.org/quick-sort/?ref=lbp","link":"/2020/08/24/data-structure-sorting/"},{"title":"Recommendation System-6-DCN","text":"DCN: Deep&amp;Cross Network1. åŠ¨æœºWide&amp;Deepæ¨¡å‹çš„æå‡ºä¸ä»…ç»¼åˆäº†â€œè®°å¿†èƒ½åŠ›â€å’Œâ€œæ³›åŒ–èƒ½åŠ›â€ï¼Œ è€Œä¸”å¼€å¯äº†ä¸åŒç½‘ç»œç»“æ„èåˆçš„æ–°æ€è·¯ã€‚ æ‰€ä»¥åé¢å°±æœ‰å„å¼å„æ ·çš„æ¨¡å‹æ”¹è¿›Wideéƒ¨åˆ†æˆ–è€…Deepéƒ¨åˆ†ï¼Œ è€ŒDeep&amp;Crossæ¨¡å‹(DCN)å°±æ˜¯å…¶ä¸­æ¯”è¾ƒå…¸å‹çš„ä¸€ä¸ªï¼Œè¿™æ˜¯2017å¹´æ–¯å¦ç¦å¤§å­¦å’Œè°·æ­Œçš„ç ”ç©¶äººå‘˜åœ¨ADKDDä¼šè®®ä¸Šæå‡ºçš„ï¼Œ è¯¥æ¨¡å‹é’ˆå¯¹W&amp;Dçš„wideéƒ¨åˆ†è¿›è¡Œäº†æ”¹è¿›ï¼Œ å› ä¸ºWideéƒ¨åˆ†æœ‰ä¸€ä¸ªä¸è¶³å°±æ˜¯éœ€è¦äººå·¥è¿›è¡Œç‰¹å¾çš„ç»„åˆç­›é€‰ï¼Œ è¿‡ç¨‹ç¹çä¸”éœ€è¦ç»éªŒï¼Œ è€Œ2é˜¶çš„FMæ¨¡å‹åœ¨çº¿æ€§çš„æ—¶é—´å¤æ‚åº¦ä¸­è‡ªåŠ¨è¿›è¡Œç‰¹å¾äº¤äº’ï¼Œä½†æ˜¯è¿™äº›ç‰¹å¾äº¤äº’çš„è¡¨ç°èƒ½åŠ›å¹¶ä¸å¤Ÿï¼Œå¹¶ä¸”éšç€é˜¶æ•°çš„ä¸Šå‡ï¼Œæ¨¡å‹å¤æ‚åº¦ä¼šå¤§å¹…åº¦æé«˜ã€‚äºæ˜¯ä¹ï¼Œä½œè€…ç”¨ä¸€ä¸ªCross Networkæ›¿æ¢æ‰äº†Wideéƒ¨åˆ†ï¼Œæ¥è‡ªåŠ¨è¿›è¡Œç‰¹å¾ä¹‹é—´çš„äº¤å‰ï¼Œå¹¶ä¸”ç½‘ç»œçš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦éƒ½æ˜¯çº¿æ€§çš„ã€‚ é€šè¿‡ä¸Deepéƒ¨åˆ†ç›¸ç»“åˆï¼Œæ„æˆäº†æ·±åº¦äº¤å‰ç½‘ç»œï¼ˆDeep &amp; Cross Networkï¼‰ï¼Œç®€ç§°DCNã€‚ 2. æ¨¡å‹ç»“æ„åŠåŸç†è¿™ä¸ªæ¨¡å‹çš„ç»“æ„æ˜¯è¿™ä¸ªæ ·å­çš„ï¼š è¿™ä¸ªæ¨¡å‹çš„ç»“æ„ä¹Ÿæ˜¯æ¯”è¾ƒç®€æ´çš„ï¼Œ ä»ä¸Šåˆ°ä¸‹ä¾æ¬¡ä¸ºï¼šEmbeddingå’ŒStackingå±‚ï¼Œ Crossç½‘ç»œå±‚ä¸Deepç½‘ç»œå±‚å¹¶åˆ—ï¼Œ ä»¥åŠæœ€åçš„è¾“å‡ºå±‚ã€‚ä¸‹é¢ä¹Ÿæ˜¯ä¸€ä¸€ä¸ºå¤§å®¶å‰–æã€‚ 2.1 Embeddingå’ŒStacking å±‚Embeddingå±‚æˆ‘ä»¬å·²ç»éå¸¸çš„ç†Ÿæ‚‰äº†å§ï¼Œ è¿™é‡Œçš„ä½œç”¨ä¾ç„¶æ˜¯æŠŠç¨€ç–ç¦»æ•£çš„ç±»åˆ«å‹ç‰¹å¾å˜æˆä½ç»´å¯†é›†å‹ã€‚ $$x_{embed, i} = W_{embed, i} x_{i}$$ å…¶ä¸­å¯¹äºæŸä¸€ç±»ç¨€ç–åˆ†ç±»ç‰¹å¾ï¼ˆå¦‚idï¼‰ï¼Œ$X_{embed, i}$æ˜¯ç¬¬ä¸ª$i$åˆ†ç±»å€¼ï¼ˆidåºå·ï¼‰çš„embeddingå‘é‡ã€‚$W_{embed,i}$æ˜¯embeddingçŸ©é˜µï¼Œ $n_e\\times n_v$ç»´åº¦ï¼Œ $n_e$æ˜¯embeddingç»´åº¦ï¼Œ $n_v$æ˜¯è¯¥ç±»ç‰¹å¾çš„å”¯ä¸€å–å€¼ä¸ªæ•°ã€‚$x_i$å±äºè¯¥ç‰¹å¾çš„äºŒå…ƒç¨€ç–å‘é‡(one-hot)ç¼–ç çš„ã€‚ ã€å®è´¨ä¸Šå°±æ˜¯åœ¨è®­ç»ƒå¾—åˆ°çš„Embeddingå‚æ•°çŸ©é˜µä¸­æ‰¾åˆ°å±äºå½“å‰æ ·æœ¬å¯¹åº”çš„Embeddingå‘é‡ã€‘ã€‚å…¶å®ç»å¤§å¤šæ•°åŸºäºæ·±åº¦å­¦ä¹ çš„æ¨èæ¨¡å‹éƒ½éœ€è¦Embeddingæ“ä½œï¼Œå‚æ•°å­¦ä¹ æ˜¯é€šè¿‡ç¥ç»ç½‘ç»œè¿›è¡Œè®­ç»ƒã€‚ æœ€åï¼Œè¯¥å±‚éœ€è¦å°†æ‰€æœ‰çš„å¯†é›†å‹ç‰¹å¾ä¸é€šè¿‡embeddingè½¬æ¢åçš„ç‰¹å¾è¿›è¡Œè”åˆï¼ˆStackingï¼‰ï¼š$$x_0= [x_{embed, 1}^{T}, \\ldots, x_{embed, k}^{T}, x_{dense }^{T}]$$ ä¸€å…±$k$ä¸ªç±»åˆ«ç‰¹å¾ï¼Œ denseæ˜¯æ•°å€¼å‹ç‰¹å¾ï¼Œ ä¸¤è€…åœ¨ç‰¹å¾ç»´åº¦æ‹¼åœ¨ä¸€å—ã€‚ ä¸Šé¢çš„è¿™ä¸¤ä¸ªæ“ä½œå¦‚æœæ˜¯çœ‹äº†å‰é¢çš„æ¨¡å‹çš„è¯ï¼Œåº”è¯¥éå¸¸å®¹æ˜“ç†è§£äº†ã€‚ 2.2 Cross Networkè¿™ä¸ªå°±æ˜¯æœ¬æ¨¡å‹æœ€å¤§çš„äº®ç‚¹äº†â€”Crossç½‘ç»œï¼Œ è¿™ä¸ªæ€è·¯æ„Ÿè§‰éå¸¸Niceã€‚è®¾è®¡è¯¥ç½‘ç»œçš„ç›®çš„æ˜¯å¢åŠ ç‰¹å¾ä¹‹é—´çš„äº¤äº’åŠ›åº¦ã€‚äº¤å‰ç½‘ç»œç”±å¤šä¸ªäº¤å‰å±‚ç»„æˆï¼Œ å‡è®¾$l$å±‚çš„è¾“å‡ºå‘é‡$x_l$ï¼Œ é‚£ä¹ˆå¯¹äºç¬¬$l+1$å±‚çš„è¾“å‡ºå‘é‡$x_{l+1}$è¡¨ç¤ºä¸ºï¼š $$x_{l+1}=x_{0} x_{l}^{T} w_{l}+b_{l}+x_{l}=f(x_{l}, w_{l}, b_{l})+x_{l}$$ å¯ä»¥çœ‹åˆ°ï¼Œ äº¤å‰å±‚çš„æ“ä½œçš„äºŒé˜¶éƒ¨åˆ†éå¸¸ç±»ä¼¼PNNæåˆ°çš„å¤–ç§¯æ“ä½œï¼Œ åœ¨æ­¤åŸºç¡€ä¸Šå¢åŠ äº†å¤–ç§¯æ“ä½œçš„æƒé‡å‘é‡$w_l$ï¼Œ ä»¥åŠåŸè¾“å…¥å‘é‡$x_l$å’Œåç½®å‘é‡$b_l$ã€‚ äº¤å‰å±‚çš„å¯è§†åŒ–å¦‚ä¸‹ï¼š å¯ä»¥çœ‹åˆ°ï¼Œ æ¯ä¸€å±‚å¢åŠ äº†ä¸€ä¸ª$n$ç»´çš„æƒé‡å‘é‡$w_l$ï¼ˆnè¡¨ç¤ºè¾“å…¥å‘é‡ç»´åº¦ï¼‰ï¼Œ å¹¶ä¸”åœ¨æ¯ä¸€å±‚å‡ä¿ç•™äº†è¾“å…¥å‘é‡ï¼Œ å› æ­¤è¾“å…¥å’Œè¾“å‡ºä¹‹é—´çš„å˜åŒ–ä¸ä¼šç‰¹åˆ«æ˜æ˜¾ã€‚å…³äºè¿™ä¸€å±‚ï¼Œ åŸè®ºæ–‡é‡Œé¢æœ‰ä¸ªå…·ä½“çš„è¯æ˜æ¨å¯¼Cross Networkä¸ºå•¥æœ‰æ•ˆï¼Œ ä¸è¿‡æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œæˆ‘æ‹¿ä¸€ä¸ªå¼å­ç®€å•çš„è§£é‡Šä¸‹ä¸Šé¢è¿™ä¸ªå…¬å¼çš„ä¼Ÿå¤§ä¹‹å¤„ï¼š æˆ‘ä»¬æ ¹æ®ä¸Šé¢è¿™ä¸ªå…¬å¼ï¼Œ å°è¯•çš„å†™å‰é¢å‡ å±‚çœ‹çœ‹: $l$ =0: $x_{1} =x_{0} x_{0}^{T} w_{0}+ b_{0}+ x_{0}$ $l=1: x_{2} =x_{0} x_{1}^{T} w_{1}+ b_{1}+x_{1}=x_{0} [x_{0} x_{0}^{T} w_{0}+ b_{0}+x_{0}]^{T} w_{1}+ b_{1}+x_{1}$ $l=2: x_{3} =x_{0} x_{2}^{T} w_{2}+ b_{2}+ x_{2}=x_{0} [x_{0} [x_{0} x_{0}^{T} w_{0}+ b_{0}+ x_{0}]^{T} w_{1}+ b_{1}+ x_{1}]^{T} w_{2}+ b_{2}+x_{2}$ æˆ‘ä»¬æš‚ä¸”å†™åˆ°ç¬¬3å±‚çš„è®¡ç®—ï¼Œ æˆ‘ä»¬ä¼šå‘ç°ä»€ä¹ˆç»“è®ºå‘¢ï¼Ÿ ç»™å¤§å®¶æ€»ç»“ä¸€ä¸‹ï¼š $x_1$ä¸­åŒ…å«äº†æ‰€æœ‰çš„$x_0$çš„1,2é˜¶ç‰¹å¾çš„äº¤äº’ï¼Œ $x_2$åŒ…å«äº†æ‰€æœ‰çš„$x_1, x_0$çš„1ï¼Œ 2ï¼Œ 3é˜¶ç‰¹å¾çš„äº¤äº’ï¼Œ$x_3$ä¸­åŒ…å«äº†æ‰€æœ‰çš„$x_2$, $x_1$ä¸$x_0$çš„äº¤äº’ï¼Œ$\\mathrm{x}_0$çš„1,2,3,4é˜¶ç‰¹å¾äº¤äº’ã€‚ å› æ­¤ï¼Œ äº¤å‰ç½‘ç»œå±‚çš„å‰ä¹˜é˜¶æ•°æ˜¯æœ‰é™çš„ã€‚ ç¬¬$l$å±‚ç‰¹å¾å¯¹åº”çš„æœ€é«˜çš„å‰ä¹˜é˜¶æ•°$l+1$ Crossç½‘ç»œçš„å‚æ•°æ˜¯å…±äº«çš„ï¼Œ æ¯ä¸€å±‚çš„è¿™ä¸ªæƒé‡ç‰¹å¾ä¹‹é—´å…±äº«ï¼Œ è¿™ä¸ªå¯ä»¥ä½¿å¾—æ¨¡å‹æ³›åŒ–åˆ°çœ‹ä¸è§çš„ç‰¹å¾äº¤äº’ä½œç”¨ï¼Œ å¹¶ä¸”å¯¹å™ªå£°æ›´å…·æœ‰é²æ£’æ€§ã€‚ ä¾‹å¦‚ä¸¤ä¸ªç¨€ç–çš„ç‰¹å¾$x_i,x_j$ï¼Œ å®ƒä»¬åœ¨æ•°æ®ä¸­å‡ ä¹ä¸å‘ç”Ÿäº¤äº’ï¼Œ é‚£ä¹ˆå­¦ä¹ $x_i,x_j$çš„æƒé‡å¯¹äºé¢„æµ‹æ²¡æœ‰ä»»ä½•çš„æ„ä¹‰ã€‚ è®¡ç®—äº¤å‰ç½‘ç»œçš„å‚æ•°æ•°é‡ã€‚ å‡è®¾äº¤å‰å±‚çš„æ•°é‡æ˜¯$L_c$ï¼Œ ç‰¹å¾$x$çš„ç»´åº¦æ˜¯$n$ï¼Œ é‚£ä¹ˆæ€»å…±çš„å‚æ•°æ˜¯ï¼š $$n\\times L_c \\times 2$$è¿™ä¸ªå°±æ˜¯æ¯ä¸€å±‚ä¼šæœ‰$w$å’Œ$b$ã€‚ä¸”$w$ç»´åº¦å’Œ$x$çš„ç»´åº¦æ˜¯ä¸€è‡´çš„ã€‚ äº¤å‰ç½‘ç»œçš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦æ˜¯çº¿æ€§çš„ã€‚è¿™æ˜¯å› ä¸ºï¼Œ æ¯ä¸€å±‚éƒ½åªæœ‰$w$å’Œ$b$ï¼Œ æ²¡æœ‰æ¿€æ´»å‡½æ•°çš„å­˜åœ¨ï¼Œç›¸å¯¹äºæ·±åº¦å­¦ä¹ ç½‘ç»œï¼Œ äº¤å‰ç½‘ç»œçš„å¤æ‚æ€§å¯ä»¥å¿½ç•¥ä¸è®¡ã€‚ Crossç½‘ç»œæ˜¯FMçš„æ³›åŒ–å½¢å¼ï¼Œ åœ¨FMæ¨¡å‹ä¸­ï¼Œ ç‰¹å¾$x_i$çš„æƒé‡$v_i$ï¼Œ é‚£ä¹ˆäº¤å‰é¡¹$x_i,x_j$çš„æƒé‡ä¸º$&lt;x_i,x_j&gt;$ã€‚åœ¨DCNä¸­ï¼Œ $x_i$çš„æƒé‡ä¸º${W_K^{(i)}}_{k=1}^l$, äº¤å‰é¡¹$x_i,x_j$çš„æƒé‡æ˜¯å‚æ•°${W_K^{(i)}}_{k=1}^l$å’Œ${W_K^{(j)}}_{k=1}^l$çš„ä¹˜ç§¯ï¼Œè¿™ä¸ªçœ‹ä¸Šé¢é‚£ä¸ªä¾‹å­å±•å¼€æ„Ÿå—ä¸‹ã€‚å› æ­¤ä¸¤ä¸ªæ¨¡å‹éƒ½å„è‡ªå­¦ä¹ äº†ç‹¬ç«‹äºå…¶ä»–ç‰¹å¾çš„ä¸€äº›å‚æ•°ï¼Œå¹¶ä¸”äº¤å‰é¡¹çš„æƒé‡æ˜¯ç›¸åº”å‚æ•°çš„æŸç§ç»„åˆã€‚FMåªå±€é™äº2é˜¶çš„ç‰¹å¾äº¤å‰(ä¸€èˆ¬)ï¼Œè€ŒDCNå¯ä»¥æ„å»ºæ›´é«˜é˜¶çš„ç‰¹å¾äº¤äº’ï¼Œ é˜¶æ•°ç”±ç½‘ç»œæ·±åº¦å†³å®šï¼Œå¹¶ä¸”äº¤å‰ç½‘ç»œçš„å‚æ•°åªä¾æ®è¾“å…¥çš„ç»´åº¦çº¿æ€§å¢é•¿ã€‚ è¿˜æœ‰ä¸€ç‚¹æˆ‘ä»¬ä¹Ÿè¦äº†è§£ï¼Œå¯¹äºæ¯ä¸€å±‚çš„è®¡ç®—ä¸­ï¼Œ éƒ½ä¼šè·Ÿç€$\\mathrm{x}_0$, è¿™ä¸ªæ˜¯å’±ä»¬çš„åŸå§‹è¾“å…¥ï¼Œ ä¹‹æ‰€ä»¥ä¼šä¹˜ä»¥ä¸€ä¸ªè¿™ä¸ªï¼Œæ˜¯ä¸ºäº†ä¿è¯åé¢ä¸ç®¡æ€ä¹ˆäº¤å‰ï¼Œéƒ½ä¸èƒ½åç¦»æˆ‘ä»¬çš„åŸå§‹è¾“å…¥å¤ªè¿œï¼Œåˆ«æœ€åäº¤å‰äº¤å‰éƒ½è·‘åäº†ã€‚ $x_{l+1}=f(x_{l}, w_{l}, b_{l})+x_{l}$, è¿™ä¸ªä¸œè¥¿å…¶å®æœ‰ç‚¹è·³è¿œè¿æ¥çš„æ„æ€ï¼Œä¹Ÿå°±æ˜¯å’ŒResNetä¹Ÿæœ‰ç‚¹ç›¸ä¼¼ï¼Œæ— å½¢ä¹‹ä¸­è¿˜èƒ½æœ‰æ•ˆçš„ç¼“è§£æ¢¯åº¦æ¶ˆå¤±ç°è±¡ã€‚ å¥½äº†ï¼Œ å…³äºæœ¬æ¨¡å‹çš„äº¤å‰ç½‘ç»œçš„ç»†èŠ‚å°±ä»‹ç»åˆ°è¿™é‡Œäº†ã€‚è¿™åº”è¯¥ä¹Ÿæ˜¯æœ¬æ¨¡å‹çš„ç²¾åä¹‹å¤„äº†ï¼Œåé¢å°±ç®€å•äº†ã€‚ 2.3 Deep Networkè¿™ä¸ªå°±å’Œä¸Šé¢çš„D&amp;Wçš„å…¨è¿æ¥å±‚åŸç†ä¸€æ ·ã€‚è¿™é‡Œä¸å†è¿‡å¤šçš„èµ˜è¿°ã€‚ $$h_{l+1}=f(W_{l} h_{l}+ b_{l})$$ å…·ä½“çš„å¯ä»¥å‚è€ƒW&amp;Dæ¨¡å‹ã€‚ 2.4ç»„åˆè¾“å‡ºå±‚è¿™ä¸ªå±‚è´Ÿè´£å°†ä¸¤ä¸ªç½‘ç»œçš„è¾“å‡ºè¿›è¡Œæ‹¼æ¥ï¼Œ å¹¶ä¸”é€šè¿‡ç®€å•çš„Logisticså›å½’å®Œæˆæœ€åçš„é¢„æµ‹ï¼š$$p=\\sigma ([x_{L_{1}}^{T}, h_{L_{2}}^{T}] w_{logits })$$å…¶ä¸­$x_{L_{1}}^{T}$$h_{L_{2}}^{T}$è¡¨ç¤ºäº¤å‰ç½‘ç»œå’Œæ·±åº¦ç½‘ç»œçš„è¾“å‡ºã€‚æœ€åäºŒåˆ†ç±»çš„æŸå¤±å‡½æ•°ä¾ç„¶æ˜¯äº¤å‰ç†µæŸå¤±ï¼š $$loss =-\\frac{1}{N} \\sum_{i=1}^{N} y_{i} \\log (p_{i})+(1-y_{i}) \\log (1-p_{i})+\\lambda \\sum_{l} |w_{i} |^{2}$$ Cross&amp;Deepæ¨¡å‹çš„åŸç†å°±æ˜¯è¿™äº›äº†ï¼Œå…¶æ ¸å¿ƒéƒ¨åˆ†å°±æ˜¯Cross Networkï¼Œ è¿™ä¸ªå¯ä»¥è¿›è¡Œç‰¹å¾çš„è‡ªåŠ¨äº¤å‰ï¼Œ é¿å…äº†æ›´å¤šåŸºäºä¸šåŠ¡ç†è§£çš„äººå·¥ç‰¹å¾ç»„åˆã€‚ è¯¥æ¨¡å‹ç›¸æ¯”äºW&amp;Dï¼ŒCrosséƒ¨åˆ†è¡¨è¾¾èƒ½åŠ›æ›´å¼ºï¼Œ ä½¿å¾—æ¨¡å‹å…·å¤‡äº†æ›´å¼ºçš„éçº¿æ€§å­¦ä¹ èƒ½åŠ›ã€‚ 3. ä»£ç å®ç° (å‚è€ƒåˆ«äººçš„ä»£ç )ä¸‹é¢æˆ‘ä»¬çœ‹ä¸‹DCNçš„ä»£ç å¤ç°ï¼Œè¿™é‡Œä¸»è¦æ˜¯ç»™å¤§å®¶è¯´ä¸€ä¸‹è¿™ä¸ªæ¨¡å‹çš„è®¾è®¡é€»è¾‘ï¼Œå‚è€ƒäº†deepctrçš„å‡½æ•°APIçš„ç¼–ç¨‹é£æ ¼ï¼Œ å…·ä½“çš„ä»£ç ä»¥åŠç¤ºä¾‹å¤§å®¶å¯ä»¥å»å‚è€ƒåé¢çš„GitHubï¼Œé‡Œé¢å·²ç»ç»™å‡ºäº†è¯¦ç»†çš„æ³¨é‡Šï¼Œ è¿™é‡Œä¸»è¦åˆ†ææ¨¡å‹çš„é€»è¾‘è¿™å—ã€‚å…³äºå‡½æ•°APIçš„ç¼–ç¨‹å¼é£æ ¼ï¼Œæˆ‘ä»¬è¿˜ç»™å‡ºäº†ä¸€ä»½æ–‡æ¡£ï¼Œ å¤§å®¶å¯ä»¥å…ˆçœ‹è¿™ä¸ªï¼Œå†çœ‹åé¢çš„ä»£ç éƒ¨åˆ†ï¼Œä¼šæ›´åŠ èˆ’æœäº›ã€‚ä¸‹é¢å¼€å§‹ï¼š ä»ä¸Šé¢çš„ç»“æ„å›¾æˆ‘ä»¬ä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œ DCNçš„æ¨¡å‹æ­å»ºï¼Œå…¶å®ä¸»è¦åˆ†ä¸ºå‡ å¤§æ¨¡å—ï¼Œ é¦–å…ˆå°±æ˜¯å»ºç«‹è¾“å…¥å±‚ï¼Œç”¨åˆ°çš„å‡½æ•°å¼build_input_layersï¼Œæœ‰äº†è¾“å…¥å±‚ä¹‹åï¼Œ æˆ‘ä»¬æ¥ä¸‹æ¥æ˜¯embeddingå±‚çš„æ­å»ºï¼Œç”¨åˆ°çš„å‡½æ•°æ˜¯build_embedding_layersï¼Œ è¿™ä¸ªå±‚çš„ä½œç”¨æ˜¯æ¥æ”¶ç¦»æ•£ç‰¹å¾ï¼Œå˜æˆä½ç»´ç¨ å¯†ã€‚ æ¥ä¸‹æ¥å°±æ˜¯æŠŠè¿ç»­ç‰¹å¾å’Œembeddingä¹‹åçš„ç¦»æ•£ç‰¹å¾è¿›è¡Œæ‹¼æ¥ï¼Œåˆ†åˆ«è¿›å…¥wideç«¯å’Œdeepç«¯ã€‚ wideç«¯å°±æ˜¯äº¤å‰ç½‘ç»œï¼Œè€Œdeepç«¯æ˜¯DNNç½‘ç»œï¼Œ è¿™é‡Œåˆ†åˆ«æ˜¯CrossNet()å’Œget_dnn_output(), æ¥ä¸‹æ¥å°±æ˜¯æŠŠè¿™ä¸¤å—çš„è¾“å‡ºæ‹¼æ¥å¾—åˆ°æœ€åçš„è¾“å‡ºäº†ã€‚æ‰€ä»¥æ•´ä½“ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334def DCN(linear_feature_columns, dnn_feature_columns): # æ„å»ºè¾“å…¥å±‚ï¼Œå³æ‰€æœ‰ç‰¹å¾å¯¹åº”çš„Input()å±‚ï¼Œè¿™é‡Œä½¿ç”¨å­—å…¸çš„å½¢å¼è¿”å›ï¼Œæ–¹ä¾¿åç»­æ„å»ºæ¨¡å‹ dense_input_dict, sparse_input_dict = build_input_layers(linear_feature_columns + dnn_feature_columns) # æ„å»ºæ¨¡å‹çš„è¾“å…¥å±‚ï¼Œæ¨¡å‹çš„è¾“å…¥å±‚ä¸èƒ½æ˜¯å­—å…¸çš„å½¢å¼ï¼Œåº”è¯¥å°†å­—å…¸çš„å½¢å¼è½¬æ¢æˆåˆ—è¡¨çš„å½¢å¼ # æ³¨æ„ï¼šè¿™é‡Œå®é™…çš„è¾“å…¥ä¸Input()å±‚çš„å¯¹åº”ï¼Œæ˜¯é€šè¿‡æ¨¡å‹è¾“å…¥æ—¶å€™çš„å­—å…¸æ•°æ®çš„keyä¸å¯¹åº”nameçš„Inputå±‚ input_layers = list(dense_input_dict.values()) + list(sparse_input_dict.values()) # æ„å»ºç»´åº¦ä¸ºkçš„embeddingå±‚ï¼Œè¿™é‡Œä½¿ç”¨å­—å…¸çš„å½¢å¼è¿”å›ï¼Œæ–¹ä¾¿åé¢æ­å»ºæ¨¡å‹ embedding_layer_dict = build_embedding_layers(dnn_feature_columns, sparse_input_dict, is_linear=False) concat_dense_inputs = Concatenate(axis=1)(list(dense_input_dict.values())) # å°†ç‰¹å¾ä¸­çš„sparseç‰¹å¾ç­›é€‰å‡ºæ¥ sparse_feature_columns = list(filter(lambda x: isinstance(x, SparseFeat), linear_feature_columns)) if linear_feature_columns else [] sparse_kd_embed = concat_embedding_list(sparse_feature_columns, sparse_input_dict, embedding_layer_dict, flatten=True) concat_sparse_kd_embed = Concatenate(axis=1)(sparse_kd_embed) dnn_input = Concatenate(axis=1)([concat_dense_inputs, concat_sparse_kd_embed]) dnn_output = get_dnn_output(dnn_input) cross_output = CrossNet()(dnn_input) # stack layer stack_output = Concatenate(axis=1)([dnn_output, cross_output]) # è¿™é‡Œçš„æ¿€æ´»å‡½æ•°ä½¿ç”¨sigmoid output_layer = Dense(1, activation='sigmoid')(stack_output) model = Model(input_layers, output_layer) return model è¿™ä¸ªæ¨¡å‹çš„å®ç°è¿‡ç¨‹å’ŒDeepFMæ¯”è¾ƒç±»ä¼¼ï¼Œè¿™é‡Œä¸ç”»è‰å›¾äº†ï¼Œå¦‚æœæƒ³çœ‹çš„å¯ä»¥å»å‚è€ƒDeepFMè‰å›¾åŠä»£ç ä¹‹é—´çš„å¯¹åº”å…³ç³»ã€‚ ä¸‹é¢æ˜¯ä¸€ä¸ªé€šè¿‡kerasç”»çš„æ¨¡å‹ç»“æ„å›¾ï¼Œä¸ºäº†æ›´å¥½çš„æ˜¾ç¤ºï¼Œç±»åˆ«ç‰¹å¾éƒ½åªæ˜¯é€‰æ‹©äº†ä¸€å°éƒ¨åˆ†ï¼Œç”»å›¾çš„ä»£ç ä¹Ÿåœ¨githubä¸­ã€‚ 4. DCNç‰¹ç‚¹ è®¡ç®—Cross Networkçš„å¤æ‚åº¦ï¼š æ—¶é—´å¤æ‚åº¦: O(n*K), n = Cross network é‡Œé¢xçš„ç»´åº¦ï¼Œ K= Cross Networkçš„å±‚æ•° ç©ºé—´å¤æ‚åº¦: O(n* k *2), n = Cross network é‡Œé¢xçš„ç»´åº¦ï¼Œ K= Cross Networkçš„å±‚æ•°, ä¹˜2æ˜¯å› ä¸ºæ¯å±‚éƒ½æœ‰1ä¸ªweight vectorå’Œ1ä¸ªbias vector åœ¨å®ç°çŸ©é˜µè®¡ç®—$x_0*x_l^Tw$çš„è¿‡ç¨‹ä¸­ï¼Œæœ‰äººè¯´è¦å…ˆç®—å‰ä¸¤ä¸ªï¼Œæœ‰äººè¯´è¦å…ˆç®—åä¸¤ä¸ªï¼Œè¯·é—®é‚£ç§æ–¹å¼æ›´å¥½ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ å…ˆè®¡ç®—åé¢xlå’Œwçš„å†è®¡ç®—å‰é¢x0ä¼šæ›´å¥½ã€‚ å› ä¸ºå¦‚æœè®¡ç®—å‰é¢x0å’Œxlçš„outer productä¼šç”Ÿæˆä¸€ä¸ªnxnçš„çŸ©é˜µï¼Œä¸ä»…éœ€è¦æ›´å¤šå†…å­˜è€Œä¸”å’Œåé¢çš„weight vectorç›¸ä¹˜æ—¶ä¼šå˜æˆ éœ€è¦O(n^2)çš„ æ—¶é—´ã€‚ è€Œè®¡ç®—åé¢wå’Œxlç›¸ä¹˜æ—¶ä¼šå¾—åˆ°ä¸€ä¸ªscalar valueä¹‹åè®¡ç®—æ–¹ä¾¿ 5. Coding å®ç°ï¼ˆPyTorchï¼‰çœ‹è¿™é‡Œï¼š https://wenkangwei.gitbook.io/leetcode-notes/deep-learning/deep-and-cross-network-dcn 6. Reference ã€Šæ·±åº¦å­¦ä¹ æ¨èç³»ç»Ÿã€‹ â€” ç‹å–† Deep&amp;Crossæ¨¡å‹åŸè®ºæ–‡ AIä¸Šæ¨è ä¹‹ Wide&amp;Deepä¸Deep&amp;Crossæ¨¡å‹(è®°å¿†ä¸æ³›åŒ–å¹¶å­˜çš„åä¸½è½¬èº«ï¼‰ Wide&amp;Deepæ¨¡å‹çš„è¿›é˜¶â€”Cross&amp;Deepæ¨¡å‹","link":"/2021/05/20/Recommendation-System-6-DCN/"},{"title":"ensemble-learning-Stacking","text":"IntroductionStackingé›†æˆç®—æ³•å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªä¸¤å±‚çš„é›†æˆï¼Œç¬¬ä¸€å±‚å«æœ‰å¤šä¸ªåŸºç¡€åˆ†ç±»å™¨ï¼ŒæŠŠé¢„æµ‹çš„ç»“æœ(å…ƒç‰¹å¾)æä¾›ç»™ç¬¬äºŒå±‚ï¼Œ è€Œç¬¬äºŒå±‚çš„åˆ†ç±» å™¨é€šå¸¸æ˜¯é€»è¾‘å›å½’ï¼Œä»–æŠŠä¸€å±‚åˆ†ç±»å™¨çš„ç»“æœå½“åšç‰¹å¾åšæ‹Ÿåˆè¾“å‡ºé¢„æµ‹ç»“æœã€‚ Stackingè€Œåœ¨Stackingé‡Œé¢ï¼Œ åœ¨ç¬¬ä¸€å±‚çš„æ¨¡å‹æ˜¯é€šè¿‡K-fold Cross validation å½¢å¼è¿›è¡Œè®­ç»ƒå’Œé¢„æµ‹ã€‚ è€ŒBlendingçš„æ€è·¯ç›¸å¯¹äºæŠŠK-fold Cross validationæ¢æˆHold-Outã€‚ä»¥ä¸‹æ˜¯Stacking æ­¥éª¤: (å›¾ç‰‡æ¥æº: https://zhuanlan.zhihu.com/p/91659366) Stacking çš„æ­¥éª¤æ˜¯ï¼š å…ˆæŠŠtraining set çš„æ•°æ®è¿›è¡ŒK-fold cross validation (sklearn é‡Œé¢default 2fold) æ¯ä¸ªæ¨¡å‹éƒ½æœ‰Kä¸ªfoldçš„predictionã€‚ä¹‹åå¦‚æœæœ‰å¤šä¸ªä¸åŒçš„æ¨¡å‹ï¼Œå°±æœ‰å¤šä¸ªK-foldçš„predictionã€‚æ¯”å¦‚è¯´å¦‚æœæˆ‘å…ˆæŠŠè®­ç»ƒé›†åˆ†æˆ 5fold,é‚£ä¹ˆå°±æ˜¯[X1, X2 â€¦ X5]. å¦‚æœæˆ‘æœ‰ä¸¤ä¸ªä¸åŒçš„æ¨¡å‹, æ¯”å¦‚KNNå’ŒRandomForesté‚£ä¹ˆå¯¹åº”çš„predictionåˆ†åˆ«æ˜¯[A1, A2â€¦A5], [B1, B2, â€¦ B5]ã€‚ä¹‹åæˆ‘ä»¬å¯ä»¥æŠŠå¯¹åº”åºå·çš„predictionè¿›è¡Œaverageè®¡ç®—ã€‚ æ¯”å¦‚ [(A1+B1)/2, (A2+B2)/2 â€¦ (A5+B5)/2 ]ã€‚ ä¹‹åæŠŠè¿™äº›æ¨¡å‹çš„è¾“å‡ºä½œä¸ºç¬¬äºŒå±‚æ¨¡å‹çš„è¾“å…¥ã€‚ç¬¬äºŒå±‚æ¨¡å‹ä¸€èˆ¬æ˜¯logistics regressionï¼Œè¿™ä¸ªå–å†³äºå…·ä½“ä»»åŠ¡ åœ¨test seté‡Œé¢ï¼Œ ç”¨ç¬¬ä¸€å±‚çš„æ¨¡å‹å¯¹test setçš„è¾“å‡ºè¿›è¡Œå¹³å‡å€¼è®¡ç®—å¾—åˆ°ç¬¬äºŒå±‚æ¨¡å‹çš„æµ‹è¯•é›†çš„è¾“å…¥ï¼Œä¹‹åç¬¬äºŒå±‚æ¨¡å‹é¢„æµ‹è¾“å‡ºã€‚ Source CodeGithubæºç :https://github.com/wenkangwei/Datawhale-Team-Learning/blob/main/Ensemble-Learning/Stacking.ipynb PropertiesBlendingä¸Stackingå¯¹æ¯”ï¼Œ Blendingçš„ä¼˜ç‚¹åœ¨äº: ä½¿ç”¨Cross validation è¿›è¡Œæ•°æ®çš„é¢„æµ‹ä½œä¸ºç¬¬äºŒå±‚è¾“å…¥ï¼Œèƒ½å……åˆ†åˆ©ç”¨æ•°æ® ç›¸å¯¹äºBlendingï¼Œå› ä¸ºç”¨äº†Cross validationä¸å®¹æ˜“è¿‡æ‹Ÿåˆ ç¼ºç‚¹åœ¨äºï¼š ç”¨ Cross validation ä¹‹åè®¡ç®—æ…¢ Reference[1] https://zhuanlan.zhihu.com/p/91659366[2] https://github.com/datawhalechina/team-learning-data-mining/tree/master/EnsembleLearning","link":"/2021/05/13/ensemble-learning-Stacking/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/06/28/hello-world/"},{"title":"tensorflow-practice","text":"Common packages for data12345import numpy as npimport pandas as pdimport matplotlib.pyplot as plt%matplotlib inlineimport seaborn as sns Tensorflow Practice Data set loading and visualization Data Preprocessing/transforming Modeling using tf.nn (more basic) / tf.keras (advance and convenient API for modeling) Performance Visualization Model saving and reuse, reload 123456import tensorflow as tfimport tensorflow.keras as keras# This one-hot convert words to index number rather than binary formfrom tensorflow.keras.preprocessing.text import one_hot#tf.one_hot import text/ labels into binary 0,1 form without compressionfrom numba import cuda 12# Check if GPU is enabledprint(cuda.gpus) &lt;Managed Device 0&gt;, &lt;Managed Device 1&gt; Basic Practise tf.constant contain types of data. Operation like +, -, *, / , should be applied to data with same types only 12345678910ls = np.random.randint(0,100,50)ls= tf.constant(ls)x1= tf.constant(1)x2= tf.constant(2)x4= tf.constant(5)x3 = x1+x2*x4tf.print(x3,[x1,x2])tf.print(tf.argsort(ls))c = tf.argsort(ls) 11 [1, 2] [32 24 27 ... 20 40 49] Practice with Text+Numeric type data: titanic data12345678TRAIN_DATA_URL = \"https://storage.googleapis.com/tf-datasets/titanic/train.csv\"TEST_DATA_URL = \"https://storage.googleapis.com/tf-datasets/titanic/eval.csv\"# The first param in get_file: the name of dataset to save# The second param: url to the dataset trainset_path = keras.utils.get_file('titanic_train.csv', TRAIN_DATA_URL)testset_path = keras.utils.get_file('titanic_test.csv', TEST_DATA_URL)trainset_path, testset_path Downloading data from https://storage.googleapis.com/tf-datasets/titanic/train.csv 32768/30874 [===============================] - 0s 0us/step Downloading data from https://storage.googleapis.com/tf-datasets/titanic/eval.csv 16384/13049 [=====================================] - 0s 0us/step ('/home/wenkanw/.keras/datasets/titanic_train.csv', '/home/wenkanw/.keras/datasets/titanic_test.csv') 123# Load CSV file with pandastrainset = pd.read_csv(trainset_path)testset = pd.read_csv(testset_path) 1trainset.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } survived sex age n_siblings_spouses parch fare class deck embark_town alone 0 0 male 22.0 1 0 7.2500 Third unknown Southampton n 1 1 female 38.0 1 0 71.2833 First C Cherbourg n 2 1 female 26.0 0 0 7.9250 Third unknown Southampton y 3 1 female 35.0 1 0 53.1000 First C Southampton n 4 0 male 28.0 0 0 8.4583 Third unknown Queenstown y 1trainset.groupby('sex').head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } survived sex age n_siblings_spouses parch fare class deck embark_town alone 0 0 male 22.0 1 0 7.2500 Third unknown Southampton n 1 1 female 38.0 1 0 71.2833 First C Cherbourg n 2 1 female 26.0 0 0 7.9250 Third unknown Southampton y 3 1 female 35.0 1 0 53.1000 First C Southampton n 4 0 male 28.0 0 0 8.4583 Third unknown Queenstown y 5 0 male 2.0 3 1 21.0750 Third unknown Southampton n 6 1 female 27.0 0 2 11.1333 Third unknown Southampton n 7 1 female 14.0 1 0 30.0708 Second unknown Cherbourg n 9 0 male 20.0 0 0 8.0500 Third unknown Southampton y 10 0 male 39.0 1 5 31.2750 Third unknown Southampton n","link":"/2020/07/14/tensorflow-practice/"},{"title":"CPSC 6300 Final Report","text":"TITLE: KKBox Music Recommendation SystemTeam Members: Wenkang Wei, ShuLe ZhuDate: 12/5/2020Problem Statement and MotivationProblem statementAs the public is listening to all kinds of music and there is a diversity of the favors of different individuals in listening music, music users may choose different music platforms based on which platform can provide the kinds of music closest to their tastes. In order to help music platforms figure out how to recommend suitable kinds of music and songs to individuals or groups so that they can provide better services and retain users, it is necessary to analyze the tastes of individuals and the public in listening to music and explore the chances that users may repeat listening some songs based on data analysis. In addition, users, who listen to a large number of songs and add many songs to their favorite albums, usually forget what songs they have collected and which songs they like when trying to re-play those songs. In this case, it is necessary to build a recommendation system to help us predict the songs users may repeat listening to after the userâ€™s a very first observable listening event. Motivation and GoalWe are to construct a recommendation system to predict the chances of a user listening to a song repetitively after the first observable listening event within a time window was triggered. If there are recurring listening event(s) triggered within a month after the userâ€™s very first observable listening event, its target is marked 1, and 0 otherwise in the training set. By constructing such a recommendation system, we are able to remind music users of their favorite songs and increase the rate of the audience as well as the benefit to the music platform. Introduction and Description of DataMusic is important in our daily life and the role of music is determined by people and the environment. Music has a lot of help, for example, it can cultivate sentiment and reduce stress. However, some people donâ€™t need music in their lives or live in music. People who never listen to music or harmony feel that music has a low sense of existence. But in fact, in their everyday lives, they actually have songs, ringing alarms, wind, and rain. So, the role of music performance is one of the most important companions in life. In order to recommend suitable music to users in music platforms efficiently, a recommendation system is an essential part of music platforms. A recommendation system is a subclass of an information filtering system that seeks to predict the â€œratingâ€ or â€œpreferenceâ€ a user would give to an item. Due to the fact that there are millions of kinds of music, composers, artists, and other information from users, it is hard for users to pick the kinds of music they like from millions of songs and remember which songs they like and want to re-play. Usually, users forget the songs they have added to their favorite song album due to the large number of songs they have a play. Hence it is necessary to build a music recommendation system to recommend kinds of music, which users prefer and are likely to repeat listening to. The dataset we collected is KKBox Music 1.7GB dataset. Our dataset is from Kaggle KKBox-Music-Recommendation-Challenge. You can also get the dataset from our GoogleDrive . The description of the dataset is as follow: Descriptions of dataset: train.csv msno: user id song_id: song id source_system_tab: the name of the tab where the event was triggered. System tabs are used to categorize KKBOX mobile apps functions. For example, tab my library contains functions to manipulate the local storage, and tab search contains functions relating to search. source_screen_name: name of the layout a user sees. source_type: an entry point a user first plays music on mobile apps. An entry point could be album, online-playlist, song .. etc. target: this is the target variable. target=1 means there are recurring listening event(s) triggered within a month after the userâ€™s very first observable listening event, target=0 otherwise . test.csv id: row id (will be used for submission) msno: user id song_id: song id source_system_tab: the name of the tab where the event was triggered. System tabs are used to categorize KKBOX mobile apps functions. For example, tab my library contains functions to manipulate the local storage, and tab search contains functions relating to search. source_screen_name: name of the layout a user sees. source_type: an entry point a user first plays music on mobile apps. An entry point could be album, online-playlist, song .. etc. sample_submission.csv sample submission file in the format that we expect you to submit id: same as id in test.csv target: this is the target variable. target=1 means there are recurring listening event(s) triggered within a month after the userâ€™s very first observable listening event, target=0 otherwise . songs.csv The songs. Note that data is in unicode. song_id song_length: in ms genre_ids: genre category. Some songs have multiple genres and they are separated by | artist_name composer lyricist language members.csv user information. msno city bd: age. Note: this column has outlier values, please use your judgement. gender registered_via: registration method registration_init_time: format %Y%m%d expiration_date: format %Y%m%d song_extra_info.csv song_id song name - the name of the song. isrc - International Standard Recording Code, theoretically can be used as an identity of a song. However, what worth to note is, ISRCs generated from providers have not been officially verified; therefore the information in ISRC, such as country code and reference year, can be misleading/incorrect. Multiple songs could share one ISRC since a single recording could be re-published several times. In preliminary EDA, we take a look to the features in different data files. 1train_df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 7377418 entries, 0 to 7377417 Data columns (total 6 columns): # Column Dtype --- ------ ----- 0 msno object 1 song_id object 2 source_system_tab object 3 source_screen_name object 4 source_type object 5 target int64 dtypes: int64(1), object(5) memory usage: 337.7+ MB 1test_df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 2556790 entries, 0 to 2556789 Data columns (total 6 columns): # Column Dtype --- ------ ----- 0 id int64 1 msno object 2 song_id object 3 source_system_tab object 4 source_screen_name object 5 source_type object dtypes: int64(1), object(5) memory usage: 117.0+ MB 1song_df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 2296320 entries, 0 to 2296319 Data columns (total 7 columns): # Column Dtype --- ------ ----- 0 song_id object 1 song_length int64 2 genre_ids object 3 artist_name object 4 composer object 5 lyricist object 6 language float64 dtypes: float64(1), int64(1), object(5) memory usage: 122.6+ MB 1members_df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 34403 entries, 0 to 34402 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 msno 34403 non-null object 1 city 34403 non-null int64 2 bd 34403 non-null int64 3 gender 14501 non-null object 4 registered_via 34403 non-null int64 5 registration_init_time 34403 non-null int64 6 expiration_date 34403 non-null int64 dtypes: int64(5), object(2) memory usage: 1.8+ MB In the dataset description above, we can obtain the information from both sources of songs, songs, and members. By using the information of sources of songs, we can know where the songs re-played by users are from. The information about songs and members can provide us with details about what kinds of songs are often re-played by users, or what types of members are more likely to repeat playing songs. Such kinds of data can give us insight into usersâ€™ behaviors of repeating listening to music. Based on the information from members, songs and sources of songs, we can use them as the input features to machine learning model. The target is the chance of a user listening to a song repetitively after the first observable listening event within a time window was triggered. If there are recurring listening event(s) triggered within a month after the userâ€™s very first observable listening event, its target is marked 1, and 0 otherwise in the training set. Hence, the question can be defined as a binary classification problem and the prediction from machine learning model should be either possibility of the chance, or 0 , 1 binary value indicating if there is a chance. Literature Review/Related WorkAs for the KKBox music recommendation system project, many Kaggle users choose to use a light gradient boosting machine (LGBM) due to its simplicity in preprocessing a large amount of data, and its fast computation speed. Based on the blog [5], the LGBM model is a light gradient boosting machine model, which is based on multiple decision tree models and use gradient boosting ensemble learning method to improve the training accuracy. One work from Kaggle we refer to [3] is to use the LGBM boosting machine as a baseline to fit the dataset and train the model using binary cross-entropy loss since the prediction task in this project is a binary classification task. In addition to the LGBM model, there are some deep learning models used for the recommendation system. One of the neural network models is called the wide and deep model [1] . In this model, first uses an embedding network to transform the sparse categorical data into dense numerical data in one branch. Then it merges the branch of categorical data and the branch of numerical features together to feed the traditional network in the main branch. The main branch of the neural network works as a classifier while the embedding neural network works as a transformation network to preprocess the data. Since in this Kaggle project, no one tries such a neural network model for this task, we are interested in trying this model and see how it works in this problem. Then we compare it with the LGBM models. Modeling ApproachTask - Since this project is to predict the chances of a user listening to a song repetitively after the first observable listening event within a time window was triggered, the output from the machine learning model is the possibility that a user will repeat listening to a song after the first listening event. Hence, this problem can be modeled as a binary classification problem Loss Function - Since this task is a binary classification problem, we simply select binary cross-entropy loss as the loss function used to train parametric machine learning models, like deep learning models, logistic regression, etc. Evaluation Metric - The evaluation metric to measure the performance of the machine learning model is selected to be accuracy and AUC (area under the curve) since we care about how accurate the models could be. LGBM Modeling - Light Gradient Boosting Machine (LGBM) model is a tree-based modelï¼Œthis model merge and train multiple decision tree models to do classification or regression tasks, using the Boosting ensemble learning process. It will automatically encode categorical data into vectors and train models for labels or one-hot encoding. Since it provides a fast way to transform categorical data and train models with good accuracy performance based on the results from leaderboard in Kaggle, we try it here and tune its parameters to fit the data.Here is the reference to use LGBM: https://lightgbm.readthedocs.io/en/latest/Quick-Start.html Wide and Deep Neural Network model - This model using the embedding network in the neural network, this model converts categorical attributes into dense vectors, allowing one to reduce the dimension of categorical data and remove key features such as PCA. Then for feature selection and classification in the main branch, it blends dense embedded vectors with numerical data. The main branch is a typical neural network that acts as a classification function using linear layers, activation functions (relu, softmax, sigmoid). The output is the possibility that the user may repeat listening to the music.The architecture of Wide and Deep Model is referred to https://github.com/zenwan/Wide-and-Deep-PyTorch Baseline model - We choose our baseline model as LGBM boosting machine model with following setings: â€˜objectiveâ€™: â€˜binaryâ€™, learning_rate = 0.3 , num_leaves = 110, bagging_fraction = 0.95, bagging_freq = 1, bagging_seed = 1, feature_fraction =0.9, feature_fraction_seed =1, max_bin = 256, max_depth = 10, num_rounds = 200.After we choose the baseline model, we tune the LGBM model by changing the max_depth parameter to be [10 , 15, 20 , 25, 30] to see how the depth affects our LGBM performance. After that, we also implement the Wide and Deep Model with learning rate = 0.001, binary cross-entropy loss, and 2 epochs. The reason why we use different settings on the Wide and Deep model is that the training process of the neural network is very slow and the convergence speed of the model is slower than the LGBM model. The training loss of the neural network is easy to increase after decreasing for some iterations. So we need to tune some parameters to train the neural network model. Project Trajectory, Results, and InterpretationOur goal in this project doesnâ€™t change. It is to construct a recommendation system to predict the chances of a user listening to a song repetitively after the first observable listening event within a time window was triggered. If there are recurring listening event(s) triggered within a month after the userâ€™s very first observable listening event, its target is marked 1, and 0 otherwise in the training set. Only one thing we change is that we choose to use neural network model and light gradient boosting machine (LGBM) model for this project, rather than using traditional models like KNN, logistic regression, Here is the trajectory of our project Timeline Date Assignment Wenkang Shule Oct 22 Proposal âœ“ âœ“ week 1 Set up environment and Exploratory Data Analysis (EDA) âœ“ âœ“ week 2 Data preprocessing âœ“ week 3 Modeling âœ“ Nov 12 Interim Report âœ“ âœ“ week 4 Training model and Evaluation âœ“ week 5 Training model and Evaluation âœ“ week 6 Wrap up and preparing website presentation âœ“ âœ“ week 7 Writting Final Report âœ“ âœ“ Dec 10 Website and Final Report âœ“ âœ“ Dec 13 Notebooks and other supporting materials âœ“ âœ“ In this project, we follow these steps to build our data pipeline and recommendation system model:First, in the exploratory data analysis step, we use visualization techniques to visualize and plot the features from the dataset to explore the correlation across features and find which features are most related to the target. Here are partial results from EDA section Genre Counts Artist Count Count of system tabs, screen names, source types In the Exploratory Data Analysis (EDA) part, we first analyze Song information by plotting and visualizing the counts of song genres, composers, artists, and the counts of source types, source screen names, system tabs. In this part, we find that the distributions of the counts of song genres, composers, artists are long-tailed distribution. That is, most users prefer listening to specific genres of music or songs created by specific artists, composers. In this case, we can know that those specific genres of music or songs from specific composers, artists are more likely to be re-played by users. In addition, when visualizing the counts of users vs source screen names, system tabs, and source types, we find that most users are more likely to repeat listening to music from their local sources, local library, rather than from online sources. That is, the features like source types, screen names, and system tabs provide important information for our recommendation system. Hence we choose to keep such kinds of features for modeling later. Later, we analyze Member information, like visualizing the count of bd/age attribute and analyzing the correlation between different attributes using the heatmap plot. In this part, we find that there are many outliers in bd/age features with values outside the range of [0, 100]. After we remove such kind of outliers, we find that most users have ages between 20 to 40. After this, we try to plot bivariate plots to visualize and analyze the relationship between attributes, like city and age/bd, expiration date, and target. what we find is that registration_init_year is negatively correlative to bd/age, city, registered_via. Song_length is also negatively correlative to language. In order to find which features are most related to targets, we plot the correlation matrix using a heatmap to visualize the correlation across features. In this part, since we find almost all other features have similar correlation values to the target, we choose to keep those features for modeling. Then in data preprocessing, we clean and transform the features to a suitable format, like converting String DateTime data to DateTime format and separate year, month, day as new features, removing the outliers in bd/age features, filling missing values, creating new features like count of composers, artist, genres and converting object data type to categorical data type before training model Later, we also construct a data pipeline to extract, transform, load data set by integrating the operations in the data preprocessing step into one single transformation function, which enable us to easily clean and transform dataset directly. After the data preprocessing and transformation step, we split the dataset into a training set (80% of the dataset) and a validation set (20% of the dataset) for training and validating our models. We also determine the Loss function (binary cross-entropy), evaluation metric (accuracy and AUC) to train our Light Gradient Boosting machines (LGBM) models and Wide and Deep Neural network model. During training our LGBM models, we are interested in how the max_depth affect the model performance, so we also try different max_depth parameters to tune our LGBM models. In the Model evaluation step, we simply use the validation dataset to validate the final trained models and then let models make predictions on the test set from Kaggle and submit predictions to Kaggle to see the final evaluation scores. Accuracy Results on our validation on LGBM model to see effect of max_depth on accuracy Index Lgbm with max_depth Validation Accuracy 0 10 0.709764 1 15 0.719106 2 20 0.723689 3 25 0.725822 4 30 0.728842 We can observe that as the value of max_depth of the decision tree in the Boosting machine increases, both validation accuracy, and test accuracy increase gradually. It implies that the performance of our LGBM models may be improved by increasing the max_depth. As increasing max_depth can improve the learning/fitting ability of the LGBM model, it is possible that tuning other parameters like the number of leaves, the number of training epochs may also help improve the accuracy and let models better fit the dataset. Accuracy Results on Kaggle Testset Model name private score public score LGBM Boosting Machine Model 4 0.67423 0.67256 LGBM Boosting Machine Model 3 0.67435 0.67241 LGBM Boosting Machine Model 2 0.67416 0.67208 LGBM Boosting Machine Model 1 0.67416 0.67188 LGBM Boosting Machine Model 0 0.67206 0.66940 Wide and Deep model 0.61628 0.61117 Best Accuracy Results on Kaggle Testset from Kaggle Leaderboard Ranking name Score Entries 1 Bing Bai 0.74787 263 In the final results on test data from Kaggle, we can see that light gradient boosting machines have the accuracy performance better than the Wide and Deep Neural Network model. The best score in LGBM models is 67.256% while the Wide and Deep model has an accuracy of 61.11%. Although the Wide and Deep model performance is not so well, we may improve its performance by tunning the parameters like dropout rate in the neural network, learning rate, training epochs in the future. In addition, in our experiments we try two epochs only, this is because we run the program in Google Colab and also try it in the Kaggle platform, but the hardware is not powerful enough to train the model quickly and there is a time limit in using GPU. Therefore, we can try better hardware to boost the training process in the future. Whatâ€™s more, the best testing score from the Kaggle leaderboard is only 74.7887%, which means that this project is still challenging. It could be due to the difficulty in parsing and transforming the dataset to extract more meaningful patterns. The limitations of designing and training good models are also some factors since we donâ€™t have enough computation power to train a large model, like Google, OpenAI. Overall, our works explore the effect of max_depth on LGBM modelsâ€™ performance and also compare the performance of the Wide and Deep model with the performance of the LGBM model. Conclusions and Future WorkIn this project, there are still a few things that perform not very well. One obvious thing is the performance of the Wide and Deep model. We can easily see that the performance from the neural network model is low. This could be due to the small training epochs we use., as we use only 2 epochs to train the model using limited computation resources (Google colab). Whatâ€™s more, we can also try different neural network architecture to better fit the dataset, or tune the parameters like learning rate, weight decay in the network to increase the learning ability of our network. As for the LGBM model, it seems like the LGBM model can better fit the dataset when using more training epochs and a larger max_depth value. We can also try to tune other parameters like the number of leaves, etc. Overall, in the future, we may do the followings to improve our project:In this project, there are several things we can improve in the future: We can use a better hardware platform for training models, rather than using Google Colab or Kaggle platform, so that we can better train the deep learning model. Tune the LGBM models using a grid search and choose larger max_depth values or tune other parameters Try to create more new features from text attributes like composer, lyricist, artist and use feature importance methods to pick features that most contribute to the prediction In conclusion, we collect a 1.7GB KKBOX music dataset from Kaggle and do exploratory data analysis (EDA) on the data by visualizing the attributes and compute the correlations among features. Then we clean the dataset by removing outliers from age/bd attributes, filling missing categorical data with new labels, and missing numerical data with median value. We also transform the text data and create new features. After that, we use 80% dataset as training set and 20% dataset as a validation set.In Modeling and Evaluation, we use LGBM models and Wide &amp; Deep Neural network models to fit the dataset and also tune the max_depth parameter in LGBM to do binary classification tasks. The best accuracy performance of our models is 67.25% while the best accuracy from the Kaggle leaderboard is about 74%. In the end, we also summarize the future works to improve the project, like using better hardware resources, tunning other parameters of models, and explore more useful features for training. References[1] https://github.com/zenwan/Wide-and-Deep-PyTorch/blob/master/wide_deep/torch_model.py [2] https://www.kaggle.com/c/kkbox-music-recommendation-challenge/submit [3] https://www.kaggle.com/asmitavikas/feature-engineered-0-68310 [4] https://blog.statsbot.co/recommendation-system-algorithms-ba67f39ac9a3 [5] https://medium.com/@pushkarmandot/https-medium-com-pushkarmandot-what-is-lightgbm-how-to-implement-it-how-to-fine-tune-the-parameters-60347819b7fc [6] https://towardsdatascience.com/how-to-build-a-wide-and-deep-model-using-keras-in-tensorflow-2-0-2f7a236b5a4b [7] https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.Dataset.html#lightgbm.Dataset Support Materials Dataset:You can find the dataset from Kaggle: https://www.kaggle.com/c/kkbox-music-recommendation-challenge/data Or you can get the dataset from our Google Drive: https://drive.google.com/file/d/1-WJHZUWFtz9ksfvFoX-dc-ZKjZ6fTk0D/view?usp=sharing Link to Our website/ notebook in databrick platform:https://databricks-prod-cloudfront.cloud.databricks.com/public/4027ec902e239c93eaaa8714f173bcfc/3546981394788271/3905787926422076/7844345949955417/latest.html Link to Our notebook in Google Colab (This notebook is as same as notebook in databrick, but in Colab, you can directly run it after copying it to your drive):https://colab.research.google.com/drive/1dssuTVKvDXM0zULihRt4tJUoOUoCxaFj?usp=sharing Github repository of this project:https://github.com/wenkangwei/cpsc6300-final-project Declaration of academic integrity and responsibilityIn your report, you should include a declaration of academic integrity as follows: 12345With my signature, I certify on my honor that:The submitted work is my and my teammates' original work and not copied from the work of someone else.Each use of existing work of others in the submitted is cited with proper reference.Signature: ___Wenkang Wei_________ Date: ______12/4/2020________ 12345With my signature, I certify on my honor that:The submitted work is my and my teammates' original work and not copied from the work of someone else.Each use of existing work of others in the submitted is cited with proper reference.Signature: ___ShuLe Zhu_________ Date: ______12/4/2020________ CreditThe above project template is based on a template developed by Harvard IACS CS109 staff (see https://github.com/Harvard-IACS/2019-CS109A/tree/master/content/projects).","link":"/2020/12/08/report/"},{"title":"Statistic- 1 Hypothesis-Testing","text":"Introduction: Hypothesis testingThis article will introduce what is hypothesis testing and some teminologies, like p-value, significant level, confidence level, etc.The outline of this article is as follow: what is hypothesis testing What components are in Hypothesis testing and How Hypothesis testing Distribution of the null hypothesis (Center limit theorem) Significant level and confidence level P-value Overall Steps in Hypothesis testing When to use hypothesis testing What is Hypothesis testingHypothesis testing is a procedure to determine if a hypothesis about an estimated difference is statistically meaningful and should be rejected or not. If the hypothesis is rejected, then we will choose alternative competing hypothesis For example, when we are designing an APP and have two different styles of the interface: Red and Green. Then we make an hypothesis that Red color style can attract more users than the Green style. The alternative competing hypothesis is that Red color style can not attract more users than Green style. Then in hypothesis testing is to determine if we should reject the hypothesis that red style can attract more users than green and choose another competing hypothesis that there is no difference between two styles. Main idea behind Hypothesis testingComponents in Hypothesis testingThe components in Hypothesis testing are as follow: Null Hypothesis H0: the original hypothesis assuming that the estimated difference is slight enough and can be regarded as no difference. Alternative Hypothesis H1: the alternative competing hypothesis that we use to challenge the null hypothesis. Usually H1 assumes that observed difference between groups should be considered.Note that alternative hypothesis is mutually exclusive from Null hypothesis. Evidence/ Observation that is used to challenge the Null hypothesis. Note that if Null hypothesis is statistically meaningful and held, then the possibility of the occurence of this evidence will be small. Idea behind Hypothesis testingThe idea behind hypothesis testing is to use proof of contradiction to reject the null hypothesis. It is to use the evidence/observation, which seems like an extreme case under hypothesis H0 and may be able to challenge the null hypothesis, to work as a contradiction to reject H0. However, whether the evidence/ observation is strong enough to work as an contradiction to reject H0 should be determined. Example 1:H0: All bird can fly. H1: Not all bird can fly. Evidence: penguin can not fly.We can see that in this case the observation that penguin can not fly is a strong enough to be a contradiction to H0, since all penguins can not fly. Example2:H0: bird eats food. H1: bird doesnâ€™t eat foodEvidence: one bird in the zoo didnâ€™t eat my food when I try to feed it.Here we can see the evidence is just a specific case while that all birds eat food is a fact. Hence the evidence is not strong enough to reject H0. In order to test whether an evidence is strong enough to reject H0, P-value, significant level, confidence level, power will be introduced later. One important note is that in hypothesis testing, we can only determine if we should reject the hypothesis or not. We CAN NOT prove that the hypothesis we specify is correct or the hypothesis is accepted.If the hypothesis is not rejected, it just means that the possibility that the hypothesis goes wrong is statistically small enough so that we can not observe the wrong cases using current observation method. It doesnâ€™t mean the hypothesis is actually correct or should be accepted. Center limit theoremThe central limit theorem states that if you have a population with mean Î¼ and standard deviation Ïƒ and take sufficiently large random samples from the population with replacementtext annotation indicator, then the distribution of the sample means will be approximately normally distributedï¼Œ even the real distribution of samples is not Normal distribution. Due to Center Limit theorem, when we samples large amount data for H0 and H1, the distribution of H0 and H1 are normal distribution, shown as below When we plot the distribution of H0 and H1 in the same space, it would look like this (assume the left one is H0, and the right one is H1) where the x axis represent feature X and y-axis represent the possibility density function value.We can see that two distributions have the overlapping region. If we want to determine when to reject H0, we need a threshold of feature x (a vertical line) to separate H0 and H1.Then to find such threshold, it involves the concept of significant level and p-value P-valueWhat is p-valueP-value is the probability under the assumption of no effect or no difference (null hypothesis H0), of obtaining a result equal to or more extreme than what was actually observed. (åœ¨H0=trueçš„å‡è®¾å‰æä¸‹/H0=Trueçš„distributionä¸‹,å–å¾—æ¯”ç›®å‰çš„evidence/observation åŒç­‰æç«¯æˆ–æ›´åŠ æç«¯æ›´åŠ æç«¯çš„äº‹ä»¶çš„æ¦‚ç‡). The P stands for probability and measures how likely it is that any observed difference between groups is due to chance. In other words, P-value actually measure how strong the evidence is to reject H0. If P-value is larger, then the strenght of evidence to reject H0 is weaker. Otherwise, the strenght is stronger. Example: Assume I am sampling a random number from a range [-1000, 1000] and assumes that the distributions of number in this range is normal distribution with mean =0. An observation is a sample with value =900. Then the P-value of this observation is the possibility of obtaining sample &gt;=900. In the plot of possbility density function, P-value represents the area under curve in X&gt;=900. Significant level and confidence levelIn order to determine whether reject H0 or not, we need to define a threshold for P-value and this leads to the concepts of significant level and confidence level. Significant levelâ€œSignificantâ€ means how significant the difference between groups is so that we should consider such difference is meaningful. Significant level is usually notated as $\\alpha$ and $\\alpha$=P(reject H0 | H0 =true). significant level is the possibility of rejecting H0 when H0 is true. Moreover, the error that rejecting H0 when H0 is true is called Type I error. Hence Significant level is also the possibility of the occurence of Type I error / Type I error rate (Significant error = Type I error) confidence levelConfidence level is the possibility of retaining H0 when H0 is true. Hence we know that confidence level = 1- significant level = $1-\\alpha$Confidence interval is the region outside the shadow region of $\\alpha$ in the distribution of H0=true. In the possibility density function, We can see that the shadow region in the figure represent a single side significant level (as it is possibility, in density function, it represents an area). Then the area of shadow region = $\\alpha$ When to reject H0if P-value &lt; $\\alpha$, we reject H0 and choose H1. if P-value &gt;=$\\alpha$, retain H0 if an observation X on the x-axis is outside of shadow region, that is, P-value, P(x&gt;=X) is greater than or equal to significant level, then we think observation X is common under null hypothesis H0 and we can not use X to reject H0. if P-value is smaller than significant level / observation X fall inside shadow region, then the difference between groups will be considered and we reject H0 and choose H1. In other words, the observation X is too rare so that we donâ€™t consider it satisfies null hypothesis and hence it becomes a contradiction to reject H0. Note: significant level and confidence level is set by user and the value of significant level is usually 0.05 or 5%. This also means that users assume the possibility of rejecting a true hypothesis H0 due to some extreme cases under current observation method should be smaller than significant level $\\alpha$. Retain region and powerNow, we are considering the alternative hypothesis H1 rather than H0. Assume the distribution from H1 is normal distribution as well. Beta/retain regionThe yellow region of distribution of H1=True is the retain region for H0 and the area of the yellow region is $\\beta$, which represents the possibility of retaining H0 when H1=True. If the observation value X on x-axis falls into the yellow region, then we retain Hypothesis H0.$\\beta$ = P(retain H0 | H0 = False) = Type II error rate ( possibility to retain H0 when H0 is false under assumption H1=True) Powerpower is possibility of rejecting null hypothesis H0 and power = 1- $\\beta$.if power is set to be larger, then testing could be easier to detect and reject false Null hypothesis. But if power is too large, it would reject a good hypothesis as well, despite the null hypothesis is true. Note that there is a tradeoff between $\\alpha$ and $\\beta$. When we set smaller $\\alpha$ value to decrease the Type I error rate (reject H0 when H0 is True), then $\\beta$ / Type II Error rate (retain H0 when H0 is False)will increase . Usually $\\beta$ is not set by user, but it can be calculated using p-value and $\\alpha$. Usually $\\beta$ is around 20% Type I and Type II ErrorNow Letâ€™s consider the distributions of hypothesis that H0=True (left) and the hypothesis that H1 = True (right) Together. Both distributions are estimated by sampling. Since the yellow region $\\beta$ in distribution of H1= True and confidence region of distribution of H0 = True represent the regions to retain H0, we can put two distribution together. Then the vertical line separates the region of retaining H0 (left) and rejecting H0 (right). Remember that $\\alpha$ = Type I error rate = P(reject H0 | H0 = True) and $\\beta$ = Type II error rate = P(retain H0 | H0 = False) and there is trade-off between Type I error rate and Type II error rate. When we lower significant level $\\alpha$, $\\beta$ will increase. In other words, lowering threshold to reject H0 can increase possibility of retaining H0, but also null hypothesis H0 may not be true, in this case, rate of accepting False H0 will increase. Factors affecting Power and $\\beta$ Size of the effect / effect size The size of the effect is the distance between the mean of null hypothesis distributions and the mean of true distribution.If $\\alpha$ is fixed, then Greater the size of effect is, smaller $\\beta$ / Type II error rate is and more different two distributions are. We can see that the first figure has the effect size smaller than the effect size in second figure, as the $\\beta$ in the top figure is larger than the bottom one. Assume distribution of H0=True is estimated from samples and the real distribution of population is distribution of H1=True. Then Equation to compute size of effect is: effect size = $\\frac{\\mu_{H0} -\\mu_{H1} }{\\sigma_{H1}}$where $\\mu_{H0}$, $\\mu_{H1}$ are mean of H0, H1 $\\sigma_{H1}$ is standard variance of distribution of H1=True. Note that effect size can be computed, but can not be controlled by users directly. It depends on the samples and population. Size of samplesThe sample size controls the variance of a distribution (width of distribution) and hence can affect $\\beta$ / Type II error rate. In the following figure, when $\\alpha$ and means of two distributions H0=True, H1 = True are fixed, large sample size is, smaller variance is and smaller $beta$ / Type II error is Control Type I error $\\alpha$ To control Type I error rate/ $\\alpha$, we can change $\\alpha$ directly. Decrease $\\alpha$ is to decrease Type I error rate (rejecting H0 when H0 =True) Usually $\\alpha$ is set to be 0.05 or 0.01 Control Type II error $\\beta$ or (1- power) Since there is trade-off between Type I error rate $\\alpha$ and Type II error rate $\\beta$, we can increase $\\alpha$ to decrease $\\beta$ and increase power Increase sample size to decrease variance of distribution to decrease $\\beta$, the rate of accepting H0 when H0=False. Two-tailed Hypthesis TestingThe hypothesis testing above is called single-tailed hypothesis testing, since we only consider the significant level $\\alpha$ in on one side only. In the figure below $H_a: \\mu &lt;\\mu_0 $ means the sample mean $\\mu$ is smaller than population mean $\\mu_0$. In single-tailed test, we only consider one-side of relationship and disregard another side Now we consider the Two-tailed Hypothesis testing with the sum of area of left tail and right tail in distribution of H0 equal to $\\alpha$. The figure is shown below. In two-tailed test, we regard the extreme cases on both sides. *We reject H0 when 2P-value&lt; $\\alpha$ or P-value &lt; $\\frac{\\alpha}{2}$ in Two-tailed Hypothesis Testing** For example, we want to analysis how tall the people are in a region. Then Example 1:H0: the mean tall of population = 1.75 mH1: the mean tall of population is not equal to 1.75 m.Observation: the mean of a sample group of people = 1.9m.In this case, if we care whether tall mean of people is &gt;1.75m or &lt;=1.75m, then we use two-tailed test and compare P-value with $\\frac{\\alpha}{2}$ Example 2:H0: the mean tall of population = 1.75 mH1: the mean tall of population is greater than 1.75 m.Observation: the mean of a sample group of people = 1.9m.If we care if tall mean of people &gt;1.75m or not only, then we use one-tailed test and compare P-value with $\\alpha$. Example 3:H0: the mean tall of population = 1.75 mH1: the mean tall of population is less than or equal to 1.75 m.Observation: the mean of a sample group of people = 1.5m.In this case, we care if mean &lt;=1.75m or not only, then we use one-tailed test again. Choosing which tail in one-tailed test depends on the observation and your alternative hypothesis H1. When to use single-tailed test or two-tailed test Choosing two-tailed test when: when you care extreme cases on both sides of distribution without direction when effects exist on both sides based on your observations. Note that if effect exists on two sides, but we choose single-tailed test, then the expected significant level =$\\alpha$ but we choose $\\frac{\\alpha}{2}$, this may increase Type II error rate and decrease power as we decrease $\\alpha$ Choosing one-tailed test when: when you care one side of effect / extreme cases on one side only when effects exist on only one side based on your observations Note that if effect exists on two tails and we choose one-tailed test, then expected significant level =$\\frac{\\alpha}{2}$, but we use $\\alpha$ instead, this may increase Type I error rate. Methods to compute p-valueThe common methods to compute P-value as follow, I will introduce them in the next article z-test Z-distribution/normal distribution Assume data follow normal distribution usually used with continuous variables t-test Use t-distribution usually used with continuous variables Pearsonâ€™s Chi-Square score Use Chi sqare distribution (Square Sum of multiple normal distribution) Used to measure independence between two variables Can be used for continuous variables or discrete variables Factors affecting Hypothesis testing Sample size As mentioned before, sample size can affect $\\beta$, type II error rate (retain H0/ can not reject H0 when H0 is false). Randomized Experiment In order to obtain representative samples from population in hypothesis testing to compute the p-value, we need to avoid sampling in bias. This leads to randomized experiment. There are some important terms in randomized experiment: Random sampling Random sampling is to obtain get some representative samples from the population (full traffic) randomly. If the samples are not obtained randomly, it could be biased which can affect the distribution of sample data even sample size is large Randomization / Random assignment Randomization is how you allocate samples to groups in experiment. It alleviates the bias that might cause a systematic difference between groups unrelated to the treatment itself. For example, If I want to test if the new UI design of a software can get higher ClickThrough rate (CRT) from users. Then I compare a group of users who use the new UI, called treatment group with another group of users who use original UI, called controlled group. Then After I randomly sample the users from different region, the way that I randomly assign those users to treatment group or controlled group is randomization/ random assignment. Confounding factor /variable Confounding factor is the factor that correlates with the independent and dependent variable confuse the effects and impact the results of experiments. Randomization of experiments is the key to controlling for confounding variables in machine learning experiments. Summary to use Hypothesis testing Specify a Null Hypothesis H0 and alternative Hypothesis H1 based on some observations (H0 and H1 should be mutually exclusive). Choose one-tailed test or two-tailed test based on H0 and H1 Specify significant level $\\alpha$ Compute P-value based on dataset (t-test/t-statistic, z-test, F-statistic,Chi-square test) Compare P-value with significant level $\\alpha$. If P-value &gt;= $\\alpha$, retain H0 (NOT accept !). If P-value &lt; $\\alpha$, reject H0 and retain H1 Reference[1] https://towardsdatascience.com/a-complete-guide-to-hypothesis-testing-2e0279fa9149 [2] https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4111019/ [3] http://web.mnstate.edu/malonech/Psy633/Notes/hyp.%20testing,%20effect%20size,%20power%20GW8.htm [4] https://statisticsbyjim.com/hypothesis-testing/one-tailed-two-tailed-hypothesis-tests/ [5] http://us.sagepub.com/sites/default/files/upm-binaries/83321_Chapter_8_Hypothesis_Testing_Significance,_Effect_Size,_and_Power.pdf [6] https://zhuanlan.zhihu.com/p/86178674 [7] https://machinelearningmastery.com/confounding-variables-in-machine-learning/ [8] https://online.stat.psu.edu/stat100/lesson/10","link":"/2021/02/18/Statistic-Hypothesis-Testing/"},{"title":"Use Hexo + ICarus to build a website","text":"IntroductionRecently, I realize that there are many benefits to write technical blog on a personal websites. It allows us to summarize the techniques weâ€™ve learned, helping review what we did before, and to learn with each other.Hence, this blog is to show how to build a personal site using static website generator, such as Hugo, Hexo and Jekyll. Static site generate actually generates the general html, css and javascript,etc files we need in the framework of website. Comparison among Hugo, Hexo, JekyllHugo: Language GoLang Advantage The fastest framework for constructing website Good flexibility and no need to install many packages since Using Go language many built-in functions/plugins Templates for GoLang International Use Support Markdown Disadvantage Need to be familiar with GoLang Without default themes for website Lack of extensive plugins Hexo: Language Node.js Advantage Fast generating speed Support markdown Easy to setup Github page Good Chinese support (Most of users are Chinese) Many different themes for website Stable Disadvantage May be lack of supports for other languages, since most of users are Chinese Need to install some packages for plugins Jekyll: Language Ruby Advantage Simple to use Many free themes and plugins Easy to publish to Github Disadvantage Not international (may be blocked in some countries) Some plugins are not supported by Github Page Speed of constructing website could be slow as more documents/passages are included in website. Setup HexoI choose Hexo as the first generator for my website since it provides many different themes and plugins. To setup Hexo and publish your website, we first need to setup our work environment (Node.js) for Hexo and associate our website to our server (Github page). Setup Node.js and Git environment Install Node.js . Here is Chinese Reference Install Git to manage your repository of your website and open Git bash terminal. Open the git bash terminal and Install Hexo using command: 1$ npm install hexo-cli -g Initialize the folder that stores your website after install hexo: 1$ hexo init new-folder-name Then hexo will create the folder with the name â€œnew-folder-nameâ€ and setup the environment. Inside the folder 1234567â”œâ”€â”€ _config.ymlâ”œâ”€â”€ package.jsonâ”œâ”€â”€ scaffoldsâ”œâ”€â”€ source| â”œâ”€â”€ _drafts| â””â”€â”€ _postsâ””â”€â”€ themes _config.yml contains the common configurations for the website. source contains the passages you are writing. themes is the folder containing all different themes for your website. Associate our website to server (I choose Gitpage here) Select your server There are many different servers for your website. To read more about choosing server for your websites, click here Since GithubPage provides a free way to publish our website and Github is a very powerful open source repository website. I use GithubPage for me website in this passage. create Github account create a new repository with name: &lt;Your github name&gt;. github.io Install git plugin for Hexo 1$ npm install hexo-deployer-git --save create SSH key 1$ ssh-keygen -t rsa -C \"your email address\" Copy your generated SSH key in the _id_rsa.pub file_ in the path you set like (C:\\Users\\Administrator.ssh\\id_rsa.pub) to your New ssh key Modify the deployment setting in _config.yml file in the root directory of your website. 123456# Deployment## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:&lt;Githubè´¦å·åç§°&gt;/&lt;Githubè´¦å·åç§°&gt;.github.io.git branch: master Upload your website to github Note: the default theme of your website in Hexo is landscape. so you donâ€™t need to add any file to your website during testing. To learn more about how to write and post your passage, click here Choosing theme for your blogIf you dislike the default theme (landscape) in hexo, you can install other themes and change the _config.yml file setting to update your website.For example, if you want to install icarus theme, Go back to the root of your website, install icarus them using this command 1$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus Modify your config.yml file 12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/#theme: landscapetheme: icarus I annotate the theme of landscape and choose icarus here. Note: do not add any space before the keyword â€œthemeâ€, otherwise, the theme will not update Generate static site files and update them to github generate static site files 1$ hexo g upload the files to github directory &lt;your github name&gt;.github.io 1$ hexo d Then you can type &lt;your github name&gt;.github.io in your browser to visit your website. Setup Comment pluginIn hexo, there are many different plugins for comment function, like valine, gitalk, gitment. Take valine as example here. Create an account on Leancloud Create a new App, then click the app you created -&gt; Settings-&gt;App keys Copy AppID and AppKey Modify the comment setting in _&lt;your hexoâ€™s root&gt;/theme/&lt;directory name of icarus&gt;/config.yml 12345678910# Comment plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Comment/comment: # type: disqus # # Disqus shortname # shortname: 'Disqus' # Name of the comment plugin type: valine app_id: 'AppID' app_key: 'AppKey' Generate static site files and deploy them again 1$ hexo g -d Additional Notes Useful commands in Hexo 123456789101112131415161718192021222324#in the root directory of hexo$ hexo new page &lt;page-name&gt; #default generate a directory in source/$ hexo new &lt;file-name without postfix \".md\"&gt; #generate &lt;file-name&gt;.md file in /source/__post$ hexo clean #clean all static site files$ hexo g #generate static site files# or $ hexo generate$ hexo d #deploy website, push it to the server#or$ hexo deploy$ hexo g -d # generate and deploy website#move file from __drafts to __posts and publish the passage to website$ hexo publish draft &lt;filename without postfix \".md\"&gt; # Start local server and display your websiteat http://localhost:4000$ hexo s # or $ hexo server To enable catalogue in icarus to enable the passage to show up in catergory, tags, at the top of markdown file add -â€“type: [â€œcategoryâ€, â€œtagsâ€]-â€“ To let catalogue show up in the page, add toc: true to the top of the file: -â€“toc: truetype: [â€œcategoryâ€, â€œtagsâ€]-â€“ To change th background of your blog go to themes\\next\\source\\images folder to put your background image Then go to the file themes\\next\\source\\css_custom\\custom.styl to addthe following codes, where bg.jpg is your background image. 1234567body{ background:url(/images/bg.jpg); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;} Then rebuild your HTML blog by commands 1hexo clean &amp;&amp; hexo g -d To change the text of button â€œnextâ€ and â€œpreviousâ€ of page to be â€œnext &gt;â€ and â€œ&lt; prevâ€:In file: themes\\next\\layout_partials\\pagination.swig , Change 123456789&lt;nav class=&quot;pagination&quot;&gt; {{ paginator({ prev_text: '&lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;/i&gt;', next_text: '&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;', mid_size: 1 }) }}&lt;/nav&gt; to 123456789&lt;nav class=&quot;pagination&quot;&gt; {{ paginator({ prev_text: '&lt; prev', next_text: 'next &gt;', mid_size: 1 }) }}&lt;/nav&gt; This enable you to change the text of next, prev button References https://blog.zhangruipeng.me/hexo-theme-icarus/Widgets/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E6%8C%82%E4%BB%B6/ https://lexcao.github.io/zh/posts/jekyll-hugo-hexo https://juejin.im/post/5bebfe51e51d45332a456de0#heading-9 https://www.vincentqin.tech/posts/build-a-website-using-hexo/ https://zsh2401.top/post/configure-theme-icarus/","link":"/2020/06/30/hexo-gitpage-website/"},{"title":"KKBox Music Recommendation System","text":"12from google.colab import drivedrive.mount('/content/drive') Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(&quot;/content/drive&quot;, force_remount=True). 1!pip install kaggle Requirement already satisfied: kaggle in /usr/local/lib/python3.6/dist-packages (1.5.9) Requirement already satisfied: python-slugify in /usr/local/lib/python3.6/dist-packages (from kaggle) (4.0.1) Requirement already satisfied: python-dateutil in /usr/local/lib/python3.6/dist-packages (from kaggle) (2.8.1) Requirement already satisfied: six&gt;=1.10 in /usr/local/lib/python3.6/dist-packages (from kaggle) (1.15.0) Requirement already satisfied: certifi in /usr/local/lib/python3.6/dist-packages (from kaggle) (2020.11.8) Requirement already satisfied: urllib3 in /usr/local/lib/python3.6/dist-packages (from kaggle) (1.24.3) Requirement already satisfied: slugify in /usr/local/lib/python3.6/dist-packages (from kaggle) (0.0.1) Requirement already satisfied: tqdm in /usr/local/lib/python3.6/dist-packages (from kaggle) (4.41.1) Requirement already satisfied: requests in /usr/local/lib/python3.6/dist-packages (from kaggle) (2.23.0) Requirement already satisfied: text-unidecode&gt;=1.3 in /usr/local/lib/python3.6/dist-packages (from python-slugify-&gt;kaggle) (1.3) Requirement already satisfied: idna&lt;3,&gt;=2.5 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;kaggle) (2.10) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;kaggle) (3.0.4) 1!cp /content/drive/My\\ Drive/Colab\\ Notebooks/KKBox-MusicRecommendationSystem/kaggle.json . 1234567# !!chmod 600 kaggle.json!mkdir -p ~/.kaggle!cp kaggle.json ~/.kaggle/!ls ~/.kaggle!mkdir -p ./kaggle/!chmod 600 /root/.kaggle/kaggle.json!kaggle competitions download kkbox-music-recommendation-challenge kaggle.json Warning: Looks like you're using an outdated API Version, please consider updating (server 1.5.9 / client 1.5.4) song_extra_info.csv.7z: Skipping, found more recently modified local copy (use --force to force download) train.csv.7z: Skipping, found more recently modified local copy (use --force to force download) test.csv.7z: Skipping, found more recently modified local copy (use --force to force download) songs.csv.7z: Skipping, found more recently modified local copy (use --force to force download) members.csv.7z: Skipping, found more recently modified local copy (use --force to force download) sample_submission.csv.7z: Skipping, found more recently modified local copy (use --force to force download) 123456789101112!mkdir kaggle/working!mkdir kaggle/working/train!mkdir kaggle/working/train/data!apt-get install p7zip!apt-get install p7zip-full !7za e members.csv.7z !7za e songs.csv.7z !7za e song_extra_info.csv.7z !7za e train.csv.7z !7za e sample_submission.csv.7z !7za e test.csv.7z !mv *.csv kaggle/working/train/data mkdir: cannot create directory â€˜kaggle/workingâ€™: File exists mkdir: cannot create directory â€˜kaggle/working/trainâ€™: File exists mkdir: cannot create directory â€˜kaggle/working/train/dataâ€™: File exists Reading package lists... Done Building dependency tree Reading state information... Done p7zip is already the newest version (16.02+dfsg-6). 0 upgraded, 0 newly installed, 0 to remove and 14 not upgraded. Reading package lists... Done Building dependency tree Reading state information... Done p7zip-full is already the newest version (16.02+dfsg-6). 0 upgraded, 0 newly installed, 0 to remove and 14 not upgraded. 7-Zip (a) [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21 p7zip Version 16.02 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,64 bits,2 CPUs AMD EPYC 7B12 (830F10),ASM,AES-NI) Scanning the drive for archives: 0M Scan\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b1 file, 1349856 bytes (1319 KiB) Extracting archive: members.csv.7z -- Path = members.csv.7z Type = 7z Physical Size = 1349856 Headers Size = 130 Method = LZMA2:3m Solid = - Blocks = 1 0%\b\b\b\b \b\b\b\bEverything is Ok Size: 2503827 Compressed: 1349856 7-Zip (a) [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21 p7zip Version 16.02 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,64 bits,2 CPUs AMD EPYC 7B12 (830F10),ASM,AES-NI) Scanning the drive for archives: 0M Scan\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b1 file, 105809525 bytes (101 MiB) Extracting archive: songs.csv.7z -- Path = songs.csv.7z Type = 7z Physical Size = 105809525 Headers Size = 122 Method = LZMA2:24 Solid = - Blocks = 1 0%\b\b\b\b \b\b\b\b 2% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 5% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 8% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 11% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 14% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 17% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 20% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 24% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 27% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 30% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 33% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 35% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 39% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 41% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 45% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 49% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 51% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 54% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 57% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 60% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 62% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 65% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 68% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 70% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 73% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 76% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 79% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 82% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 85% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 87% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 90% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 92% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 95% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 98% - songs.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\bEverything is Ok Size: 221828666 Compressed: 105809525 7-Zip (a) [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21 p7zip Version 16.02 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,64 bits,2 CPUs AMD EPYC 7B12 (830F10),ASM,AES-NI) Scanning the drive for archives: 0M Scan\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b1 file, 103608205 bytes (99 MiB) Extracting archive: song_extra_info.csv.7z -- Path = song_extra_info.csv.7z Type = 7z Physical Size = 103608205 Headers Size = 140 Method = LZMA:25 Solid = - Blocks = 1 0%\b\b\b\b \b\b\b\b 1% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 4% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 6% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 9% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 11% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 13% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 16% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 18% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 20% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 23% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 25% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 27% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 30% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 32% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 34% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 37% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 39% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 41% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 44% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 46% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 48% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 50% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 53% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 55% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 57% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 60% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 62% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 65% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 68% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 71% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 74% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 76% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 78% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 81% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 83% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 85% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 88% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 92% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 95% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 99% - song_extra_info.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\bEverything is Ok Size: 181010294 Compressed: 103608205 7-Zip (a) [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21 p7zip Version 16.02 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,64 bits,2 CPUs AMD EPYC 7B12 (830F10),ASM,AES-NI) Scanning the drive for archives: 0M Scan\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b1 file, 106420688 bytes (102 MiB) Extracting archive: train.csv.7z -- Path = train.csv.7z Type = 7z Physical Size = 106420688 Headers Size = 122 Method = LZMA2:24 Solid = - Blocks = 1 0%\b\b\b\b \b\b\b\b 2% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 4% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 6% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 9% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 10% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 13% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 14% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 17% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 19% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 21% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 23% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 25% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 27% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 29% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 31% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 33% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 34% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 36% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 38% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 41% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 43% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 46% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 48% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 50% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 52% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 54% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 56% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 58% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 59% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 62% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 65% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 68% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 70% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 73% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 75% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 76% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 78% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 80% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 82% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 84% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 86% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 88% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 90% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 91% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 93% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 95% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 97% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 99% - train.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\bEverything is Ok Size: 971675848 Compressed: 106420688 7-Zip (a) [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21 p7zip Version 16.02 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,64 bits,2 CPUs AMD EPYC 7B12 (830F10),ASM,AES-NI) Scanning the drive for archives: 0M Scan\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b1 file, 463688 bytes (453 KiB) Extracting archive: sample_submission.csv.7z -- Path = sample_submission.csv.7z Type = 7z Physical Size = 463688 Headers Size = 146 Method = LZMA2:24 Solid = - Blocks = 1 0%\b\b\b\b \b\b\b\bEverything is Ok Size: 29570380 Compressed: 463688 7-Zip (a) [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21 p7zip Version 16.02 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,64 bits,2 CPUs AMD EPYC 7B12 (830F10),ASM,AES-NI) Scanning the drive for archives: 0M Scan\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b1 file, 43925208 bytes (42 MiB) Extracting archive: test.csv.7z -- Path = test.csv.7z Type = 7z Physical Size = 43925208 Headers Size = 122 Method = LZMA2:24 Solid = - Blocks = 1 0%\b\b\b\b \b\b\b\b 4% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 8% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 13% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 18% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 22% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 28% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 34% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 42% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 49% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 55% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 61% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 67% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 74% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 80% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 86% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 90% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b 96% - test.csv\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b \b\b\b\b\b\b\b\b\b\b\b\b\b\b\bEverything is Ok Size: 347789925 Compressed: 43925208 1234567891011121314151617# This Python 3 environment comes with many helpful analytics libraries installed# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python# For example, here's several helpful packages to loadimport numpy as np # linear algebraimport pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)# Input data files are available in the read-only \"../input/\" directory# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directoryimport osfor dirname, _, filenames in os.walk('./kaggle/input'): for filename in filenames: print(os.path.join(dirname, filename))# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using \"Save &amp; Run All\" # You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session Use 7z to uncompress the csv files1!ls ./kaggle/working/train/data/ members.csv song_extra_info.csv test.csv sample_submission.csv songs.csv train.csv 1!du -h ./kaggle/working/train/data/ 1.7G ./kaggle/working/train/data/ 1!cat /proc/cpuinfo processor : 0 vendor_id : AuthenticAMD cpu family : 23 model : 49 model name : AMD EPYC 7B12 stepping : 0 microcode : 0x1000065 cpu MHz : 2250.000 cache size : 512 KB physical id : 0 siblings : 2 core id : 0 cpu cores : 1 apicid : 0 initial apicid : 0 fpu : yes fpu_exception : yes cpuid level : 13 wp : yes flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid extd_apicid tsc_known_freq pni pclmulqdq ssse3 fma cx16 sse4_1 sse4_2 movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm cmp_legacy cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw topoext ssbd ibrs ibpb stibp vmmcall fsgsbase tsc_adjust bmi1 avx2 smep bmi2 rdseed adx smap clflushopt clwb sha_ni xsaveopt xsavec xgetbv1 clzero xsaveerptr arat npt nrip_save umip rdpid bugs : sysret_ss_attrs spectre_v1 spectre_v2 spec_store_bypass bogomips : 4500.00 TLB size : 3072 4K pages clflush size : 64 cache_alignment : 64 address sizes : 48 bits physical, 48 bits virtual power management: processor : 1 vendor_id : AuthenticAMD cpu family : 23 model : 49 model name : AMD EPYC 7B12 stepping : 0 microcode : 0x1000065 cpu MHz : 2250.000 cache size : 512 KB physical id : 0 siblings : 2 core id : 0 cpu cores : 1 apicid : 1 initial apicid : 1 fpu : yes fpu_exception : yes cpuid level : 13 wp : yes flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid extd_apicid tsc_known_freq pni pclmulqdq ssse3 fma cx16 sse4_1 sse4_2 movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm cmp_legacy cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw topoext ssbd ibrs ibpb stibp vmmcall fsgsbase tsc_adjust bmi1 avx2 smep bmi2 rdseed adx smap clflushopt clwb sha_ni xsaveopt xsavec xgetbv1 clzero xsaveerptr arat npt nrip_save umip rdpid bugs : sysret_ss_attrs spectre_v1 spectre_v2 spec_store_bypass bogomips : 4500.00 TLB size : 3072 4K pages clflush size : 64 cache_alignment : 64 address sizes : 48 bits physical, 48 bits virtual power management: KKBox-Music Recommendation SystemGoal of this projectIn this project, we are going to build a recommendation system to predict the chances of a user listening to a song repetitively after the first observable listening event within a time window was triggered. If there are recurring listening event(s) triggered within a month after the userâ€™s very first observable listening event, its target is marked 1, and 0 otherwise in the training set. The same rule applies to the testing set. 0. Data Collection and DescriptionThe KKBox dataset is composed of following files: train.csv msno: user id song_id: song id source_system_tab: the name of the tab where the event was triggered. System tabs are used to categorize KKBOX mobile apps functions. For example, tab my library contains functions to manipulate the local storage, and tab search contains functions relating to search. source_screen_name: name of the layout a user sees. source_type: an entry point a user first plays music on mobile apps. An entry point could be album, online-playlist, song .. etc. target: this is the target variable. target=1 means there are recurring listening event(s) triggered within a month after the userâ€™s very first observable listening event, target=0 otherwise . test.csv id: row id (will be used for submission) msno: user id song_id: song id source_system_tab: the name of the tab where the event was triggered. System tabs are used to categorize KKBOX mobile apps functions. For example, tab my library contains functions to manipulate the local storage, and tab search contains functions relating to search. source_screen_name: name of the layout a user sees. source_type: an entry point a user first plays music on mobile apps. An entry point could be album, online-playlist, song .. etc. sample_submission.csv sample submission file in the format that we expect you to submit id: same as id in test.csv target: this is the target variable. target=1 means there are recurring listening event(s) triggered within a month after the userâ€™s very first observable listening event, target=0 otherwise . songs.csv The songs. Note that data is in unicode. song_id song_length: in ms genre_ids: genre category. Some songs have multiple genres and they are separated by | artist_name composer lyricist language members.csv user information. msno city bd: age. Note: this column has outlier values, please use your judgement. gender registered_via: registration method registration_init_time: format %Y%m%d expiration_date: format %Y%m%d song_extra_info.csv song_id song name - the name of the song. isrc - International Standard Recording Code, theoretically can be used as an identity of a song. However, what worth to note is, ISRCs generated from providers have not been officially verified; therefore the information in ISRC, such as country code and reference year, can be misleading/incorrect. Multiple songs could share one ISRC since a single recording could be re-published several times. 1. Data Cleaning and Exploratory Data Analysis (EDA) Find the Description and summary of each CSV file and Determine Null object, categorical attributes, numerical attributes Convert some attribute types to correct data type, like convert string to float, if necessary Handle Missing values Plot univariate, bivariate plots to visualize and analyze relationship between attributes and target Analysis Summary in this section 2. Data PreprocessingNote that This section is to give some examples to preprocess data like filling missing values and removing outliers. In order to train models, you should start from step 3 ETL to extract and transform data directly using integrated functions 3. Data Pipeline: Extract, Transformation, Load (ETL)4. Machine Learning Modeling LGBM Boosting machineIn the modeling part, we use LGBM model first, which is a light gradient boosting machine model using tree-based basic models for boosting. Since the dataset is large, 1.9 GB and the number of attributes can increase during transformation, LGBM provides a very fast way to train a machine model, so we try it here. In this part, we try LGBM model with different max_depth of tree: [10, 15,20, 25, 30] and see how max_depth affects the accuracy on prediction Wide and Deep Neural network modelIn addition to LGBM model, we are also interested in trying the Wide and Deep Neural network model since it is one of the popular neural network model in recommendation system and we want to see if this can help us improve the accuracy.In wide and deep model, It first uses a technique called embedding, which projects the sparse categorical features into dense features vectors with smaller dimension and extract the main features. Then it concatenates the embedded vectors with the numerical features together to train a traditional neural network classifier. 5. Model Training and validation In model training and validation step, we split the data set into training set(80% of dataset) and validation set (20% of dataset) and then use them to train and keep track of the performance of models. 6. Model EvaluationIn Model evaluation step, we simply use the validation set to validate the final trained models and then let models make predictions on testset from kaggle and submit predictions to kaggle to see the final evaluation scores. 7. Summary123456789101112#import necessary packages hereimport warningswarnings.filterwarnings('ignore')import numpy as np import pandas as pdimport matplotlib.pyplot as pltimport seaborn as snsimport lightgbm as lgbfrom subprocess import check_output# print(check_output([\"ls\", \"../input\"]).decode(\"utf8\"))np.random.seed(2020) 1. Exploratory Data Analysis12345678root = './kaggle/working/train/data/'# !ls ../input/kkbox-music-recommendation-challengetrain_df = pd.read_csv(root+ \"train.csv\")test_df = pd.read_csv(root+ \"test.csv\")song_df = pd.read_csv(root+ \"songs.csv\")song_extra_df = pd.read_csv(root+ \"song_extra_info.csv\")members_df = pd.read_csv(root+ \"members.csv\")# sample_df = pd.read_csv(root+ \"sample_submission.csv\") 1.1 Take a look to the info and format of data1train_df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 7377418 entries, 0 to 7377417 Data columns (total 6 columns): # Column Dtype --- ------ ----- 0 msno object 1 song_id object 2 source_system_tab object 3 source_screen_name object 4 source_type object 5 target int64 dtypes: int64(1), object(5) memory usage: 337.7+ MB 1train_df.count() msno 7377418 song_id 7377418 source_system_tab 7352569 source_screen_name 6962614 source_type 7355879 target 7377418 dtype: int64 We can see that attributes: source_system_tab, source_screen_name, source_type contain missing values1train_df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } msno song_id source_system_tab source_screen_name source_type target 0 FGtllVqz18RPiwJj/edr2gV78zirAiY/9SmYvia+kCg= BBzumQNXUHKdEBOB7mAJuzok+IJA1c2Ryg/yzTF6tik= explore Explore online-playlist 1 1 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= bhp/MpSNoqoxOIB+/l8WPqu6jldth4DIpCm3ayXnJqM= my library Local playlist more local-playlist 1 2 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= JNWfrrC7zNN7BdMpsISKa4Mw+xVJYNnxXh3/Epw7QgY= my library Local playlist more local-playlist 1 3 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= 2A87tzfnJTSWqD7gIZHisolhe4DMdzkbd6LzO1KHjNs= my library Local playlist more local-playlist 1 4 FGtllVqz18RPiwJj/edr2gV78zirAiY/9SmYvia+kCg= 3qm6XTZ6MOCU11x8FIVbAGH5l5uMkT3/ZalWG1oo2Gc= explore Explore online-playlist 1 1test_df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 2556790 entries, 0 to 2556789 Data columns (total 6 columns): # Column Dtype --- ------ ----- 0 id int64 1 msno object 2 song_id object 3 source_system_tab object 4 source_screen_name object 5 source_type object dtypes: int64(1), object(5) memory usage: 117.0+ MB 1test_df.count() id 2556790 msno 2556790 song_id 2556790 source_system_tab 2548348 source_screen_name 2393907 source_type 2549493 dtype: int64 In test dataset, We can see that attributes that contain missing values: source_system_tab source_screen_name source_type 1test_df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } id msno song_id source_system_tab source_screen_name source_type 0 0 V8ruy7SGk7tDm3zA51DPpn6qutt+vmKMBKa21dp54uM= WmHKgKMlp1lQMecNdNvDMkvIycZYHnFwDT72I5sIssc= my library Local playlist more local-library 1 1 V8ruy7SGk7tDm3zA51DPpn6qutt+vmKMBKa21dp54uM= y/rsZ9DC7FwK5F2PK2D5mj+aOBUJAjuu3dZ14NgE0vM= my library Local playlist more local-library 2 2 /uQAlrAkaczV+nWCd2sPF2ekvXPRipV7q0l+gbLuxjw= 8eZLFOdGVdXBSqoAv5nsLigeH2BvKXzTQYtUM53I0k4= discover NaN song-based-playlist 3 3 1a6oo/iXKatxQx4eS9zTVD+KlSVaAFbTIqVvwLC1Y0k= ztCf8thYsS4YN3GcIL/bvoxLm/T5mYBVKOO4C9NiVfQ= radio Radio radio 4 4 1a6oo/iXKatxQx4eS9zTVD+KlSVaAFbTIqVvwLC1Y0k= MKVMpslKcQhMaFEgcEQhEfi5+RZhMYlU3eRDpySrH8Y= radio Radio radio 1song_df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 2296320 entries, 0 to 2296319 Data columns (total 7 columns): # Column Dtype --- ------ ----- 0 song_id object 1 song_length int64 2 genre_ids object 3 artist_name object 4 composer object 5 lyricist object 6 language float64 dtypes: float64(1), int64(1), object(5) memory usage: 122.6+ MB 1song_df.count() song_id 2296320 song_length 2296320 genre_ids 2202204 artist_name 2296320 composer 1224966 lyricist 351052 language 2296319 dtype: int64 Attributes that contain missing values are composer lyricist genre_ids language 1song_df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } song_id song_length genre_ids artist_name composer lyricist language 0 CXoTN1eb7AI+DntdU1vbcwGRV4SCIDxZu+YD8JP8r4E= 247640 465 å¼µä¿¡å“² (Jeff Chang) è‘£è² ä½•å•Ÿå¼˜ 3.0 1 o0kFgae9QtnYgRkVPqLJwa05zIhRlUjfF7O1tDw0ZDU= 197328 444 BLACKPINK TEDDY| FUTURE BOUNCE| Bekuh BOOM TEDDY 31.0 2 DwVvVurfpuz+XPuFvucclVQEyPqcpUkHR0ne1RQzPs0= 231781 465 SUPER JUNIOR NaN NaN 31.0 3 dKMBWoZyScdxSkihKG+Vf47nc18N9q4m58+b4e7dSSE= 273554 465 S.H.E æ¹¯å°åº· å¾ä¸–ç 3.0 4 W3bqWd3T+VeHFzHAUfARgW9AvVRaF4N5Yzm4Mr6Eo/o= 140329 726 è²´æ—ç²¾é¸ Traditional Traditional 52.0 1song_extra_df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 2295971 entries, 0 to 2295970 Data columns (total 3 columns): # Column Dtype --- ------ ----- 0 song_id object 1 name object 2 isrc object dtypes: object(3) memory usage: 52.6+ MB 1song_extra_df.count() song_id 2295971 name 2295969 isrc 2159423 dtype: int64 1song_extra_df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } song_id name isrc 0 LP7pLJoJFBvyuUwvu+oLzjT+bI+UeBPURCecJsX1jjs= æˆ‘å€‘ TWUM71200043 1 ClazTFnk6r0Bnuie44bocdNMM3rdlrq0bCGAsGUWcHE= Let Me Love You QMZSY1600015 2 u2ja/bZE3zhCGxvbbOB3zOoUjx27u40cf5g09UXMoKQ= åŸè«’æˆ‘ TWA530887303 3 92Fqsy0+p6+RHe2EoLKjHahORHR1Kq1TBJoClW9v+Ts= Classic USSM11301446 4 0QFmz/+rJy1Q56C1DuYqT9hKKqi5TUqx0sN0IwvoHrw= æ„›æŠ•ç¾…ç¶² TWA471306001 1members_df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 34403 entries, 0 to 34402 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 msno 34403 non-null object 1 city 34403 non-null int64 2 bd 34403 non-null int64 3 gender 14501 non-null object 4 registered_via 34403 non-null int64 5 registration_init_time 34403 non-null int64 6 expiration_date 34403 non-null int64 dtypes: int64(5), object(2) memory usage: 1.8+ MB 1train_df['song_id'].head() 0 BBzumQNXUHKdEBOB7mAJuzok+IJA1c2Ryg/yzTF6tik= 1 bhp/MpSNoqoxOIB+/l8WPqu6jldth4DIpCm3ayXnJqM= 2 JNWfrrC7zNN7BdMpsISKa4Mw+xVJYNnxXh3/Epw7QgY= 3 2A87tzfnJTSWqD7gIZHisolhe4DMdzkbd6LzO1KHjNs= 4 3qm6XTZ6MOCU11x8FIVbAGH5l5uMkT3/ZalWG1oo2Gc= Name: song_id, dtype: object 1song_df['song_id'].head() 0 CXoTN1eb7AI+DntdU1vbcwGRV4SCIDxZu+YD8JP8r4E= 1 o0kFgae9QtnYgRkVPqLJwa05zIhRlUjfF7O1tDw0ZDU= 2 DwVvVurfpuz+XPuFvucclVQEyPqcpUkHR0ne1RQzPs0= 3 dKMBWoZyScdxSkihKG+Vf47nc18N9q4m58+b4e7dSSE= 4 W3bqWd3T+VeHFzHAUfARgW9AvVRaF4N5Yzm4Mr6Eo/o= Name: song_id, dtype: object 123print(\"Unique Song amount in trainset:\",train_df['song_id'].nunique())print(\"Unique Song amount in testset:\", test_df['song_id'].nunique())print(\"Unique Song amount in song list:\",song_df['song_id'].nunique()) Unique Song amount in trainset: 359966 Unique Song amount in testset: 224753 Unique Song amount in song list: 2296320 1.2 Explore Song information12345# Merge two dataframe based on song_id so that we can analyze the song information together with training datauser_music_df = train_df.merge(song_df,on='song_id',how=\"left\", copy =False)user_music_df[\"song_id\"] = user_music_df[\"song_id\"].astype(\"category\")user_music_df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } msno song_id source_system_tab source_screen_name source_type target song_length genre_ids artist_name composer lyricist language 0 FGtllVqz18RPiwJj/edr2gV78zirAiY/9SmYvia+kCg= BBzumQNXUHKdEBOB7mAJuzok+IJA1c2Ryg/yzTF6tik= explore Explore online-playlist 1 206471.0 359 Bastille Dan Smith| Mark Crew NaN 52.0 1 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= bhp/MpSNoqoxOIB+/l8WPqu6jldth4DIpCm3ayXnJqM= my library Local playlist more local-playlist 1 284584.0 1259 Various Artists NaN NaN 52.0 2 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= JNWfrrC7zNN7BdMpsISKa4Mw+xVJYNnxXh3/Epw7QgY= my library Local playlist more local-playlist 1 225396.0 1259 Nas N. Jonesã€W. Adamsã€J. Lordanã€D. Ingle NaN 52.0 3 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= 2A87tzfnJTSWqD7gIZHisolhe4DMdzkbd6LzO1KHjNs= my library Local playlist more local-playlist 1 255512.0 1019 Soundway Kwadwo Donkoh NaN -1.0 4 FGtllVqz18RPiwJj/edr2gV78zirAiY/9SmYvia+kCg= 3qm6XTZ6MOCU11x8FIVbAGH5l5uMkT3/ZalWG1oo2Gc= explore Explore online-playlist 1 187802.0 1011 Brett Young Brett Young| Kelly Archer| Justin Ebach NaN 52.0 1user_music_df['song_id'].nunique(), user_music_df['genre_ids'].nunique() (359966, 572) 1user_music_df.count() msno 7377418 song_id 7377418 source_system_tab 7352569 source_screen_name 6962614 source_type 7355879 target 7377418 song_length 7377304 genre_ids 7258963 artist_name 7377304 composer 5701712 lyricist 4198620 language 7377268 dtype: int64 1234567# plot the top-20 frequent genre_ids df_genre = user_music_df.sample(n=5000)df_genre = df_genre[\"genre_ids\"].value_counts().sort_values(ascending=False)[:20]df_genre = df_genre.sort_values(ascending=True)ax = df_genre.plot.barh(figsize=(15,8))ax.set_ylabel(\"song genre ids\")ax.set_xlabel(\"Count\") Text(0.5, 0, 'Count') 12345678910111213#selec the top-20 frequent artist_namedf_artist = user_music_df[\"artist_name\"].value_counts().sort_values(ascending=False)[:20]#plot in descending order in horizonal directiondf_artist = df_artist.sort_values(ascending=True)ax = df_artist.plot.barh(figsize=(15,10))ax.set_ylabel(\"song artist_name\")ax.set_xlabel(\"Count\")# artist_name # composer # lyricist Text(0.5, 0, 'Count') 1df_artist.head(10) The Chainsmokers 44215 æ¢éœèŒ¹ (Fish Leong) 44290 ä¸å™¹ (Della) 45762 æ¥Šä¸ç³ (Rainie Yang) 46006 è˜‡æ‰“ç¶  (Sodagreen) 47177 è”¡ä¾æ— (Jolin Tsai) 49055 Eric å‘¨èˆˆå“² 49426 A-Lin 52913 Maroon 5 55151 è¬å’Œå¼¦ (R-chord) 57040 Name: artist_name, dtype: int64 12345678fig, ax = plt.subplots(1, figsize=(15,8))df_composer = user_music_df[\"composer\"].value_counts().sort_values(ascending=False)[:20]ax = sns.barplot([i for i in df_composer.index],df_composer,ax= ax)ax.set_xlabel(\"song composer\")ax.set_ylabel(\"Count\") Text(0, 0.5, 'Count') 1df_composer.head(20).index Index(['å‘¨æ°å€«', 'é˜¿ä¿¡', 'æ—ä¿Šå‚‘', 'é™³çš“å®‡', 'JJ Lin', 'å¼µç°¡å›å‰', 'Eric Chou', 'éŸ‹ç¦®å®‰', 'å…«ä¸‰å¤­ é˜¿ç’', 'R-chord', 'æ€ªç¸', 'å³é’å³°', 'å‘¨æ¹¯è±ª', 'G.E.M. é„§ç´«æ£‹', 'é™³å°éœ', 'JerryC', 'å³å…‹ç¾¤', 'è–›ä¹‹è¬™', 'Rocoberry', 'ææ¦®æµ©'], dtype='object') Analyse the relationship between target and song 123456789101112131415161718192021222324252627fig, ax = plt.subplots(3,1,figsize=(15,18))# df = user_music_df[['source_system_tab','source_screen_name','source_type']]# df['source_system_tab'].value_counts().plot.bar(rot=20,ax=ax[0])# ax[0].set_xlabel(\"source_system_tab\")# ax[0].set_ylabel(\"count\")# df['source_screen_name'].value_counts().plot.bar(rot=30,ax=ax[1])# ax[1].set_xlabel(\"source_screen_name\")# ax[1].set_ylabel(\"count\")# df['source_type'].value_counts().plot.bar(rot=20,ax=ax[2])# ax[2].set_xlabel(\"source_type\")# ax[2].set_ylabel(\"count\")sns.countplot(y= 'source_system_tab',hue='target', order = user_music_df['source_system_tab'].value_counts().index, data=user_music_df,dodge=True, ax= ax[0])sns.countplot(y= 'source_screen_name',hue='target', order = user_music_df['source_screen_name'].value_counts().index, data=user_music_df,dodge=True, ax= ax[1])sns.countplot(y= 'source_type',hue='target', order = user_music_df['source_type'].value_counts().index, data=user_music_df,dodge=True, ax= ax[2]) &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f269a90e128&gt; We can see that local library and local playlist are the main sources that users repeat playing music and Most of users more prefer to play music from local library than to play music onlineAnalyze Relationship between Target and members info1members_df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 34403 entries, 0 to 34402 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 msno 34403 non-null object 1 city 34403 non-null int64 2 bd 34403 non-null int64 3 gender 14501 non-null object 4 registered_via 34403 non-null int64 5 registration_init_time 34403 non-null int64 6 expiration_date 34403 non-null int64 dtypes: int64(5), object(2) memory usage: 1.8+ MB 12members_df[\"registration_init_time\"] = pd.to_datetime(members_df[\"registration_init_time\"], format=\"%Y%m%d\")members_df[\"expiration_date\"] = pd.to_datetime(members_df[\"expiration_date\"], format=\"%Y%m%d\") Parse the datetime data12345678members_df[\"registration_init_day\"] = members_df[\"registration_init_time\"].dt.daymembers_df[\"registration_init_month\"] = members_df[\"registration_init_time\"].dt.monthmembers_df[\"registration_init_year\"] = members_df[\"registration_init_time\"].dt.yearmembers_df[\"expiration_day\"] = members_df[\"expiration_date\"].dt.daymembers_df[\"expiration_month\"] = members_df[\"expiration_date\"].dt.monthmembers_df[\"expiration_year\"] = members_df[\"expiration_date\"].dt.yearmembers_df = members_df.drop(columns = [\"registration_init_time\", \"expiration_date\"],axis=1)members_df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 34403 entries, 0 to 34402 Data columns (total 11 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 msno 34403 non-null object 1 city 34403 non-null int64 2 bd 34403 non-null int64 3 gender 14501 non-null object 4 registered_via 34403 non-null int64 5 registration_init_day 34403 non-null int64 6 registration_init_month 34403 non-null int64 7 registration_init_year 34403 non-null int64 8 expiration_day 34403 non-null int64 9 expiration_month 34403 non-null int64 10 expiration_year 34403 non-null int64 dtypes: int64(9), object(2) memory usage: 2.9+ MB 123456member_music_df = user_music_df.merge(members_df,on='msno',how=\"left\", copy=False)#after merging, the axis used to merge becomes object type,so need to convert it back to category typemember_music_df[\"msno\"] = member_music_df[\"msno\"].astype(\"category\")member_music_df[\"song_id\"] = member_music_df[\"song_id\"].astype(\"category\")member_music_df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } msno song_id source_system_tab source_screen_name source_type target song_length genre_ids artist_name composer lyricist language city bd gender registered_via registration_init_day registration_init_month registration_init_year expiration_day expiration_month expiration_year 0 FGtllVqz18RPiwJj/edr2gV78zirAiY/9SmYvia+kCg= BBzumQNXUHKdEBOB7mAJuzok+IJA1c2Ryg/yzTF6tik= explore Explore online-playlist 1 206471.0 359 Bastille Dan Smith| Mark Crew NaN 52.0 1 0 NaN 7 2 1 2012 5 10 2017 1 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= bhp/MpSNoqoxOIB+/l8WPqu6jldth4DIpCm3ayXnJqM= my library Local playlist more local-playlist 1 284584.0 1259 Various Artists NaN NaN 52.0 13 24 female 9 25 5 2011 11 9 2017 2 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= JNWfrrC7zNN7BdMpsISKa4Mw+xVJYNnxXh3/Epw7QgY= my library Local playlist more local-playlist 1 225396.0 1259 Nas N. Jonesã€W. Adamsã€J. Lordanã€D. Ingle NaN 52.0 13 24 female 9 25 5 2011 11 9 2017 3 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= 2A87tzfnJTSWqD7gIZHisolhe4DMdzkbd6LzO1KHjNs= my library Local playlist more local-playlist 1 255512.0 1019 Soundway Kwadwo Donkoh NaN -1.0 13 24 female 9 25 5 2011 11 9 2017 4 FGtllVqz18RPiwJj/edr2gV78zirAiY/9SmYvia+kCg= 3qm6XTZ6MOCU11x8FIVbAGH5l5uMkT3/ZalWG1oo2Gc= explore Explore online-playlist 1 187802.0 1011 Brett Young Brett Young| Kelly Archer| Justin Ebach NaN 52.0 1 0 NaN 7 2 1 2012 5 10 2017 1member_music_df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; Int64Index: 7377418 entries, 0 to 7377417 Data columns (total 22 columns): # Column Dtype --- ------ ----- 0 msno category 1 song_id category 2 source_system_tab object 3 source_screen_name object 4 source_type object 5 target int64 6 song_length float64 7 genre_ids object 8 artist_name object 9 composer object 10 lyricist object 11 language float64 12 city int64 13 bd int64 14 gender object 15 registered_via int64 16 registration_init_day int64 17 registration_init_month int64 18 registration_init_year int64 19 expiration_day int64 20 expiration_month int64 21 expiration_year int64 dtypes: category(2), float64(2), int64(10), object(8) memory usage: 1.2+ GB 1member_music_df.count() msno 7377418 song_id 7377418 source_system_tab 7352569 source_screen_name 6962614 source_type 7355879 target 7377418 song_length 7377304 genre_ids 7258963 artist_name 7377304 composer 5701712 lyricist 4198620 language 7377268 city 7377418 bd 7377418 gender 4415939 registered_via 7377418 registration_init_day 7377418 registration_init_month 7377418 registration_init_year 7377418 expiration_day 7377418 expiration_month 7377418 expiration_year 7377418 dtype: int64 1member_music_df['bd'].describe() count 7.377418e+06 mean 1.753927e+01 std 2.155447e+01 min -4.300000e+01 25% 0.000000e+00 50% 2.100000e+01 75% 2.900000e+01 max 1.051000e+03 Name: bd, dtype: float64 Visualize distribution of age: bd attributionNote: Since this attribute has outliers, I use remove the data that lies outside range [0,100] 123456789fig, ax = plt.subplots(2, figsize= (15,8))age_df = member_music_df['bd'].loc[(member_music_df['bd']&gt;0) &amp; (member_music_df['bd']&lt;100)]age_df.hist(ax = ax[0])ax[0].set_ylabel(\"count\")member_music_df['bd'].loc[(member_music_df['bd']&lt;0) | (member_music_df['bd']&gt;100)].hist(ax = ax[1])ax[1].set_xlabel(\"age\")ax[1].set_ylabel(\"count\") Text(0, 0.5, 'count') We can see that bd/age has outliers outside range [0,100], so we want to replace the incorrect bd with NaN1member_music_df['bd'].loc[(member_music_df['bd']&lt;=0) | (member_music_df['bd']&gt;=100)]= np.nan 12# member_music_df.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } target song_length language city bd registered_via registration_init_day registration_init_month registration_init_year expiration_day expiration_month expiration_year count 7.377418e+06 7.377304e+06 7.377268e+06 7.377418e+06 4.430216e+06 7.377418e+06 7.377418e+06 7.377418e+06 7.377418e+06 7.377418e+06 7.377418e+06 7.377418e+06 mean 5.035171e-01 2.451210e+05 1.860933e+01 7.511399e+00 2.872200e+01 6.794068e+00 1.581532e+01 6.832306e+00 2.012741e+03 1.562338e+01 8.341742e+00 2.017072e+03 std 4.999877e-01 6.734471e+04 2.117681e+01 6.641625e+00 8.634326e+00 2.275774e+00 8.768549e+00 3.700723e+00 3.018861e+00 9.107235e+00 2.511360e+00 3.982536e-01 min 0.000000e+00 1.393000e+03 -1.000000e+00 1.000000e+00 2.000000e+00 3.000000e+00 1.000000e+00 1.000000e+00 2.004000e+03 1.000000e+00 1.000000e+00 1.970000e+03 25% 0.000000e+00 2.147260e+05 3.000000e+00 1.000000e+00 2.300000e+01 4.000000e+00 8.000000e+00 3.000000e+00 2.011000e+03 8.000000e+00 9.000000e+00 2.017000e+03 50% 1.000000e+00 2.418120e+05 3.000000e+00 5.000000e+00 2.700000e+01 7.000000e+00 1.600000e+01 7.000000e+00 2.013000e+03 1.500000e+01 9.000000e+00 2.017000e+03 75% 1.000000e+00 2.721600e+05 5.200000e+01 1.300000e+01 3.300000e+01 9.000000e+00 2.300000e+01 1.000000e+01 2.015000e+03 2.300000e+01 1.000000e+01 2.017000e+03 max 1.000000e+00 1.085171e+07 5.900000e+01 2.200000e+01 9.500000e+01 1.300000e+01 3.100000e+01 1.200000e+01 2.017000e+03 3.100000e+01 1.200000e+01 2.020000e+03 1234#dataframe.corr() is used to find the pairwise correlation of all columns in the dataframe. #Any na values are automatically excluded. For any non-numeric data type columns in the data frame it is ignored.corr_matrix = member_music_df.corr()_ = sns.heatmap(corr_matrix) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#print the top threee attributes that have the strongest correlation with \"Target\" and the corresponding correlation coefficients.corr = corr_matrix['target'].sort_values(ascending= False)for x in corr.index[1:4].to_list(): print(\"{} {}\".format(x, corr[x]))print(\"\")#print the top threee attributes that have the strongest correlation with \"song_length\" and the corresponding correlation coefficients.corr = corr_matrix['song_length'].sort_values(ascending= False)for x in corr.index[1:4].to_list(): print(\"{} {}\".format(x, corr[x]))print(\"\")#print the top threee attributes that have the strongest correlation with \"language\" and the corresponding correlation coefficients.corr = corr_matrix['language'].sort_values(ascending= False)for x in corr.index[1:4].to_list(): print(\"{} {}\".format(x, corr[x]))print(\"\")#print the top threee attributes that have the strongest correlation with \"city\" and the corresponding correlation coefficients.corr = corr_matrix['city'].sort_values(ascending= False)for x in corr.index[1:4].to_list(): print(\"{} {}\".format(x, corr[x]))print(\"\")#print the top threee attributes that have the strongest correlation with \"bd\" and the corresponding correlation coefficients.corr = corr_matrix['bd'].sort_values(ascending= False)for x in corr.index[1:4].to_list(): print(\"{} {}\".format(x, corr[x]))print(\"\")#print the top threee attributes that have the strongest correlation with \"registered_via\" and the corresponding correlation coefficients.corr = corr_matrix['registered_via'].sort_values(ascending= False)for x in corr.index[1:4].to_list(): print(\"{} {}\".format(x, corr[x]))print(\"\")corr = corr_matrix['registration_init_day'].sort_values(ascending= False)for x in corr.index[1:4].to_list(): print(\"{} {}\".format(x, corr[x]))print(\"\")corr = corr_matrix['registration_init_month'].sort_values(ascending= False)for x in corr.index[1:4].to_list(): print(\"{} {}\".format(x, corr[x]))print(\"\")corr = corr_matrix['registration_init_year'].sort_values(ascending= False)for x in corr.index[1:4].to_list(): print(\"{} {}\".format(x, corr[x]))print(\"\")corr = corr_matrix['expiration_day'].sort_values(ascending= False)for x in corr.index[1:4].to_list(): print(\"{} {}\".format(x, corr[x]))print(\"\")corr = corr_matrix['expiration_month'].sort_values(ascending= False)for x in corr.index[1:4].to_list(): print(\"{} {}\".format(x, corr[x]))print(\"\")corr = corr_matrix['expiration_year'].sort_values(ascending= False)for x in corr.index[1:4].to_list(): print(\"{} {}\".format(x, corr[x]))print(\"\") expiration_year 0.042248332355979766 city 0.01211438566189457 expiration_month 0.011817072086387569 bd 0.009861302779254176 city 0.005184912771179072 expiration_year 0.00457185870016758 registration_init_year 0.009070490482763404 registration_init_day 0.001510510575428178 bd 0.001107978394135987 expiration_year 0.15014690465127595 registered_via 0.0737556175747622 target 0.01211438566189457 registered_via 0.1753390015877422 expiration_day 0.056335854806629254 expiration_month 0.032935904360496926 bd 0.1753390015877422 expiration_year 0.08413460079453493 city 0.0737556175747622 expiration_day 0.1493505099924221 registration_init_month 0.04443692475737983 registered_via 0.02554331305533987 expiration_month 0.056911114419175665 registration_init_day 0.04443692475737983 bd 0.005399463812914416 language 0.009070490482763404 target -0.00196242388069252 song_length -0.007434856516605977 registration_init_day 0.1493505099924221 registered_via 0.05695618668075027 bd 0.056335854806629254 registered_via 0.0647318000666518 registration_init_month 0.056911114419175665 bd 0.032935904360496926 city 0.15014690465127595 registered_via 0.08413460079453493 target 0.042248332355979766 123456#graphfig, ax = plt.subplots(1,1,figsize=(10,8), sharex=False)plt.scatter(x = member_music_df['city'],y = member_music_df['bd'])ax.set_ylabel(\"bd\")ax.set_xlabel(\"city\")plt.show() 123456#graphfig, ax = plt.subplots(1,1,figsize=(10,8), sharex=False)plt.scatter(x = member_music_df['target'],y = member_music_df['expiration_year'])ax.set_ylabel(\"expiration_year\")ax.set_xlabel(\"target\")plt.show() 12345#userçš„musiclisté‡Œé¢å¯èƒ½é‡å¬çš„music print(train_df.target.value_counts()*100/train_df.target.value_counts().sum())print('unique songs ',len(train_df.song_id.unique()))#unique() = Return unique values of Series object.#len() to find unqiue sound. 1 50.351708 0 49.648292 Name: target, dtype: float64 unique songs 359966 1234567repeats=train_df[train_df.target==1]song_repeats=repeats.groupby('song_id',as_index=False).msno.count()song_repeats.columns=['song_id','count']##merge together 2 dataframe and create a new dataframesong_repeats=pd.DataFrame(song_repeats).merge(song_df,left_on='song_id',right_on='song_id')print(\"Print top 50 songs repeated\")repeats.song_id.value_counts().head(50) Print top 50 songs repeated reXuGcEWDDCnL0K3Th//3DFG4S1ACSpJMzA+CFipo1g= 10885 T86YHdD4C9JSc274b1IlMkLuNdz4BQRB50fWWE7hx9g= 10556 FynUyq0+drmIARmK1JZ/qcjNZ7DKkqTY6/0O0lTzNUI= 9808 wBTWuHbjdjxnG1lQcbqnK4FddV24rUhuyrYLd9c/hmk= 9411 PgRtmmESVNtWjoZHO5a1r21vIz9sVZmcJJpFCbRa1LI= 9004 U9kojfZSKaiWOW94PKh1Riyv/zUWxmBRmv0XInQWLGw= 8787 YN4T/yvvXtYrBVN8KTnieiQohHL3T9fnzUkbLWcgLro= 8780 M9rAajz4dYuRhZ7jLvf9RRayVA3os61X/XXHEuW4giA= 8403 43Qm2YzsP99P5wm37B1JIhezUcQ/1CDjYlQx6rBbz2U= 8112 J4qKkLIoW7aYACuTupHLAPZYmRp08en1AEux+GSUzdw= 7903 cy10N2j2sdY/X4BDUcMu2Iumfz7pV3tqE5iEaup2yGI= 7725 750RprmFfLV0bymtDH88g24pLZGVi5VpBAI300P6UOA= 7608 IKMFuL0f5Y8c63Hg9BXkeNJjE0z8yf3gMt/tOxF4QNE= 7224 +SstqMwhQPBQFTPBhLKPT642IiBDXzZFwlzsLl4cGXo= 7061 DLBDZhOoW7zd7GBV99bi92ZXYUS26lzV+jJKbHshP5c= 6901 v/3onppBGoSpGsWb8iaCIO8eX5+iacbH5a4ZUhT7N54= 6879 p/yR06j/RQ2J6yGCFL0K+1R06OeG+eXcwxRgOHDo/Tk= 6536 Xpjwi8UAE2Vv9PZ6cZnhc58MCtl3cKZEO1sdAkqJ4mo= 6399 OaEbZ6TJ1NePtNUeEgWsvFLeopkSln9WQu8PBR5B3+A= 6187 BITuBuNyXQydJcjDL2BUnCu4/IXaJg5IPOuycc/4dtY= 6160 BgqjNqzsyCpEGvxyUmktvHC8WO5+FQO/pQTaZ4broMU= 6140 3VkD5ekIf5duJm1hmYTZlXjyl0zqV8wCzuAh3uocfCg= 6012 8Ckw1wek5d6oEsNUoM4P5iag86TaEmyLwdtrckL0Re8= 6003 n+pMhj/jpCnpiUcSDl4k3i9FJODDddEXmpE48/HczTI= 5787 WL4ipO3Mx9pxd4FMs69ha6o9541+fLeOow67Qkrfnro= 5784 /70HjygVDhHsKBoV8mmsBg/WduSgs4+Zg6GfzhUQbdk= 5588 L6w2d0w84FjTvFr+BhMfgu7dZAsGiOqUGmvvxIG3gvQ= 5480 fEAIgFRWmhXmo6m3ukQeqRksZCcO/7CjkqNckRHiVQo= 5460 +Sm75wnBf/sjm/QMUAFx8N+Ae04kWCXGlgH50tTeM6c= 5412 VkDBgh89umc9m6uAEfD6LXngetyGhln4vh/ArCGO0nY= 5361 fCCmIa0Y5m+MCGbQga31MOLTIqi7ddgXvkjFPmfslGw= 5305 +LztcJcPEEwsikk6+K5udm06XJQMzR4+lzavKLUyE0k= 5298 o9HWMBZMeIPnYEpSuscGoORKE44sj3BYOdvGuIi0P68= 5233 QZBm8SOwnEjNfCpgsKBBGPMGET6y6XaQgnJiirspW7I= 5224 ClazTFnk6r0Bnuie44bocdNMM3rdlrq0bCGAsGUWcHE= 5202 wp1gSQ4LlMEF6bzvEaJl8VdHlAj/EJMTJ0ASrXeddbo= 5110 THqGcrzQyUhBn1NI/+Iptc1vKtxBIEg0uA8iaoJnO1Q= 5086 ys+EL8Sok4HC4i7sDY0+slDNGVZ8+uOQi6TQ6g8VSF4= 5012 zHqZ07gn+YvF36FWzv9+y8KiCMhYhdAUS+vSIKY3UZY= 5001 8f/T4ohROj1wa25YHMItOW2/wJhRXZM0+T5/2p86COc= 4982 G/4+VCRLpfjQJ4SAwMDcf+W8PTw0eOBRgFvg4fHUOO8= 4956 KZ5hwP74wRO6kRapVIprwodtNdVD2EVD3hkZmmyXFPk= 4888 MtFK4NN8Kv1k/xPA3wb8SQaP/jWee52FAaC1s9NFsU4= 4813 UQeOwfhcqgEcIwp3cgNiLGW1237Qjpvqzt/asQimVp0= 4778 JA6C0GEK1sSCVbHyqtruH/ARD1NKolYrw7HXy6EVNAc= 4766 8qWeDv6RTv+hYJxW94e7n6HBzHPGPEZW9FuGhj6pPhQ= 4761 35dx60z4m4+Lg+qIS0l2A8vspbthqnpTylWUu51jW+4= 4679 r4lUPUkz3tAgIWaEyrSYVCxX1yz8PnlVuQz+To0Pd+c= 4650 1PR/lVwL4VeYcZjexwBJ2NOSTfgh8JoVxWCunnbJO/8= 4592 7EnDBkQYJpipCyRd9JBsug4iKnfAunUXc14/96cNotg= 4571 Name: song_id, dtype: int64 2. Data PreprocessingNote: This section is to show how to preprocess data. We can also directly start from Step 3 for data extract, transformation and load using integrated transformation function and skip this step if necessary 2.1 Filling missing values12missing_value_cols = [c for c in member_music_df.columns if member_music_df[c].isnull().any()]missing_value_cols ['source_system_tab', 'source_screen_name', 'source_type', 'song_length', 'genre_ids', 'artist_name', 'composer', 'lyricist', 'language', 'bd', 'gender'] 1member_music_df.count() msno 7377418 song_id 7377418 source_system_tab 7352569 source_screen_name 6962614 source_type 7355879 target 7377418 song_length 7377304 genre_ids 7258963 artist_name 7377304 composer 5701712 lyricist 4198620 language 7377268 city 7377418 bd 4430216 gender 4415939 registered_via 7377418 registration_init_day 7377418 registration_init_month 7377418 registration_init_year 7377418 expiration_day 7377418 expiration_month 7377418 expiration_year 7377418 dtype: int64 1234567891011121314151617181920212223242526272829# list of columns with missing values# ['source_system_tab',# 'source_screen_name',# 'source_type',# 'song_length',# 'genre_ids',# 'artist_name',# 'composer',# 'lyricist',# 'language',# 'bd',# 'gender']def fill_missing_value_v1(x): # fill missing values with the most frequent values return x.fillna(x.value_counts().sort_values(ascending=False).index[0]) categorical_ls = ['source_system_tab', 'source_screen_name','source_type','genre_ids','artist_name','composer', 'lyricist','gender']numerical_ls = ['song_length','language','bd']# Fill missing values for index in numerical_ls: member_music_df[index].fillna(member_music_df[index].median(), inplace=True)for index in categorical_ls: member_music_df[index].fillna(\"no_data\", inplace=True) 1member_music_df.count() msno 7377418 song_id 7377418 source_system_tab 7377418 source_screen_name 7377418 source_type 7377418 target 7377418 song_length 7377418 genre_ids 7377418 artist_name 7377418 composer 7377418 lyricist 7377418 language 7377418 city 7377418 bd 7377418 gender 7377418 registered_via 7377418 registration_init_day 7377418 registration_init_month 7377418 registration_init_year 7377418 expiration_day 7377418 expiration_month 7377418 expiration_year 7377418 dtype: int64 12member_music_df[numerical_ls].head(100) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } song_length language bd 0 206471.0 52.0 27.0 1 284584.0 52.0 24.0 2 225396.0 52.0 24.0 3 255512.0 -1.0 24.0 4 187802.0 52.0 27.0 ... ... ... ... 95 333024.0 3.0 27.0 96 288391.0 3.0 46.0 97 279196.0 3.0 46.0 98 240744.0 3.0 46.0 99 221622.0 3.0 46.0 100 rows Ã— 3 columns 12member_music_df[categorical_ls].head(100) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } source_system_tab source_screen_name source_type genre_ids artist_name composer lyricist gender 0 explore Explore online-playlist 359 Bastille Dan Smith| Mark Crew no_data no_data 1 my library Local playlist more local-playlist 1259 Various Artists no_data no_data female 2 my library Local playlist more local-playlist 1259 Nas N. Jonesã€W. Adamsã€J. Lordanã€D. Ingle no_data female 3 my library Local playlist more local-playlist 1019 Soundway Kwadwo Donkoh no_data female 4 explore Explore online-playlist 1011 Brett Young Brett Young| Kelly Archer| Justin Ebach no_data no_data ... ... ... ... ... ... ... ... ... 95 my library no_data local-library 458 æ¥Šä¹ƒæ–‡ (Naiwen Yang) é»ƒå»ºç‚º è‘›å¤§ç‚º male 96 my library Local playlist more local-library 458 é™³å¥•è¿… (Eason Chan) Jun Jie Lin no_data female 97 my library Local playlist more local-library 458 å‘¨æ°å€« (Jay Chou) å‘¨æ°å€« æ–¹æ–‡å±± female 98 my library Local playlist more local-library 465 èŒƒç‘‹çª (Christine Fan) éé éé female 99 my library Local playlist more local-library 465|1259 ç–å£¹å£¹ é™³çš“å®‡ å»–å»ºè‡³|æ´ªç‘œé´» female 100 rows Ã— 8 columns 2.2 Data TransformationWe can see that the columns like genre_ids, composer, lyricist have multiple values in a cell. In this case, the count of genres, composers, lyricist could be useful information as well 1member_music_df.columns Index(['msno', 'song_id', 'source_system_tab', 'source_screen_name', 'source_type', 'target', 'song_length', 'genre_ids', 'artist_name', 'composer', 'lyricist', 'language', 'city', 'bd', 'gender', 'registered_via', 'registration_init_day', 'registration_init_month', 'registration_init_year', 'expiration_day', 'expiration_month', 'expiration_year'], dtype='object') 1member_music_df.genre_ids.nunique(), member_music_df.composer.nunique(), member_music_df.lyricist.nunique() (573, 76065, 33889) 123456789def count_items(x): if x ==\"no_data\": return 0 return sum(map(x.count, ['|', '/', '\\\\', ';',','])) + 1member_music_df['genre_count']= member_music_df['genre_ids'].apply(count_items)member_music_df['composer_count']= member_music_df['composer'].apply(count_items)member_music_df['lyricist_count']= member_music_df['lyricist'].apply(count_items) 1member_music_df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } msno song_id source_system_tab source_screen_name source_type target song_length genre_ids artist_name composer lyricist language city bd gender registered_via registration_init_day registration_init_month registration_init_year expiration_day expiration_month expiration_year genre_count composer_count lyricist_count 0 FGtllVqz18RPiwJj/edr2gV78zirAiY/9SmYvia+kCg= BBzumQNXUHKdEBOB7mAJuzok+IJA1c2Ryg/yzTF6tik= explore Explore online-playlist 1 206471.0 359 Bastille Dan Smith| Mark Crew no_data 52.0 1 27.0 no_data 7 2 1 2012 5 10 2017 1 2 0 1 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= bhp/MpSNoqoxOIB+/l8WPqu6jldth4DIpCm3ayXnJqM= my library Local playlist more local-playlist 1 284584.0 1259 Various Artists no_data no_data 52.0 13 24.0 female 9 25 5 2011 11 9 2017 1 0 0 2 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= JNWfrrC7zNN7BdMpsISKa4Mw+xVJYNnxXh3/Epw7QgY= my library Local playlist more local-playlist 1 225396.0 1259 Nas N. Jonesã€W. Adamsã€J. Lordanã€D. Ingle no_data 52.0 13 24.0 female 9 25 5 2011 11 9 2017 1 1 0 3 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= 2A87tzfnJTSWqD7gIZHisolhe4DMdzkbd6LzO1KHjNs= my library Local playlist more local-playlist 1 255512.0 1019 Soundway Kwadwo Donkoh no_data -1.0 13 24.0 female 9 25 5 2011 11 9 2017 1 1 0 4 FGtllVqz18RPiwJj/edr2gV78zirAiY/9SmYvia+kCg= 3qm6XTZ6MOCU11x8FIVbAGH5l5uMkT3/ZalWG1oo2Gc= explore Explore online-playlist 1 187802.0 1011 Brett Young Brett Young| Kelly Archer| Justin Ebach no_data 52.0 1 27.0 no_data 7 2 1 2012 5 10 2017 1 3 0 1member_music_df.info() 3. Data Extract, Transform and Load (ETL)We can skip Step 2 if we just want to transform data directly 3.1 Transformation Function for Data cleaning123456789101112#import necessary packages hereimport warningswarnings.filterwarnings('ignore')import numpy as np import pandas as pdimport matplotlib.pyplot as pltimport seaborn as snsimport lightgbm as lgbfrom subprocess import check_output# print(check_output([\"ls\", \"../input\"]).decode(\"utf8\"))np.random.seed(2020) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152def transform_data(data, song_df, members_df): # Merge song data with data set data = data.merge(song_df,on='song_id',how=\"left\", copy =False) # preprocess member data members_df[\"registration_init_time\"] = pd.to_datetime(members_df[\"registration_init_time\"], format=\"%Y%m%d\") members_df[\"expiration_date\"] = pd.to_datetime(members_df[\"expiration_date\"], format=\"%Y%m%d\") members_df[\"registration_init_day\"] = members_df[\"registration_init_time\"].dt.day members_df[\"registration_init_month\"] = members_df[\"registration_init_time\"].dt.month members_df[\"registration_init_year\"] = members_df[\"registration_init_time\"].dt.year members_df[\"expiration_day\"] = members_df[\"expiration_date\"].dt.day members_df[\"expiration_month\"] = members_df[\"expiration_date\"].dt.month members_df[\"expiration_year\"] = members_df[\"expiration_date\"].dt.year members_df = members_df.drop(columns = [\"registration_init_time\", \"expiration_date\"],axis=1) # merge member data with dataset data = data.merge(members_df,on='msno',how=\"left\", copy=False) # Remove outliers of bd age data['bd'].loc[(data['bd']&lt;=0) | (data['bd']&gt;=100)]= np.nan categorical_ls = ['source_system_tab', 'source_screen_name','source_type','genre_ids','artist_name','composer', 'lyricist','gender'] numerical_ls = ['song_length','language','bd'] # Fill missing values for index in numerical_ls: data[index].fillna(data[index].median(), inplace=True) for index in categorical_ls: data[index].fillna(\"no_data\", inplace=True) def count_items(x): if x ==\"no_data\": return 0 return sum(map(x.count, ['|', '/', '\\\\', ';',','])) + 1 data['genre_count']= data['genre_ids'].apply(count_items) data['composer_count']= data['composer'].apply(count_items) data['lyricist_count']= data['lyricist'].apply(count_items) # Convert object type to categorical type for c in data.columns: if data[c].dtype=='O': data[c] = data[c].astype(\"category\",copy=False) if 'id' in data.columns: ids = data['id'] data.drop(['id'], inplace=True,axis=1) else: ids =None return ids, data 3.2 Transform the composer, artist, lyricist to counts as new features123456root = './kaggle/working/train/data/'train_df = pd.read_csv(root+ \"train.csv\")test_df = pd.read_csv(root+ \"test.csv\")song_df = pd.read_csv(root+ \"songs.csv\")# song_extra_df = pd.read_csv(root+ \"song_extra_info.csv\")members_df = pd.read_csv(root+ \"members.csv\") 3.2.1 Transform train set1_, train_data = transform_data(train_df, song_df, members_df) 123y_train = train_data['target']train_data.drop(['target'], axis=1,inplace=True)X_train = train_data Transform the name of composer, artist, lyricist to new features like counts, number of intersection of names 12345678910111213141516def transform_names_intersection(data): #This function finds the intersection of names in composer, artist, lyricist def check_name_list(x): #convert string to name list dataframe strings = None strings = x.str.split(r\"//|/|;|ã€|\\| \") return strings df = data[[\"composer\",\"artist_name\", \"lyricist\"]].apply(check_name_list) data[\"composer_artist_intersect\"] =[len(set(a) &amp; set(b)) for a, b in zip(df.composer, df.artist_name)] data[\"composer_lyricist_intersect\"] =[len(set(a) &amp; set(b)) for a, b in zip(df.composer, df.lyricist)] data[\"artist_lyricist_intersect\"] =[len(set(a) &amp; set(b)) for a, b in zip(df.artist_name, df.lyricist)] return data _ = transform_names_intersection(X_train)X_train.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } msno song_id source_system_tab source_screen_name source_type song_length genre_ids artist_name composer lyricist language city bd gender registered_via registration_init_day registration_init_month registration_init_year expiration_day expiration_month expiration_year genre_count composer_count lyricist_count composer_artist_intersect composer_lyricist_intersect artist_lyricist_intersect 0 FGtllVqz18RPiwJj/edr2gV78zirAiY/9SmYvia+kCg= BBzumQNXUHKdEBOB7mAJuzok+IJA1c2Ryg/yzTF6tik= explore Explore online-playlist 206471.0 359 Bastille Dan Smith| Mark Crew no_data 52.0 1 27.0 no_data 7 2 1 2012 5 10 2017 1 2 0 0 0 0 1 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= bhp/MpSNoqoxOIB+/l8WPqu6jldth4DIpCm3ayXnJqM= my library Local playlist more local-playlist 284584.0 1259 Various Artists no_data no_data 52.0 13 24.0 female 9 25 5 2011 11 9 2017 1 0 0 0 1 0 2 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= JNWfrrC7zNN7BdMpsISKa4Mw+xVJYNnxXh3/Epw7QgY= my library Local playlist more local-playlist 225396.0 1259 Nas N. Jonesã€W. Adamsã€J. Lordanã€D. Ingle no_data 52.0 13 24.0 female 9 25 5 2011 11 9 2017 1 1 0 0 0 0 3 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= 2A87tzfnJTSWqD7gIZHisolhe4DMdzkbd6LzO1KHjNs= my library Local playlist more local-playlist 255512.0 1019 Soundway Kwadwo Donkoh no_data -1.0 13 24.0 female 9 25 5 2011 11 9 2017 1 1 0 0 0 0 4 FGtllVqz18RPiwJj/edr2gV78zirAiY/9SmYvia+kCg= 3qm6XTZ6MOCU11x8FIVbAGH5l5uMkT3/ZalWG1oo2Gc= explore Explore online-playlist 187802.0 1011 Brett Young Brett Young| Kelly Archer| Justin Ebach no_data 52.0 1 27.0 no_data 7 2 1 2012 5 10 2017 1 3 0 1 0 0 3.2.2 Transform Testset123ids, test_data = transform_data(test_df, song_df, members_df)_ = transform_names_intersection(test_data)test_data.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } msno song_id source_system_tab source_screen_name source_type song_length genre_ids artist_name composer lyricist language city bd gender registered_via registration_init_day registration_init_month registration_init_year expiration_day expiration_month expiration_year genre_count composer_count lyricist_count composer_artist_intersect composer_lyricist_intersect artist_lyricist_intersect 0 V8ruy7SGk7tDm3zA51DPpn6qutt+vmKMBKa21dp54uM= WmHKgKMlp1lQMecNdNvDMkvIycZYHnFwDT72I5sIssc= my library Local playlist more local-library 224130.0 458 æ¢æ–‡éŸ³ (Rachel Liang) Qi Zheng Zhang no_data 3.0 1 27.0 no_data 7 19 2 2016 18 9 2017 1 1 0 0 0 0 1 V8ruy7SGk7tDm3zA51DPpn6qutt+vmKMBKa21dp54uM= y/rsZ9DC7FwK5F2PK2D5mj+aOBUJAjuu3dZ14NgE0vM= my library Local playlist more local-library 320470.0 465 æ—ä¿Šå‚‘ (JJ Lin) æ—ä¿Šå‚‘ å­«ç‡•å§¿/æ˜“å®¶æš 3.0 1 27.0 no_data 7 19 2 2016 18 9 2017 1 1 2 0 0 0 2 /uQAlrAkaczV+nWCd2sPF2ekvXPRipV7q0l+gbLuxjw= 8eZLFOdGVdXBSqoAv5nsLigeH2BvKXzTQYtUM53I0k4= discover no_data song-based-playlist 315899.0 2022 Yu Takahashi (é«˜æ©‹å„ª) Yu Takahashi Yu Takahashi 17.0 1 27.0 no_data 4 17 11 2016 24 11 2016 1 1 1 0 1 0 3 1a6oo/iXKatxQx4eS9zTVD+KlSVaAFbTIqVvwLC1Y0k= ztCf8thYsS4YN3GcIL/bvoxLm/T5mYBVKOO4C9NiVfQ= radio Radio radio 285210.0 465 U2 The Edge| Adam Clayton| Larry Mullen| Jr. no_data 52.0 3 30.0 male 9 25 7 2007 30 4 2017 1 4 0 0 0 0 4 1a6oo/iXKatxQx4eS9zTVD+KlSVaAFbTIqVvwLC1Y0k= MKVMpslKcQhMaFEgcEQhEfi5+RZhMYlU3eRDpySrH8Y= radio Radio radio 197590.0 873 Yoga Mr Sound Neuromancer no_data -1.0 3 30.0 male 9 25 7 2007 30 4 2017 1 1 0 0 0 0 1X_train.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } msno song_id source_system_tab source_screen_name source_type song_length genre_ids artist_name composer lyricist language city bd gender registered_via registration_init_day registration_init_month registration_init_year expiration_day expiration_month expiration_year genre_count composer_count lyricist_count composer_artist_intersect composer_lyricist_intersect artist_lyricist_intersect 0 FGtllVqz18RPiwJj/edr2gV78zirAiY/9SmYvia+kCg= BBzumQNXUHKdEBOB7mAJuzok+IJA1c2Ryg/yzTF6tik= explore Explore online-playlist 206471.0 359 Bastille Dan Smith| Mark Crew no_data 52.0 1 27.0 no_data 7 2 1 2012 5 10 2017 1 2 0 0 0 0 1 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= bhp/MpSNoqoxOIB+/l8WPqu6jldth4DIpCm3ayXnJqM= my library Local playlist more local-playlist 284584.0 1259 Various Artists no_data no_data 52.0 13 24.0 female 9 25 5 2011 11 9 2017 1 0 0 0 1 0 2 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= JNWfrrC7zNN7BdMpsISKa4Mw+xVJYNnxXh3/Epw7QgY= my library Local playlist more local-playlist 225396.0 1259 Nas N. Jonesã€W. Adamsã€J. Lordanã€D. Ingle no_data 52.0 13 24.0 female 9 25 5 2011 11 9 2017 1 1 0 0 0 0 3 Xumu+NIjS6QYVxDS4/t3SawvJ7viT9hPKXmf0RtLNx8= 2A87tzfnJTSWqD7gIZHisolhe4DMdzkbd6LzO1KHjNs= my library Local playlist more local-playlist 255512.0 1019 Soundway Kwadwo Donkoh no_data -1.0 13 24.0 female 9 25 5 2011 11 9 2017 1 1 0 0 0 0 4 FGtllVqz18RPiwJj/edr2gV78zirAiY/9SmYvia+kCg= 3qm6XTZ6MOCU11x8FIVbAGH5l5uMkT3/ZalWG1oo2Gc= explore Explore online-playlist 187802.0 1011 Brett Young Brett Young| Kelly Archer| Justin Ebach no_data 52.0 1 27.0 no_data 7 2 1 2012 5 10 2017 1 3 0 1 0 0 1test_data.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } msno song_id source_system_tab source_screen_name source_type song_length genre_ids artist_name composer lyricist language city bd gender registered_via registration_init_day registration_init_month registration_init_year expiration_day expiration_month expiration_year genre_count composer_count lyricist_count composer_artist_intersect composer_lyricist_intersect artist_lyricist_intersect 0 V8ruy7SGk7tDm3zA51DPpn6qutt+vmKMBKa21dp54uM= WmHKgKMlp1lQMecNdNvDMkvIycZYHnFwDT72I5sIssc= my library Local playlist more local-library 224130.0 458 æ¢æ–‡éŸ³ (Rachel Liang) Qi Zheng Zhang no_data 3.0 1 27.0 no_data 7 19 2 2016 18 9 2017 1 1 0 0 0 0 1 V8ruy7SGk7tDm3zA51DPpn6qutt+vmKMBKa21dp54uM= y/rsZ9DC7FwK5F2PK2D5mj+aOBUJAjuu3dZ14NgE0vM= my library Local playlist more local-library 320470.0 465 æ—ä¿Šå‚‘ (JJ Lin) æ—ä¿Šå‚‘ å­«ç‡•å§¿/æ˜“å®¶æš 3.0 1 27.0 no_data 7 19 2 2016 18 9 2017 1 1 2 0 0 0 2 /uQAlrAkaczV+nWCd2sPF2ekvXPRipV7q0l+gbLuxjw= 8eZLFOdGVdXBSqoAv5nsLigeH2BvKXzTQYtUM53I0k4= discover no_data song-based-playlist 315899.0 2022 Yu Takahashi (é«˜æ©‹å„ª) Yu Takahashi Yu Takahashi 17.0 1 27.0 no_data 4 17 11 2016 24 11 2016 1 1 1 0 1 0 3 1a6oo/iXKatxQx4eS9zTVD+KlSVaAFbTIqVvwLC1Y0k= ztCf8thYsS4YN3GcIL/bvoxLm/T5mYBVKOO4C9NiVfQ= radio Radio radio 285210.0 465 U2 The Edge| Adam Clayton| Larry Mullen| Jr. no_data 52.0 3 30.0 male 9 25 7 2007 30 4 2017 1 4 0 0 0 0 4 1a6oo/iXKatxQx4eS9zTVD+KlSVaAFbTIqVvwLC1Y0k= MKVMpslKcQhMaFEgcEQhEfi5+RZhMYlU3eRDpySrH8Y= radio Radio radio 197590.0 873 Yoga Mr Sound Neuromancer no_data -1.0 3 30.0 male 9 25 7 2007 30 4 2017 1 1 0 0 0 0 3.2.3 Split validation set and trainset123456789from sklearn.model_selection import StratifiedShuffleSplit, StratifiedKFold, train_test_splitss_split = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=2021)# Split training set and testing settrain_index, valid_index ,test_index = None, None, Nonefor train_i, test_i in ss_split.split(np.zeros(y_train.shape) ,y_train): train_index = train_i test_index = test_i print(train_index.shape, test_index.shape) (5901934,) (1475484,) 12345678X_validset = X_train.iloc[test_index]y_validset = y_train.iloc[test_index].valuesX_trainset = X_train.iloc[train_index]y_trainset = y_train.iloc[train_index].values#delete dataframes to save spacedel X_train, y_train 1X_trainset.info() &lt;class 'pandas.core.frame.DataFrame'&gt; Int64Index: 5901934 entries, 7066318 to 5275539 Data columns (total 27 columns): # Column Dtype --- ------ ----- 0 msno category 1 song_id category 2 source_system_tab category 3 source_screen_name category 4 source_type category 5 song_length float64 6 genre_ids category 7 artist_name category 8 composer category 9 lyricist category 10 language float64 11 city int64 12 bd float64 13 gender category 14 registered_via int64 15 registration_init_day int64 16 registration_init_month int64 17 registration_init_year int64 18 expiration_day int64 19 expiration_month int64 20 expiration_year int64 21 genre_count int64 22 composer_count int64 23 lyricist_count int64 24 composer_artist_intersect int64 25 composer_lyricist_intersect int64 26 artist_lyricist_intersect int64 dtypes: category(10), float64(3), int64(14) memory usage: 966.0 MB 4. LGBM Modeling123import lightgbm as lgbtrain_set = lgb.Dataset(X_trainset, y_trainset)valid_set = lgb.Dataset(X_validset, y_validset) 12num_leaves = 110max_depths = [10, 15, 20, 25,30] 5.Model Training and Validation on LGBM models12345678910111213141516171819params = { 'objective': 'binary', 'metric': 'binary_logloss', 'boosting': 'gbdt', 'learning_rate': 0.3 , 'verbose': 0, 'num_leaves': num_leaves, 'bagging_fraction': 0.95, 'bagging_freq': 1, 'bagging_seed': 1, 'feature_fraction': 0.9, 'feature_fraction_seed': 1, 'max_bin': 256, 'max_depth': max_depths[0], 'num_rounds': 200, 'metric' : 'auc' }%time model_f1 = lgb.train(params, train_set=train_set, valid_sets=valid_set, verbose_eval=5) [5] valid_0's auc: 0.710928 [10] valid_0's auc: 0.723954 [15] valid_0's auc: 0.731661 [20] valid_0's auc: 0.736653 [25] valid_0's auc: 0.740424 [30] valid_0's auc: 0.744678 [35] valid_0's auc: 0.749056 [40] valid_0's auc: 0.752277 [45] valid_0's auc: 0.754501 [50] valid_0's auc: 0.756448 [55] valid_0's auc: 0.758097 [60] valid_0's auc: 0.75991 [65] valid_0's auc: 0.761418 [70] valid_0's auc: 0.762683 [75] valid_0's auc: 0.764243 [80] valid_0's auc: 0.765646 [85] valid_0's auc: 0.766883 [90] valid_0's auc: 0.767921 [95] valid_0's auc: 0.769111 [100] valid_0's auc: 0.770006 [105] valid_0's auc: 0.770934 [110] valid_0's auc: 0.772012 [115] valid_0's auc: 0.772747 [120] valid_0's auc: 0.773835 [125] valid_0's auc: 0.774486 [130] valid_0's auc: 0.775258 [135] valid_0's auc: 0.775887 [140] valid_0's auc: 0.776838 [145] valid_0's auc: 0.777587 [150] valid_0's auc: 0.778113 [155] valid_0's auc: 0.778714 [160] valid_0's auc: 0.77929 [165] valid_0's auc: 0.779884 [170] valid_0's auc: 0.780354 [175] valid_0's auc: 0.781586 [180] valid_0's auc: 0.782002 [185] valid_0's auc: 0.782517 [190] valid_0's auc: 0.783075 [195] valid_0's auc: 0.783496 [200] valid_0's auc: 0.784083 CPU times: user 8min 20s, sys: 3 s, total: 8min 23s Wall time: 4min 25s 12345678910111213141516171819params = { 'objective': 'binary', 'metric': 'binary_logloss', 'boosting': 'gbdt', 'learning_rate': 0.3 , 'verbose': 0, 'num_leaves': num_leaves, 'bagging_fraction': 0.95, 'bagging_freq': 1, 'bagging_seed': 1, 'feature_fraction': 0.9, 'feature_fraction_seed': 1, 'max_bin': 256, 'max_depth': max_depths[1], 'num_rounds': 200, 'metric' : 'auc' }%time model_f2 = lgb.train(params, train_set=train_set, valid_sets=valid_set, verbose_eval=5) [5] valid_0's auc: 0.727917 [10] valid_0's auc: 0.742629 [15] valid_0's auc: 0.74811 [20] valid_0's auc: 0.754257 [25] valid_0's auc: 0.758256 [30] valid_0's auc: 0.76119 [35] valid_0's auc: 0.763674 [40] valid_0's auc: 0.76626 [45] valid_0's auc: 0.7681 [50] valid_0's auc: 0.769933 [55] valid_0's auc: 0.771692 [60] valid_0's auc: 0.773121 [65] valid_0's auc: 0.774693 [70] valid_0's auc: 0.776149 [75] valid_0's auc: 0.777157 [80] valid_0's auc: 0.778674 [85] valid_0's auc: 0.780085 [90] valid_0's auc: 0.78098 [95] valid_0's auc: 0.782016 [100] valid_0's auc: 0.783028 [105] valid_0's auc: 0.783782 [110] valid_0's auc: 0.784875 [115] valid_0's auc: 0.785417 [120] valid_0's auc: 0.786042 [125] valid_0's auc: 0.78665 [130] valid_0's auc: 0.787237 [135] valid_0's auc: 0.787897 [140] valid_0's auc: 0.788426 [145] valid_0's auc: 0.788904 [150] valid_0's auc: 0.789517 [155] valid_0's auc: 0.78991 [160] valid_0's auc: 0.790561 [165] valid_0's auc: 0.791319 [170] valid_0's auc: 0.791855 [175] valid_0's auc: 0.792519 [180] valid_0's auc: 0.792922 [185] valid_0's auc: 0.793727 [190] valid_0's auc: 0.794061 [195] valid_0's auc: 0.794584 [200] valid_0's auc: 0.794811 CPU times: user 9min 27s, sys: 1.28 s, total: 9min 28s Wall time: 4min 51s 12345678910111213141516171819params = { 'objective': 'binary', 'metric': 'binary_logloss', 'boosting': 'gbdt', 'learning_rate': 0.3 , 'verbose': 0, 'num_leaves': num_leaves, 'bagging_fraction': 0.95, 'bagging_freq': 1, 'bagging_seed': 1, 'feature_fraction': 0.9, 'feature_fraction_seed': 1, 'max_bin': 256, 'max_depth': max_depths[2], 'num_rounds': 200, 'metric' : 'auc' }%time model_f3 = lgb.train(params, train_set=train_set, valid_sets=valid_set, verbose_eval=5) [5] valid_0's auc: 0.734133 [10] valid_0's auc: 0.749742 [15] valid_0's auc: 0.75615 [20] valid_0's auc: 0.761276 [25] valid_0's auc: 0.766358 [30] valid_0's auc: 0.769127 [35] valid_0's auc: 0.771531 [40] valid_0's auc: 0.773761 [45] valid_0's auc: 0.775287 [50] valid_0's auc: 0.777329 [55] valid_0's auc: 0.779154 [60] valid_0's auc: 0.780391 [65] valid_0's auc: 0.782072 [70] valid_0's auc: 0.783786 [75] valid_0's auc: 0.784989 [80] valid_0's auc: 0.785685 [85] valid_0's auc: 0.786851 [90] valid_0's auc: 0.787643 [95] valid_0's auc: 0.788312 [100] valid_0's auc: 0.789305 [105] valid_0's auc: 0.790256 [110] valid_0's auc: 0.791037 [115] valid_0's auc: 0.79177 [120] valid_0's auc: 0.792466 [125] valid_0's auc: 0.792988 [130] valid_0's auc: 0.793478 [135] valid_0's auc: 0.793961 [140] valid_0's auc: 0.794871 [145] valid_0's auc: 0.795495 [150] valid_0's auc: 0.795952 [155] valid_0's auc: 0.796269 [160] valid_0's auc: 0.796888 [165] valid_0's auc: 0.797808 [170] valid_0's auc: 0.7982 [175] valid_0's auc: 0.798443 [180] valid_0's auc: 0.798959 [185] valid_0's auc: 0.799395 [190] valid_0's auc: 0.799687 [195] valid_0's auc: 0.800153 [200] valid_0's auc: 0.800409 CPU times: user 11min 16s, sys: 1.54 s, total: 11min 17s Wall time: 5min 47s 12345678910111213141516171819params = { 'objective': 'binary', 'metric': 'binary_logloss', 'boosting': 'gbdt', 'learning_rate': 0.3 , 'verbose': 0, 'num_leaves': num_leaves, 'bagging_fraction': 0.95, 'bagging_freq': 1, 'bagging_seed': 1, 'feature_fraction': 0.9, 'feature_fraction_seed': 1, 'max_bin': 256, 'max_depth': max_depths[3], 'num_rounds': 200, 'metric' : 'auc' }%time model_f4 = lgb.train(params, train_set=train_set, valid_sets=valid_set, verbose_eval=5) [5] valid_0's auc: 0.736351 [10] valid_0's auc: 0.754592 [15] valid_0's auc: 0.76195 [20] valid_0's auc: 0.766405 [25] valid_0's auc: 0.770538 [30] valid_0's auc: 0.772566 [35] valid_0's auc: 0.775789 [40] valid_0's auc: 0.777994 [45] valid_0's auc: 0.779658 [50] valid_0's auc: 0.781394 [55] valid_0's auc: 0.783194 [60] valid_0's auc: 0.784808 [65] valid_0's auc: 0.786109 [70] valid_0's auc: 0.787265 [75] valid_0's auc: 0.788079 [80] valid_0's auc: 0.789109 [85] valid_0's auc: 0.78986 [90] valid_0's auc: 0.790613 [95] valid_0's auc: 0.791347 [100] valid_0's auc: 0.79209 [105] valid_0's auc: 0.793348 [110] valid_0's auc: 0.79409 [115] valid_0's auc: 0.794754 [120] valid_0's auc: 0.795411 [125] valid_0's auc: 0.795866 [130] valid_0's auc: 0.796604 [135] valid_0's auc: 0.79781 [140] valid_0's auc: 0.798172 [145] valid_0's auc: 0.798723 [150] valid_0's auc: 0.799132 [155] valid_0's auc: 0.799488 [160] valid_0's auc: 0.800115 [165] valid_0's auc: 0.800509 [170] valid_0's auc: 0.800784 [175] valid_0's auc: 0.801118 [180] valid_0's auc: 0.801448 [185] valid_0's auc: 0.801882 [190] valid_0's auc: 0.8022 [195] valid_0's auc: 0.802578 [200] valid_0's auc: 0.802953 CPU times: user 12min 34s, sys: 1.44 s, total: 12min 36s Wall time: 6min 27s 12345678910111213141516171819params = { 'objective': 'binary', 'metric': 'binary_logloss', 'boosting': 'gbdt', 'learning_rate': 0.3 , 'verbose': 0, 'num_leaves': num_leaves, 'bagging_fraction': 0.95, 'bagging_freq': 1, 'bagging_seed': 1, 'feature_fraction': 0.9, 'feature_fraction_seed': 1, 'max_bin': 256, 'max_depth': max_depths[4], 'num_rounds': 200, 'metric' : 'auc' }%time model_f5 = lgb.train(params, train_set=train_set, valid_sets=valid_set, verbose_eval=5) [5] valid_0's auc: 0.739442 [10] valid_0's auc: 0.757442 [15] valid_0's auc: 0.766439 [20] valid_0's auc: 0.77132 [25] valid_0's auc: 0.774735 [30] valid_0's auc: 0.777071 [35] valid_0's auc: 0.779247 [40] valid_0's auc: 0.781616 [45] valid_0's auc: 0.782953 [50] valid_0's auc: 0.785154 [55] valid_0's auc: 0.786877 [60] valid_0's auc: 0.787993 [65] valid_0's auc: 0.788839 [70] valid_0's auc: 0.790254 [75] valid_0's auc: 0.791088 [80] valid_0's auc: 0.792455 [85] valid_0's auc: 0.79365 [90] valid_0's auc: 0.794445 [95] valid_0's auc: 0.795072 [100] valid_0's auc: 0.796276 [105] valid_0's auc: 0.797737 [110] valid_0's auc: 0.798265 [115] valid_0's auc: 0.799021 [120] valid_0's auc: 0.799964 [125] valid_0's auc: 0.800469 [130] valid_0's auc: 0.801445 [135] valid_0's auc: 0.801851 [140] valid_0's auc: 0.802299 [145] valid_0's auc: 0.802599 [150] valid_0's auc: 0.803381 [155] valid_0's auc: 0.803696 [160] valid_0's auc: 0.803926 [165] valid_0's auc: 0.80443 [170] valid_0's auc: 0.804694 [175] valid_0's auc: 0.804897 [180] valid_0's auc: 0.80524 [185] valid_0's auc: 0.805486 [190] valid_0's auc: 0.805804 [195] valid_0's auc: 0.806059 [200] valid_0's auc: 0.806525 CPU times: user 14min 7s, sys: 1.66 s, total: 14min 9s Wall time: 7min 14s 6.Model Evaluation on LGBM models12345678from sklearn.metrics import accuracy_scoredef evaluation_lgbm(model, X =X_validset , y= y_validset): out = model.predict(X) preds = out&gt;=0.5 acc = accuracy_score(preds, y) print(\"Evaluation acc:\", acc) return acc 1X_validset.shape (1475484, 27) 12345acc_1 = evaluation_lgbm(model_f1)acc_2 = evaluation_lgbm(model_f2)acc_3 = evaluation_lgbm(model_f3)acc_4 = evaluation_lgbm(model_f4)acc_5 = evaluation_lgbm(model_f5) Evaluation acc: 0.709764389176704 Evaluation acc: 0.719106408473423 Evaluation acc: 0.7236893114395005 Evaluation acc: 0.7258221708944319 Evaluation acc: 0.728842196865571 12eval_df = pd.DataFrame({\"Lgbm with max_depth\":max_depths,\"Validation Accuracy\":[acc_1,acc_2,acc_3,acc_4,acc_5]})eval_df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Lgbm with max_depth Validation Accuracy 0 10 0.709764 1 15 0.719106 2 20 0.723689 3 25 0.725822 4 30 0.728842 Create Submission Files12345678models = [model_f1,model_f2,model_f3,model_f4,model_f5]for i in range(len(models)): preds_test = models[i].predict(test_data) submission = pd.DataFrame() submission['id'] = ids submission['target'] = preds_test submission.to_csv(root + 'submission_lgbm_model_'+ str(i)+'.csv.gz', compression = 'gzip', index=False, float_format = '%.5f') print(\"Predictions from model \",i,\": \",preds_test) Predictions from model 0 : [0.47177512 0.48584262 0.19651648 ... 0.39917036 0.30263348 0.36468783] Predictions from model 1 : [0.45280296 0.55415074 0.17824637 ... 0.41500494 0.30757934 0.34520384] Predictions from model 2 : [0.39847416 0.48724786 0.15954141 ... 0.38293317 0.27657349 0.28451098] Predictions from model 3 : [0.3825275 0.39659855 0.15904321 ... 0.3515784 0.21812496 0.28995803] Predictions from model 4 : [0.3951268 0.45704878 0.14609333 ... 0.35033303 0.23065677 0.2885925 ] Scores from kaggle test set Model name private score public score LGBM Boosting Machine Model 4 0.67423 0.67256 LGBM Boosting Machine Model 3 0.67435 0.67241 LGBM Boosting Machine Model 2 0.67416 0.67208 LGBM Boosting Machine Model 1 0.67416 0.67188 LGBM Boosting Machine Model 0 0.67206 0.66940 4. Wide &amp; Depth neural network modelWide and Deep modelï¼ˆ2 branchesâ€“&gt;merge two branchesâ€“&gt;main branchï¼‰ This model converts categorical attributes into dense vectors using embedding network in neural network, which enable us to reduce the dimension of categorical data and extract main features like PCA. Then it combines dense embedded vectors with numerical data for features selection and classifcation in the main branch. The output is possibility that user may repeat listening to the music Label Encoding for categorical dataConvert categorical data into numerical labels before using embedding 12345678910111213141516171819202122232425262728from sklearn.preprocessing import LabelEncodercategorical_ls1 = ['source_system_tab', 'source_screen_name','source_type','genre_ids','gender']categorical_ls2 = ['artist_name','composer', 'lyricist']numerical_ls = ['song_length','language','bd',\"registration_init_year\", \"expiration_day\",\"expiration_month\",\"expiration_year\", \"genre_count\",\"composer_count\",\"lyricist_count\",\"composer_artist_intersect\", \"composer_lyricist_intersect\",\"artist_lyricist_intersect\"]max_values = {}# labelencoders = {}for col in categorical_ls1: print(col) lbl = LabelEncoder() df = pd.concat([X_trainset[col], X_validset[col],test_data[col]],ignore_index=True) lbl.fit(df) df = lbl.transform(list(df.values.astype('str',copy=False))) X_trainset[col] = lbl.transform(list(X_trainset[col].values.astype('str',copy=False))) X_validset[col] = lbl.transform(list(X_validset[col].values.astype('str',copy=False))) test_data[col] = lbl.transform(list(test_data[col].values.astype('str',copy=False))) max_values[col] = df.max() + 2 #set the range of embedding input larger# Compute embedding dimensionsemb_dims1 = []emb_dims2 = []for i in categorical_ls1: emb_dims1.append((max_values[i], min((max_values[i]+1)//2, 50))) source_system_tab source_screen_name source_type genre_ids gender 12# max_valuesX_trainset.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } msno song_id source_system_tab source_screen_name source_type song_length genre_ids artist_name composer lyricist language city bd gender registered_via registration_init_day registration_init_month registration_init_year expiration_day expiration_month expiration_year genre_count composer_count lyricist_count composer_artist_intersect composer_lyricist_intersect artist_lyricist_intersect 7066318 BQ7nOoOUipsqjOBANK+ilA8F7TVaOHSI8gVPWElXsuI= FaTUlIiCh/6sEOasPm1vgIk9XqavgSGgRGYuOkzTF0o= 0 3 7 203520.0 364 ç”°é¦¥ç”„ (Hebe) å€ªå­å²¡ ææ ¼å¼Ÿ 3.0 5 25.0 0 9 2 9 2006 11 10 2017 1 1 1 0 0 0 1471565 Ul+UpO5PxuhCn040AK8gzR1A/mE/k3KbL13gO7Uc4Ts= +SstqMwhQPBQFTPBhLKPT642IiBDXzZFwlzsLl4cGXo= 3 8 3 283846.0 371 é™³å‹¢å®‰ (Andrew Tan) è¦ƒå˜‰å¥ é¦¬åµ©æƒŸ 3.0 13 47.0 0 9 1 2 2006 30 9 2017 1 1 1 0 0 0 6176886 sa6oKy94c62R5Eq0YHkNzZrJSo9j5E7JGjTDHnYRKqs= K6fBQxiNhgWazjXrZUGlZIm9ltT4o+Vq19sWmZRdAhg= 2 12 2 296960.0 371 è”¡ä¾æ— (Jolin Tsai) éƒ­å­ é„”è£•åº· 3.0 5 38.0 1 7 27 11 2011 30 12 2017 1 1 1 0 0 0 3527889 LG/BLgJxw5AvXy0pkgaHYYWeU7jKS+ms/51+7TaBY9Y= O+/KJ5a5GzbgLZrCOw/t/iDOPTrDcrz5ZnOtaK9blA8= 3 8 0 235403.0 200 ONE OK ROCK Toru/Taka Taka 17.0 1 27.0 2 7 1 6 2013 1 10 2017 1 2 1 0 1 0 6073849 KmAJtsNcrofH6qMoHvET89mQAlC1EN3r3r3rkfW2iT4= WogFv1yz1n49l4gNSbf76bWxas8nNvzHntrj4FuzC24= 3 22 7 210604.0 371 Twins no_data no_data 24.0 13 28.0 1 9 2 11 2016 7 10 2017 1 0 0 0 1 0 1X_validset.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } msno song_id source_system_tab source_screen_name source_type song_length genre_ids artist_name composer lyricist language city bd gender registered_via registration_init_day registration_init_month registration_init_year expiration_day expiration_month expiration_year genre_count composer_count lyricist_count composer_artist_intersect composer_lyricist_intersect artist_lyricist_intersect 3400479 RZDFiPWpvwi1RWF5NAPEkvmogqe+7rGys+zoLU9he2M= MvON55vzjT7QW7GSs/UVLZrE/LJpMAVFUjXwZczdw40= 0 11 7 356379.0 97 Nas Amy Winehouse| Salaam Remi| Nasir Jones p/k/a NAS no_data 52.0 1 27.0 2 7 7 12 2010 20 9 2017 1 5 0 0 0 0 2481022 C3EZ5oh7XDt5fP9OY20RPlD8MA+rBknmvmDhA1tHGMU= 5PvPCUIB7vVuCNpQRKXIOcWvh9EerujDAbrjV7G6ZE0= 3 8 3 216920.0 349 è²´æ—ç²¾é¸ no_data Super Market| Microdot 31.0 5 27.0 2 3 11 12 2012 5 1 2018 1 0 2 0 0 0 5808216 O1pwjdTED6P3lKm52VBxVUtaSVc31S9PmIw+07WBNw4= va3+1L2wraJkzDbHjvdo+e+0TTJcLko0k0pqBn09nJE= 3 8 3 268225.0 548 Various Artists no_data no_data 3.0 13 82.0 0 9 29 4 2007 23 1 2018 1 0 0 0 1 0 42686 WFCCMzA4hADGBduTS6X8mXlutyiC0P33QkTG6zr5yCg= U9kojfZSKaiWOW94PKh1Riyv/zUWxmBRmv0XInQWLGw= 7 11 7 290063.0 364 å‘¨æ°å€« (Jay Chou) å‘¨æ°å€« æ–¹æ–‡å±± 3.0 13 32.0 0 7 12 12 2010 9 9 2017 1 1 1 0 0 0 1850837 h0fTru8nYMv9bR0j6kBh8kiXDaybzWBYaSHbUIVzeBs= J1sgBEFbcXSK6eiN7CK1WNxsso0/sY6t0BMX+c+iPNw= 0 11 7 220450.0 111 Usher no_data no_data 52.0 22 28.0 0 9 2 1 2008 28 9 2017 3 0 0 0 1 0 123456789101112131415161718192021222324252627282930313233343536373839import torchfrom torch import nnimport torch.nn.functional as Ffrom torch.utils.data import Dataset, DataLoaderclass TabularDataset(Dataset): def __init__(self, x_data, y_data, cat_cols1, cat_cols2, num_cols): \"\"\" data: pandas data frame; cat_cols: list of string, the names of the categorical columns in the data, will be passed through the embedding layers; num_cols: list of string y_data: the target \"\"\" self.n = x_data.shape[0] self.y = y_data.astype(np.float32).reshape(-1, 1)#.values.reshape(-1, 1) self.cat_cols1 = cat_cols1 self.cat_cols2 = cat_cols2 self.num_cols = num_cols self.num_X = x_data[self.num_cols].astype(np.float32).values self.cat_X1 = x_data[self.cat_cols1].astype(np.int64).values self.cat_X2 = x_data[self.cat_cols2].astype(np.int64).values def print_data(self): return self.num_X, self.cat_X1, self.cat_X2, self.y def __len__(self): \"\"\" total number of samples \"\"\" return self.n def __getitem__(self, idx): \"\"\" Generates one sample of data. \"\"\" return [self.y[idx], self.num_X[idx], self.cat_X1[idx], self.cat_X2[idx]] 12345train_dataset = TabularDataset(x_data=X_trainset, y_data=y_trainset, cat_cols1=categorical_ls1, cat_cols2=[], num_cols=numerical_ls)val_dataset = TabularDataset(x_data=X_validset, y_data=y_validset, cat_cols1=categorical_ls1, cat_cols2=[], num_cols=numerical_ls) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class FeedForwardNN(nn.Module): def __init__(self, emb_dims1, emb_dims2, no_of_num, lin_layer_sizes, output_size, emb_dropout, lin_layer_dropouts, branch2_enable=0): \"\"\" emb_dims: List of two element tuples; no_of_num: Integer, the number of continuous features in the data; lin_layer_sizes: List of integers. The size of each linear layer; output_size: Integer, the size of the final output; emb_dropout: Float, the dropout to be used after the embedding layers. lin_layer_dropouts: List of floats, the dropouts to be used after each linear layer. \"\"\" super().__init__() self.branch2_enable = branch2_enable # embedding layers self.emb_layers1 = nn.ModuleList([nn.Embedding(x, y) for x, y in emb_dims1]) self.emb_layers2 = nn.ModuleList([nn.Embedding(x, y) for x, y in emb_dims2]) # è®¡ç®—å„ä¸ªembå‚æ•°æ•°é‡ï¼Œä¸ºåç»­Linear layerçš„è¾“å…¥åšå‡†å¤‡ self.no_of_embs1 = sum([y for x, y in emb_dims1]) self.no_of_embs2 = sum([y for x, y in emb_dims2]) self.no_of_num = no_of_num # åˆ†æ”¯1 self.branch1 = nn.Linear(self.no_of_embs1, lin_layer_sizes[0]) self.branch1_2 = nn.Linear(lin_layer_sizes[0], lin_layer_sizes[1]) nn.init.kaiming_normal_(self.branch1.weight.data) nn.init.kaiming_normal_(self.branch1_2.weight.data) # åˆ†æ”¯2 if branch2_enable: self.branch2 = nn.Linear(self.no_of_embs2, lin_layer_sizes[0] * 2) self.branch2_2 = nn.Linear(lin_layer_sizes[0] * 2, lin_layer_sizes[1] * 2) nn.init.kaiming_normal_(self.branch2.weight.data) nn.init.kaiming_normal_(self.branch2_2.weight.data) # ä¸»åˆ†æ”¯# self.main_layer1 = nn.Linear(lin_layer_sizes[1] * 3 + self.no_of_num, lin_layer_sizes[2]) self.main_layer1 = nn.Linear(77, lin_layer_sizes[2]) self.main_layer2 = nn.Linear(lin_layer_sizes[2], lin_layer_sizes[3]) # batch normal self.branch_bn_layers1 = nn.BatchNorm1d(lin_layer_sizes[0]) self.branch_bn_layers2 = nn.BatchNorm1d(lin_layer_sizes[0] * 2) self.main_bn_layer = nn.BatchNorm1d(lin_layer_sizes[2]) # Dropout Layers self.emb_dropout_layer = nn.Dropout(emb_dropout) self.dropout_layers = nn.ModuleList([nn.Dropout(size) for size in lin_layer_dropouts]) # Output layer self.output_layer = nn.Linear(lin_layer_sizes[-1], output_size) nn.init.kaiming_normal_(self.output_layer.weight.data) self.sigmoid = nn.Sigmoid() def forward(self, num_data, cat_data1, cat_data2): # embedding categorical feature and cat them together x1 = [emb_layer(torch.tensor(cat_data1[:, i])) for i, emb_layer in enumerate(self.emb_layers1)] x1 = torch.cat(x1, 1) x1 = self.emb_dropout_layer(F.relu(self.branch1(x1))) x1 = self.branch_bn_layers1(x1) x1 = self.dropout_layers[0](F.relu(self.branch1_2(x1))) if self.branch2_enable: x2 = [emb_layer(torch.tensor(cat_data2[:, i])) for i, emb_layer in enumerate(self.emb_layers2)] x2 = torch.cat(x2, 1) x2 = self.emb_dropout_layer(F.relu(self.branch2(x2))) x2 = self.branch_bn_layers2(x2) x2 = self.dropout_layers[0](F.relu(self.branch2_2(x2))) main = torch.cat([x1, x2, num_data], 1) else: main = torch.cat([x1, num_data], 1)# print(\"Main Shape: \", main.shape) main = self.dropout_layers[1](F.relu(self.main_layer1(main))) main = self.main_bn_layer(main) main = self.dropout_layers[2](F.relu(self.main_layer2(main))) out = self.output_layer(main) out = self.sigmoid(out) return out 123batchsize = 64train_dataloader = DataLoader(train_dataset, batchsize, shuffle=True, num_workers=2)val_dataloader = DataLoader(val_dataset, 64, shuffle=True, num_workers=2) 1# next(iter(train_dataloader))[3] 123456789np.random.seed(2020)device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")model = FeedForwardNN(emb_dims1=emb_dims1, emb_dims2=emb_dims2, no_of_num=len(numerical_ls), lin_layer_sizes=[128,64,32,16], output_size=1, lin_layer_dropouts=[0.1, 0.1, 0.05], emb_dropout=0.05).to(device) 1device,len(train_dataloader) (device(type='cpu'), 92218) 5.Model Training and Validation on Wide and Deep model12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273no_of_epochs = 2batch_num = 4000# criterion = torch.nn.MSELoss()criterion = torch.nn.BCELoss()optimizer = torch.optim.Adam(model.parameters(), lr=0.001)lrscheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode='max', factor=0.1, patience=2, threshold=0.9 )total_data = train_dataset.__len__()best_val_score = 0.0best_model =Noneprint_every = 500steps = 0running_loss = 0for epoch in range(no_of_epochs): model.train() batch_cnt = 0 for index, datas in enumerate(train_dataloader): if batch_cnt == batch_num: break steps += 1 batch_cnt += 1 y, num_x, cat_x1, cat_x2 = datas cat_x1 = cat_x1.to(device) cat_x2 = cat_x2.to(device) num_x = num_x.to(device) y = y.to(device) # Forward Pass optimizer.zero_grad() preds = model.forward(num_x, cat_x1, cat_x2) loss = criterion(preds, y) loss.backward() optimizer.step() running_loss += loss.item() if steps % print_every == 0: val_loss = 0 model.eval() val_acc = 0. total_len = 0. with torch.no_grad(): for val_index, val_datas in enumerate(val_dataloader): y, num_x, cat_x1, cat_x2 = val_datas cat_x1 = cat_x1.to(device) cat_x2 = cat_x2.to(device) num_x = num_x.to(device) y = y.to(device) out = model.forward(num_x, cat_x1, cat_x2) batch_loss = criterion(out, y) val_acc += ((out&gt;0.5)==y ).sum().detach().to('cpu').numpy() total_len += len(out) val_loss += batch_loss.item() val_acc /= total_len if val_acc&gt; best_val_score: best_val_score = val_acc torch.save(model,\"checkpoint.pt\") # print(\"Checkpoint saved.\") # update scheduler lrscheduler.step(val_loss) print(f\"Epoch {epoch+1}/{no_of_epochs}..\" f\"Train loss:{running_loss/print_every:.4f}..\" f\"Validation loss:{val_loss/len(val_dataloader):.4f}..\" f\"Validation Acc:{val_acc:.4f}..\" f\"Best Validation Acc:{best_val_score:.4f}..\") running_loss = 0 model.train()print(\"Training Completed\")best_model = torch.load(\"checkpoint.pt\") Epoch 1/2..Train loss:0.6945..Validation loss:0.6925..Validation Acc:0.5302..Best Validation Acc:0.5302.. Epoch 1/2..Train loss:0.6742..Validation loss:0.6663..Validation Acc:0.6229..Best Validation Acc:0.6229.. Epoch 1/2..Train loss:0.6640..Validation loss:0.6618..Validation Acc:0.6245..Best Validation Acc:0.6245.. Epoch 1/2..Train loss:0.6623..Validation loss:0.6768..Validation Acc:0.6252..Best Validation Acc:0.6252.. Epoch 1/2..Train loss:0.6628..Validation loss:0.6648..Validation Acc:0.6249..Best Validation Acc:0.6252.. Epoch 1/2..Train loss:0.6636..Validation loss:0.6656..Validation Acc:0.6253..Best Validation Acc:0.6253.. Epoch 1/2..Train loss:0.6623..Validation loss:0.6674..Validation Acc:0.6254..Best Validation Acc:0.6254.. Epoch 1/2..Train loss:0.6640..Validation loss:0.6649..Validation Acc:0.6255..Best Validation Acc:0.6255.. Epoch 2/2..Train loss:0.6597..Validation loss:0.6638..Validation Acc:0.6256..Best Validation Acc:0.6256.. Epoch 2/2..Train loss:0.6605..Validation loss:0.6584..Validation Acc:0.6259..Best Validation Acc:0.6259.. Epoch 2/2..Train loss:0.6609..Validation loss:0.6636..Validation Acc:0.6263..Best Validation Acc:0.6263.. Epoch 2/2..Train loss:0.6602..Validation loss:0.6620..Validation Acc:0.6263..Best Validation Acc:0.6263.. Epoch 2/2..Train loss:0.6647..Validation loss:0.6658..Validation Acc:0.6264..Best Validation Acc:0.6264.. Epoch 2/2..Train loss:0.6615..Validation loss:0.6644..Validation Acc:0.6262..Best Validation Acc:0.6264.. Epoch 2/2..Train loss:0.6641..Validation loss:0.6764..Validation Acc:0.6254..Best Validation Acc:0.6264.. Epoch 2/2..Train loss:0.6600..Validation loss:0.6926..Validation Acc:0.6263..Best Validation Acc:0.6264.. Training Completed 1print(f\"Best Validation Acc:{best_val_score:.4f}..\") Best Validation Acc:0.6264.. 1model = torch.load(\"checkpoint.pt\") 12test_dataset = TabularDataset(x_data=test_data, y_data=np.zeros(len(test_data)), cat_cols1=categorical_ls1, cat_cols2=[], num_cols=numerical_ls) 123456789101112131415161718192021def evaluation(test_dataloder): model.eval() total_cnt = 0. correct_cnt = 0. acc = None with torch.no_grad(): for test_index, test_datas in enumerate(test_dataloder): y, num_x, cat_x1, cat_x2 = test_datas cat_x1 = cat_x1.to(device) cat_x2 = cat_x2.to(device) num_x = num_x.to(device) y = y.to(device) out = model.forward(num_x, cat_x1, cat_x2) correct_cnt += ((out&gt;0.5)==y ).sum().detach().to('cpu').numpy() total_cnt += len(out)# out = out.squeeze().to(\"cpu\").numpy().tolist() acc = 100* correct_cnt / total_cnt print(\"Evaluation Acc: %.4f %%\"%(acc)) return acc 6.Model Evaluation on Wide and Deep model using validation set1acc = evaluation(val_dataloader) Evaluation Acc: 62.6432 % 1234567891011121314151617def predict_test(test_dataset): preds = [] model.eval() test_dataloder = DataLoader(test_dataset, 200, shuffle=False, num_workers=4) with torch.no_grad(): for test_index, test_datas in enumerate(test_dataloder): y, num_x, cat_x1, cat_x2 = test_datas cat_x1 = cat_x1.to(device) cat_x2 = cat_x2.to(device) num_x = num_x.to(device) y = y.to(device) out = model.forward(num_x, cat_x1, cat_x2) out = out.squeeze().to(\"cpu\").numpy().tolist()# print(out) preds.extend(out) return np.array(preds) Make Predictions and submission1234567preds = predict_test(test_dataset)submission = pd.DataFrame()submission['id'] = idssubmission['target'] = predssubmission.to_csv(root + 'submission_WideAndDeep_model.csv.gz', compression = 'gzip', index=False, float_format = '%.5f')print(\"Model Predictions: \",preds)# !kaggle competitions submit -c ./train/data -f submission_lgbm_model.csv.gz -m \"Message\" Model Predictions: [0.60901934 0.60901934 0.35112065 ... 0.54463851 0.48204085 0.54300648] submission_WideAndDeep_model.csv.gzWideAndDeep_model0.616280.61117 12perf_df = pd.DataFrame({\"model name\":['Wide and Deep model'],\"private_score\":[0.61628], \"public score\": [0.61117]})perf_df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } model name private_score public score 0 Wide and Deep model 0.61628 0.61117 12345model_names = [\"lgbm model 0\",\"lgbm model 1\",\"lgbm model 2\",\"lgbm model 3\",\"lgbm model 4\"]private_score = [0.67206,0.67416,0.67416,0.67435,0.67423]public_score = [0.66940,0.67188,0.67208,0.67241,0.67256]perf_df = pd.DataFrame({\"model name\":model_names,\"max_depth:\":max_depths,\"private_score\":private_score, \"public score\": public_score})perf_df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } model name max_depth: private_score public score 0 lgbm model 0 10 0.67206 0.66940 1 lgbm model 1 15 0.67416 0.67188 2 lgbm model 2 20 0.67416 0.67208 3 lgbm model 3 25 0.67435 0.67241 4 lgbm model 4 30 0.67423 0.67256 7. SummaryType answers here","link":"/2020/12/01/kkboxmusicrecommendation-notebook-v4/"}],"tags":[{"name":"DeepFM","slug":"DeepFM","link":"/tags/DeepFM/"},{"name":"BuckSort","slug":"BuckSort","link":"/tags/BuckSort/"},{"name":"Sorting","slug":"Sorting","link":"/tags/Sorting/"},{"name":"Parallel Computing","slug":"Parallel-Computing","link":"/tags/Parallel-Computing/"},{"name":"Dropout","slug":"Dropout","link":"/tags/Dropout/"},{"name":"Binary Tree","slug":"Binary-Tree","link":"/tags/Binary-Tree/"},{"name":"Traversal","slug":"Traversal","link":"/tags/Traversal/"},{"name":"Amdahl&#39;s Law","slug":"Amdahl-s-Law","link":"/tags/Amdahl-s-Law/"},{"name":"Parallel Speedup","slug":"Parallel-Speedup","link":"/tags/Parallel-Speedup/"},{"name":"binary search","slug":"binary-search","link":"/tags/binary-search/"},{"name":"GNN","slug":"GNN","link":"/tags/GNN/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"D3.js","slug":"D3-js","link":"/tags/D3-js/"},{"name":"K-Mean Clustering","slug":"K-Mean-Clustering","link":"/tags/K-Mean-Clustering/"},{"name":"Unsupervised Learning","slug":"Unsupervised-Learning","link":"/tags/Unsupervised-Learning/"},{"name":"non-parametric learning","slug":"non-parametric-learning","link":"/tags/non-parametric-learning/"},{"name":"Convolution Neural Network","slug":"Convolution-Neural-Network","link":"/tags/Convolution-Neural-Network/"},{"name":"Backpropagation","slug":"Backpropagation","link":"/tags/Backpropagation/"},{"name":"commands","slug":"commands","link":"/tags/commands/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"review","slug":"review","link":"/tags/review/"},{"name":"ROC curve","slug":"ROC-curve","link":"/tags/ROC-curve/"},{"name":"Confusion Metric","slug":"Confusion-Metric","link":"/tags/Confusion-Metric/"},{"name":"Cross Validation","slug":"Cross-Validation","link":"/tags/Cross-Validation/"},{"name":"Holdout","slug":"Holdout","link":"/tags/Holdout/"},{"name":"Ensemble Learning","slug":"Ensemble-Learning","link":"/tags/Ensemble-Learning/"},{"name":"Model Evaluation","slug":"Model-Evaluation","link":"/tags/Model-Evaluation/"},{"name":"Model Selection","slug":"Model-Selection","link":"/tags/Model-Selection/"},{"name":"Regression","slug":"Regression","link":"/tags/Regression/"},{"name":"Variable Selection","slug":"Variable-Selection","link":"/tags/Variable-Selection/"},{"name":"Collaborative Filtering","slug":"Collaborative-Filtering","link":"/tags/Collaborative-Filtering/"},{"name":"PySpark","slug":"PySpark","link":"/tags/PySpark/"},{"name":"Data Analysis","slug":"Data-Analysis","link":"/tags/Data-Analysis/"},{"name":"KMean Clustering","slug":"KMean-Clustering","link":"/tags/KMean-Clustering/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"Bagging","slug":"Bagging","link":"/tags/Bagging/"},{"name":"Boosting","slug":"Boosting","link":"/tags/Boosting/"},{"name":"Stacking","slug":"Stacking","link":"/tags/Stacking/"},{"name":"Nature Language Processing","slug":"Nature-Language-Processing","link":"/tags/Nature-Language-Processing/"},{"name":"Word vector","slug":"Word-vector","link":"/tags/Word-vector/"},{"name":"Natural Language Representations","slug":"Natural-Language-Representations","link":"/tags/Natural-Language-Representations/"},{"name":"Datawhale Team Learning","slug":"Datawhale-Team-Learning","link":"/tags/Datawhale-Team-Learning/"},{"name":"Wide&amp;Deep Model","slug":"Wide-Deep-Model","link":"/tags/Wide-Deep-Model/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Negative Sampling","slug":"Negative-Sampling","link":"/tags/Negative-Sampling/"},{"name":"Word Embedding","slug":"Word-Embedding","link":"/tags/Word-Embedding/"},{"name":"DIN","slug":"DIN","link":"/tags/DIN/"},{"name":"Regular Expression","slug":"Regular-Expression","link":"/tags/Regular-Expression/"},{"name":"BeautifulSoup","slug":"BeautifulSoup","link":"/tags/BeautifulSoup/"},{"name":"Web Scrapping","slug":"Web-Scrapping","link":"/tags/Web-Scrapping/"},{"name":"Blending","slug":"Blending","link":"/tags/Blending/"},{"name":"P-value","slug":"P-value","link":"/tags/P-value/"},{"name":"Independence Test","slug":"Independence-Test","link":"/tags/Independence-Test/"},{"name":"Data Mining","slug":"Data-Mining","link":"/tags/Data-Mining/"},{"name":"NeuralFM","slug":"NeuralFM","link":"/tags/NeuralFM/"},{"name":"insertion sort","slug":"insertion-sort","link":"/tags/insertion-sort/"},{"name":"bubble sort","slug":"bubble-sort","link":"/tags/bubble-sort/"},{"name":"merge sort","slug":"merge-sort","link":"/tags/merge-sort/"},{"name":"quick sort","slug":"quick-sort","link":"/tags/quick-sort/"},{"name":"DCN","slug":"DCN","link":"/tags/DCN/"},{"name":"LGBM","slug":"LGBM","link":"/tags/LGBM/"},{"name":"Wide and Deep Model","slug":"Wide-and-Deep-Model","link":"/tags/Wide-and-Deep-Model/"},{"name":"Recommendation System","slug":"Recommendation-System","link":"/tags/Recommendation-System/"},{"name":"Hypothesis Test","slug":"Hypothesis-Test","link":"/tags/Hypothesis-Test/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Boosting Machine","slug":"Boosting-Machine","link":"/tags/Boosting-Machine/"},{"name":"Wide and Deep","slug":"Wide-and-Deep","link":"/tags/Wide-and-Deep/"}],"categories":[{"name":"Machine Learning","slug":"Machine-Learning","link":"/categories/Machine-Learning/"},{"name":"NLP","slug":"NLP","link":"/categories/NLP/"},{"name":"Recommendation System","slug":"Recommendation-System","link":"/categories/Recommendation-System/"},{"name":"Parallel Computing","slug":"Parallel-Computing","link":"/categories/Parallel-Computing/"},{"name":"Deep Learning","slug":"Deep-Learning","link":"/categories/Deep-Learning/"},{"name":"Data Structure","slug":"Data-Structure","link":"/categories/Data-Structure/"},{"name":"Searching","slug":"Searching","link":"/categories/Searching/"},{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Data Strucure","slug":"Searching/Data-Strucure","link":"/categories/Searching/Data-Strucure/"},{"name":"PySpark","slug":"PySpark","link":"/categories/PySpark/"},{"name":"Accuracy Improvement","slug":"Machine-Learning/Accuracy-Improvement","link":"/categories/Machine-Learning/Accuracy-Improvement/"},{"name":"Machine Learning","slug":"NLP/Machine-Learning","link":"/categories/NLP/Machine-Learning/"},{"name":"Data Collection","slug":"Data-Collection","link":"/categories/Data-Collection/"},{"name":"Statistic","slug":"Statistic","link":"/categories/Statistic/"},{"name":"Sorting","slug":"Data-Structure/Sorting","link":"/categories/Data-Structure/Sorting/"},{"name":"Report","slug":"Report","link":"/categories/Report/"},{"name":"Web","slug":"Web","link":"/categories/Web/"}]}